/*  ---------------------------------------------------------------------------

    (c) copyright 2021 Altair Semiconductor, Ltd. All rights reserved.

    This software, in source or object form (the "Software"), is the
    property of Altair Semiconductor Ltd. (the "Company") and/or its
    licensors, which have all right, title and interest therein, You
    may use the Software only in  accordance with the terms of written
    license agreement between you and the Company (the "License").
    Except as expressly stated in the License, the Company grants no
    licenses by implication, estoppel, or otherwise. If you are not
    aware of or do not agree to the License terms, you may not use,
    copy or modify the Software. You may use the source code of the
    Software only for your internal purposes and may not distribute the
    source code of the Software, any part thereof, or any derivative work
    thereof, to any third party, except pursuant to the Company's prior
    written consent.
    The Software is the confidential information of the Company.

   ------------------------------------------------------------------------- */


/** @addtogroup Sony Semiconductor Israel
  * @{
  */


/** @addtogroup ALT1250
  * @{
  */


#ifndef ALT1250_H
#define ALT1250_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M4 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  ALT1250 Specific Interrupt Numbers  =========================================== */
  AUXADC_INT0_IRQn          =   2,              /*!< 2  AUXADC_INT0 Interrupt                                                  */
  AUXADC_INT1_IRQn          =   3,              /*!< 3  AUXADC_INT1 Interrupt                                                  */
  AUXADC_INT2_IRQn          =   4,              /*!< 4  AUXADC_INT2 Interrupt                                                  */
  AUXADC_INT3_IRQn          =   5,              /*!< 5  AUXADC_INT3 Interrupt                                                  */
  AUXADC_INT4_IRQn          =   6,              /*!< 6  AUXADC_INT4 Interrupt                                                  */
  AUXADC_INT5_IRQn          =   7,              /*!< 7  AUXADC_INT5 Interrupt                                                  */
  AUXADC_INT6_IRQn          =   8,              /*!< 8  AUXADC_INT6 Interrupt                                                  */
  AUXADC_INT7_IRQn          =   9,              /*!< 9  AUXADC_INT7 Interrupt                                                  */
  GDMA_CH0_IRQn             =  10,              /*!< 10 GDMA channel 0 Interrupt                                               */
  GDMA_CH1_IRQn             =  11,              /*!< 11 GDMA channel 1 Interrupt                                               */
  GDMA_CH2_IRQn             =  12,              /*!< 12 GDMA channel 2 Interrupt                                               */
  GDMA_CH3_IRQn             =  13,              /*!< 13 GDMA channel 3 Interrupt                                               */
  GDMA_CH4_IRQn             =  14,              /*!< 14 GDMA channel 4 Interrupt                                               */
  GDMA_CH5_IRQn             =  15,              /*!< 15 GDMA channel 5 Interrupt                                               */
  GDMA_CH6_IRQn             =  16,              /*!< 16 GDMA channel 6 Interrupt                                               */
  GDMA_CH7_IRQn             =  17,              /*!< 17 GDMA channel 7 Interrupt                                               */
  UARTF0_IRQn               =  22,              /*!< 22 UARTF0 Interrupt                                                       */
  UARTF0_ERR_IRQn           =  23,              /*!< 23 UARTF0_ERR Interrupt                                                   */
  UARTF1_IRQn               =  24,              /*!< 24 UARTF1 Interrupt                                                       */
  UARTF1_ERR_IRQn           =  25,              /*!< 25 UARTF1_ERR Interrupt                                                   */
  SPIS0_IRQn                =  26,              /*!< 26 SPIS0 Interrupt                                                        */
  SPIS0_ERR_IRQn            =  27,              /*!< 27 SPIS0_ERR Interrupt                                                    */
  I2C0_ERR_IRQn             =  28,              /*!< 28 I2C0_ERR Interrupt                                                     */
  I2C0_IRQn                 =  29,              /*!< 29 I2C0 Interrupt                                                         */
  I2C1_ERR_IRQn             =  30,              /*!< 30 I2C1_ERR Interrupt                                                     */
  I2C1_IRQn                 =  31,              /*!< 31 I2C1 Interrupt                                                         */
  SPIM0_ERR_IRQn            =  32,              /*!< 32 SPIM0_ERR Interrupt                                                    */
  SPIM0_IRQn                =  33,              /*!< 33 SPIM0 Interrupt                                                        */
  SPIM1_ERR_IRQn            =  34,              /*!< 34 SPIM1_ERR Interrupt                                                    */
  SPIM1_IRQn                =  35,              /*!< 35 SPIM1 Interrupt                                                        */
  UARTI0_IRQn               =  36,              /*!< 36 UARTI0 Interrupt                                                       */
  UARTI1_IRQn               =  37,              /*!< 37 UARTI1 Interrupt                                                       */
  UARTI2_IRQn               =  38,              /*!< 38 UARTI2 Interrupt                                                       */
  GPIO0_IRQn                =  41,              /*!< 41 GPIO0 Interrupt                                                        */
  GPIO1_IRQn                =  42,              /*!< 42 GPIO1 Interrupt                                                        */
  GPIO2_IRQn                =  43,              /*!< 43 GPIO2 Interrupt                                                        */
  GPIO3_IRQn                =  44,              /*!< 44 GPIO3 Interrupt                                                        */
  GPIO4_IRQn                =  45,              /*!< 45 GPIO4 Interrupt                                                        */
  GPIO5_IRQn                =  46,              /*!< 46 GPIO5 Interrupt                                                        */
  GPIO6_IRQn                =  47,              /*!< 47 GPIO6 Interrupt                                                        */
  GPIO7_IRQn                =  48,              /*!< 48 GPIO7 Interrupt                                                        */
  GPIO8_IRQn                =  49,              /*!< 49 GPIO8 Interrupt                                                        */
  GPIO9_IRQn                =  50,              /*!< 50 GPIO9 Interrupt                                                        */
  GP_Timer_0_IRQn           =  51,              /*!< 51 GP_Timer_0 Interrupt                                                   */
  GP_Timer_1_IRQn           =  52,              /*!< 52 GP_Timer_1 Interrupt                                                   */
  Shadow_32K_Timer_IRQn     =  53,              /*!< 53 Shadow_32K_Timer Interrupt                                             */
  WD_IRQn                   =  55,              /*!< 55 WD Interrupt                                                           */
  GPM_IO_WAKEUP_IRQn        =  56,              /*!< 56 GPM_IO_WAKEUP Interrupt                                                */
  ATMCTR_MAILBOX_IRQn       =  57               /*!< 57 ATMCTR_MAILBOX Interrupt                                               */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M4 Processor and Core Peripherals  =========================== */
#define __CM4_REV                 0x0001U       /*!< CM4 Core Revision                                                         */
#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"                           /*!< ARM Cortex-M4 processor and core peripherals                              */
#include "system_ALT125x.h"                     /*!< ALT1250 System                                                            */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                        AUX_ADC_B0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Control over logical channel 0 (AUX_ADC_B0)
  */

typedef struct {                                /*!< (@ 0x0C111000) AUX_ADC_B0 Structure                                       */
  
  union {
    __IOM uint32_t RESULT;                      /*!< (@ 0x00000000) RESULT                                                     */
    
    struct {
      __IM  uint32_t RESULT     : 12;           /*!< [11..0] aux adc source result                                             */
            uint32_t            : 20;
    } RESULT_b;
  } ;
  
  union {
    __IOM uint32_t RESULT_AND_MARKER;           /*!< (@ 0x00000004) RESULT_AND_MARKER                                          */
    
    struct {
      __IM  uint32_t RESULT     : 12;           /*!< [11..0] aux adc source result                                             */
      __IM  uint32_t MARKER     : 1;            /*!< [12..12] sticky indication for new sample                                 */
            uint32_t            : 19;
    } RESULT_AND_MARKER_b;
  } ;
  
  union {
    __IOM uint32_t RESULT_AND_MARKER_CLR;       /*!< (@ 0x00000008) RESULT_AND_MARKER_CLR                                      */
    
    struct {
      __IM  uint32_t RESULT     : 12;           /*!< [11..0] aux adc source result                                             */
      __IOM uint32_t MARKER     : 1;            /*!< [12..12] sticky indication for new sample - read clear                    */
            uint32_t            : 19;
    } RESULT_AND_MARKER_CLR_b;
  } ;
  
  union {
    __IOM uint32_t SOURCE_SELECT;               /*!< (@ 0x0000000C) SOURCE_SELECT                                              */
    
    struct {
      __IM  uint32_t SOURCE_SELECT : 3;         /*!< [2..0] analog source select as defined by OTP/flash                       */
            uint32_t            : 29;
    } SOURCE_SELECT_b;
  } ;
  
  union {
    __IOM uint32_t CFG;                         /*!< (@ 0x00000010) CFG                                                        */
    
    struct {
      __IOM uint32_t EN_SAMPLE  : 1;            /*!< [0..0] enable sample acquisition                                          */
      __IOM uint32_t EN_OVERWRITE : 1;          /*!< [1..1] allow overwriting of result register when sticky indication
                                                     is true                                                                   */
      __IOM uint32_t EN_AGU     : 1;            /*!< [2..2] enable writing of incoming samples into the retention
                                                     memory                                                                    */
      __IOM uint32_t AGU_ACCUMULATE : 1;        /*!< [3..3] write accumulated (averaged) samples to the AGU                    */
      __IOM uint32_t EN_GATED   : 1;            /*!< [4..4] mask acquisition if last sample was not read yet (marker
                                                     is set high). Not valid if agu mode is enabled.                           */
            uint32_t            : 3;
      __IOM uint32_t AVG_PROGRAM : 7;           /*!< [14..8] pre configuration for accumulator counter. Loaded each
                                                     time aux_adc_soc is writen providing avg_program_en is
                                                     set to '1'                                                                */
      __IOM uint32_t AVG_PROGRAM_EN : 1;        /*!< [15..15] enabler for accumulation programming                             */
            uint32_t            : 16;
    } CFG_b;
  } ;
  
  union {
    __IOM uint32_t AGU_STATUS;                  /*!< (@ 0x00000014) AGU_STATUS                                                 */
    
    struct {
      __IM  uint32_t AGU_STATUS : 21;           /*!< [20..0] current address in retention memory                               */
            uint32_t            : 11;
    } AGU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t AVG_CNT;                     /*!< (@ 0x00000018) AVG_CNT                                                    */
    
    struct {
      __IOM uint32_t AVG_CNT    : 7;            /*!< [6..0] one set to non-zero allows accumulation of incoming samples.
                                                     Decrements on each sample. Assume one extra accumulation
                                                     - so should be set to 15 for 16 sample accumulation/averaging             */
            uint32_t            : 25;
    } AVG_CNT_b;
  } ;
  
  union {
    __IOM uint32_t AVG_ACC;                     /*!< (@ 0x0000001C) AVG_ACC                                                    */
    
    struct {
      __IM  uint32_t AVG_ACC    : 19;           /*!< [18..0] accumulation result for averaging mechanism                       */
            uint32_t            : 13;
    } AVG_ACC_b;
  } ;
  
  union {
    __IOM uint32_t AVG_64_RESULT;               /*!< (@ 0x00000020) AVG_64_RESULT                                              */
    
    struct {
      __IM  uint32_t AVG_64_RESULT : 12;        /*!< [11..0] normalized result of averaging mechanism in the case
                                                     of x64 averaging (read clear)                                             */
            uint32_t            : 20;
    } AVG_64_RESULT_b;
  } ;
  
  union {
    __IOM uint32_t AVG_MAX;                     /*!< (@ 0x00000024) AVG_MAX                                                    */
    
    struct {
      __IM  uint32_t AVG_MAX    : 12;           /*!< [11..0] max single result received during averaging process               */
            uint32_t            : 20;
    } AVG_MAX_b;
  } ;
  
  union {
    __IOM uint32_t AVG_MIN;                     /*!< (@ 0x00000028) AVG_MIN                                                    */
    
    struct {
      __IM  uint32_t AVG_MIN    : 12;           /*!< [11..0] min single result received during averaging process               */
            uint32_t            : 20;
    } AVG_MIN_b;
  } ;
  
  union {
    __IOM uint32_t ALRM_CFG;                    /*!< (@ 0x0000002C) ALRM_CFG                                                   */
    
    struct {
      __IOM uint32_t ALRM_TH    : 12;           /*!< [11..0] configurable threshold                                            */
      __IOM uint32_t ALRM_EN_TH_HIGH : 1;       /*!< [12..12] enable max threshold. Generate interrupt if value >
                                                     th                                                                        */
      __IOM uint32_t ALRM_EN_TH_LOW : 1;        /*!< [13..13] enable min threshold. Generate interrupt if value <
                                                     th                                                                        */
      __IOM uint32_t AVG8_ALRM_EN_TH_HIGH : 1;  /*!< [14..14] enable max threshold. Generate interrupt if accumulated
                                                     value > th*8                                                              */
      __IOM uint32_t AVG8_ALRM_EN_TH_LOW : 1;   /*!< [15..15] enable min threshold. Generate interrupt if accumulated
                                                     value < th*8                                                              */
            uint32_t            : 16;
    } ALRM_CFG_b;
  } ;
  
  union {
    __IOM uint32_t ALRM_READ;                   /*!< (@ 0x00000030) ALRM_READ                                                  */
    
    struct {
      __IM  uint32_t ALRM_READ  : 12;           /*!< [11..0] value which caused alarm interrupt                                */
            uint32_t            : 20;
    } ALRM_READ_b;
  } ;
  
  union {
    __IOM uint32_t IRPT;                        /*!< (@ 0x00000034) IRPT                                                       */
    
    struct {
      __IM  uint32_t AVG_DONE   : 1;            /*!< [0..0] accumulation/averaging done interrupt                              */
      __IM  uint32_t ALRM       : 1;            /*!< [1..1] alarm interrupt                                                    */
      __IM  uint32_t OVERWRITE  : 1;            /*!< [2..2] data register overwrite                                            */
      __IM  uint32_t RETENTION_FAILURE : 1;     /*!< [3..3] retention memory busy                                              */
            uint32_t            : 28;
    } IRPT_b;
  } ;
  
  union {
    __IOM uint32_t IRPT_CLR;                    /*!< (@ 0x00000038) IRPT_CLR                                                   */
    
    struct {
      __IOM uint32_t AVG_DONE   : 1;            /*!< [0..0] accumulation/averaging done interrupt                              */
      __IOM uint32_t ALRM       : 1;            /*!< [1..1] alarm interrupt                                                    */
      __IOM uint32_t OVERWRITE  : 1;            /*!< [2..2] data register overwrite                                            */
      __IOM uint32_t RETENTION_FAILURE : 1;     /*!< [3..3] retention memory busy                                              */
            uint32_t            : 28;
    } IRPT_CLR_b;
  } ;
  
  union {
    __IOM uint32_t IRPT_EN;                     /*!< (@ 0x0000003C) IRPT_EN                                                    */
    
    struct {
      __IOM uint32_t AVG_DONE   : 1;            /*!< [0..0] enable accumulation/averaging done interrupt                       */
      __IOM uint32_t ALRM       : 1;            /*!< [1..1] enable alarm interrupt                                             */
      __IOM uint32_t OVERWRITE  : 1;            /*!< [2..2] enable data register overwrite                                     */
      __IOM uint32_t RETENTION_FAILURE : 1;     /*!< [3..3] enable retention memory busy                                       */
            uint32_t            : 28;
    } IRPT_EN_b;
  } ;
} AUX_ADC_Type;                                 /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                           GDMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose DMA engine (GDMA)
  */

typedef struct {                                /*!< (@ 0x01540000) GDMA Structure                                             */
  
  union {
    __IOM uint32_t CMD0_CNT_INC;                /*!< (@ 0x00000000) CMD0_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD0_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD0_BASE_ADDR;              /*!< (@ 0x00000004) CMD0_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD0_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD0_INDEX;                  /*!< (@ 0x00000008) CMD0_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD0_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD0_SIZE;                   /*!< (@ 0x0000000C) CMD0_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD0_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD0_STATUS;                 /*!< (@ 0x00000010) CMD0_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD0_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t STAT0_INDEX;                 /*!< (@ 0x00000020) STAT0_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT0_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED1[7];
  
  union {
    __IOM uint32_t CMD1_CNT_INC;                /*!< (@ 0x00000040) CMD1_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD1_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD1_BASE_ADDR;              /*!< (@ 0x00000044) CMD1_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD1_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD1_INDEX;                  /*!< (@ 0x00000048) CMD1_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD1_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD1_SIZE;                   /*!< (@ 0x0000004C) CMD1_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD1_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD1_STATUS;                 /*!< (@ 0x00000050) CMD1_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD1_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t STAT1_INDEX;                 /*!< (@ 0x00000060) STAT1_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT1_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED3[7];
  
  union {
    __IOM uint32_t CMD2_CNT_INC;                /*!< (@ 0x00000080) CMD2_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD2_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD2_BASE_ADDR;              /*!< (@ 0x00000084) CMD2_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD2_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD2_INDEX;                  /*!< (@ 0x00000088) CMD2_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD2_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD2_SIZE;                   /*!< (@ 0x0000008C) CMD2_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD2_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD2_STATUS;                 /*!< (@ 0x00000090) CMD2_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD2_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t STAT2_INDEX;                 /*!< (@ 0x000000A0) STAT2_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT2_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED5[7];
  
  union {
    __IOM uint32_t CMD3_CNT_INC;                /*!< (@ 0x000000C0) CMD3_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD3_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD3_BASE_ADDR;              /*!< (@ 0x000000C4) CMD3_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD3_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD3_INDEX;                  /*!< (@ 0x000000C8) CMD3_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD3_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD3_SIZE;                   /*!< (@ 0x000000CC) CMD3_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD3_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD3_STATUS;                 /*!< (@ 0x000000D0) CMD3_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD3_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t STAT3_INDEX;                 /*!< (@ 0x000000E0) STAT3_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT3_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED7[7];
  
  union {
    __IOM uint32_t CMD4_CNT_INC;                /*!< (@ 0x00000100) CMD4_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD4_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD4_BASE_ADDR;              /*!< (@ 0x00000104) CMD4_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD4_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD4_INDEX;                  /*!< (@ 0x00000108) CMD4_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD4_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD4_SIZE;                   /*!< (@ 0x0000010C) CMD4_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD4_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD4_STATUS;                 /*!< (@ 0x00000110) CMD4_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD4_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED8[3];
  
  union {
    __IOM uint32_t STAT4_INDEX;                 /*!< (@ 0x00000120) STAT4_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT4_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED9[7];
  
  union {
    __IOM uint32_t CMD5_CNT_INC;                /*!< (@ 0x00000140) CMD5_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD5_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD5_BASE_ADDR;              /*!< (@ 0x00000144) CMD5_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD5_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD5_INDEX;                  /*!< (@ 0x00000148) CMD5_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD5_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD5_SIZE;                   /*!< (@ 0x0000014C) CMD5_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD5_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD5_STATUS;                 /*!< (@ 0x00000150) CMD5_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD5_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t STAT5_INDEX;                 /*!< (@ 0x00000160) STAT5_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT5_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED11[7];
  
  union {
    __IOM uint32_t CMD6_CNT_INC;                /*!< (@ 0x00000180) CMD6_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD6_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD6_BASE_ADDR;              /*!< (@ 0x00000184) CMD6_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD6_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD6_INDEX;                  /*!< (@ 0x00000188) CMD6_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD6_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD6_SIZE;                   /*!< (@ 0x0000018C) CMD6_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD6_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD6_STATUS;                 /*!< (@ 0x00000190) CMD6_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD6_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED12[3];
  
  union {
    __IOM uint32_t STAT6_INDEX;                 /*!< (@ 0x000001A0) STAT6_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT6_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED13[7];
  
  union {
    __IOM uint32_t CMD7_CNT_INC;                /*!< (@ 0x000001C0) CMD7_CNT_INC                                               */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Writing to this register increases the atomic counter
                                                     value; thus causing the DMA start fetching commands from
                                                     the command FIFO                                                          */
            uint32_t            : 24;
    } CMD7_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t CMD7_BASE_ADDR;              /*!< (@ 0x000001C4) CMD7_BASE_ADDR                                             */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] The start address of the command FIFO                             */
    } CMD7_BASE_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD7_INDEX;                  /*!< (@ 0x000001C8) CMD7_INDEX                                                 */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Command pointer - current index to command FIFO                    */
            uint32_t            : 24;
    } CMD7_INDEX_b;
  } ;
  
  union {
    __IOM uint32_t CMD7_SIZE;                   /*!< (@ 0x000001CC) CMD7_SIZE                                                  */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The size of the command FIFO                                       */
            uint32_t            : 24;
    } CMD7_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t CMD7_STATUS;                 /*!< (@ 0x000001D0) CMD7_STATUS                                                */
    
    struct {
      __IM  uint32_t CNT        : 8;            /*!< [7..0] The value of the command FIFO counter (number of commands
                                                     pending)                                                                  */
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] No commands are pending                                            */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] Number of commands pending reached to the MAX                      */
            uint32_t            : 22;
    } CMD7_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED14[3];
  
  union {
    __IOM uint32_t STAT7_INDEX;                 /*!< (@ 0x000001E0) STAT7_INDEX                                                */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Status pointer - current index to the command FIFO                 */
            uint32_t            : 24;
    } STAT7_INDEX_b;
  } ;
  __IM  uint32_t  RESERVED15[135];
  
  union {
    __IOM uint32_t DMA_CTRL;                    /*!< (@ 0x00000400) DMA_CTRL                                                   */
    
    struct {
      __IOM uint32_t STOP       : 1;            /*!< [0..0] stop and halt DMA                                                  */
      __IOM uint32_t FLUSH      : 1;            /*!< [1..1] flush command and halt DMA                                         */
      __IOM uint32_t CLEAR_FIFO : 1;            /*!< [2..2] Clear the FIFO                                                     */
      __IOM uint32_t RESET_MAIN_CTRL : 1;       /*!< [3..3] Reset the main ctrl SM                                             */
      __IOM uint32_t RESET_WR   : 1;            /*!< [4..4] Reset the WR SM                                                    */
      __IOM uint32_t RESET_WR_BUFF : 1;         /*!< [5..5] Reset the WR Buff SM                                               */
      __IOM uint32_t RESET_WR_BD : 1;           /*!< [6..6] Reset the WR BD SM                                                 */
      __IOM uint32_t RESET_RD   : 1;            /*!< [7..7] Reset the RD SM                                                    */
      __IOM uint32_t RESET_RD_BUFF : 1;         /*!< [8..8] Reset the RD Buff SM                                               */
      __IOM uint32_t RESET_RD_BD : 1;           /*!< [9..9] Reset the RD BD SM                                                 */
      __IOM uint32_t WRITEBACK_BD_MODE : 1;     /*!< [10..10] 1- After each BD read the SM writes back to the BD
                                                     structure 0 - no write back                                               */
            uint32_t            : 21;
    } DMA_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_ARB_CTRL;                /*!< (@ 0x00000404) DMA_ARB_CTRL                                               */
    
    struct {
      __IOM uint32_t MODE       : 2;            /*!< [1..0] Determine the arbitration between channels scheme:0 &#8211;
                                                     round robin. 1 &#8211; fixed priority by order. 2-mixed
                                                     priority according to the priorities field                                */
            uint32_t            : 2;
      __IOM uint32_t PRIORITIES : 8;            /*!< [11..4] 1 in one of the bits puts the channel in the high pririty
                                                     group (only in mixed priority mode_                                       */
            uint32_t            : 20;
    } DMA_ARB_CTRL_b;
  } ;
  __IM  uint32_t  RESERVED16[4];
  
  union {
    __IOM uint32_t RD_FIFO_THRESHOLD;           /*!< (@ 0x00000418) RD_FIFO_THRESHOLD                                          */
    
    struct {
      __IOM uint32_t DATA       : 9;            /*!< [8..0] when the numbers of bytes in the fifo is less than the
                                                     treshold - it will indictae an internal status to the RD
                                                     machine - SW should not re-configure it                                   */
            uint32_t            : 23;
    } RD_FIFO_THRESHOLD_b;
  } ;
  
  union {
    __IOM uint32_t WR_FIFO_THRESHOLD;           /*!< (@ 0x0000041C) WR_FIFO_THRESHOLD                                          */
    
    struct {
      __IOM uint32_t DATA       : 9;            /*!< [8..0] when the numbers of bytes in the fifo is more than the
                                                     threshold - it will indicate an internal status to the
                                                     WR machine - SW should not re-configure it                                */
            uint32_t            : 23;
    } WR_FIFO_THRESHOLD_b;
  } ;
  __IM  uint32_t  RESERVED17[249];
  
  union {
    __IOM uint32_t DMA_CHS_DONE_INT_STAT_NO_CLR;/*!< (@ 0x00000804) Channels command done interrupts status                    */
    
    struct {
      __IM  uint32_t CH0_STAT   : 1;            /*!< [0..0] CH0 command done interrupt status                                  */
      __IM  uint32_t CH1_STAT   : 1;            /*!< [1..1] CH1 command done interrupt status                                  */
      __IM  uint32_t CH2_STAT   : 1;            /*!< [2..2] CH2 command done interrupt status                                  */
      __IM  uint32_t CH3_STAT   : 1;            /*!< [3..3] CH3 command done interrupt status                                  */
      __IM  uint32_t CH4_STAT   : 1;            /*!< [4..4] CH4 command done interrupt status                                  */
      __IM  uint32_t CH5_STAT   : 1;            /*!< [5..5] CH5 command done interrupt status                                  */
      __IM  uint32_t CH6_STAT   : 1;            /*!< [6..6] CH6 command done interrupt status                                  */
      __IM  uint32_t CH7_STAT   : 1;            /*!< [7..7] CH7 command done interrupt status                                  */
            uint32_t            : 24;
    } DMA_CHS_DONE_INT_STAT_NO_CLR_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH0_DONE_INT_STAT;       /*!< (@ 0x00000808) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH0 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH0_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH1_DONE_INT_STAT;       /*!< (@ 0x0000080C) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH1 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH1_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH2_DONE_INT_STAT;       /*!< (@ 0x00000810) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH2 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH2_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH3_DONE_INT_STAT;       /*!< (@ 0x00000814) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH3 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH3_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH4_DONE_INT_STAT;       /*!< (@ 0x00000818) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH4 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH4_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH5_DONE_INT_STAT;       /*!< (@ 0x0000081C) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH5 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH5_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH6_DONE_INT_STAT;       /*!< (@ 0x00000820) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH6 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH6_DONE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH7_DONE_INT_STAT;       /*!< (@ 0x00000824) Channel command done interrupt read and clear              */
    
    struct {
      __IOM uint32_t STAT       : 1;            /*!< [0..0] CH7 command done interrupt status                                  */
            uint32_t            : 31;
    } DMA_CH7_DONE_INT_STAT_b;
  } ;
  __IM  uint32_t  RESERVED18[246];
  
  union {
    __IOM uint32_t MAIN_SM_STAT;                /*!< (@ 0x00000C00) MAIN_SM_STAT                                               */
    
    struct {
      __IM  uint32_t MAIN_SM_CS : 3;            /*!< [2..0] Main SM Current State                                              */
            uint32_t            : 1;
      __IM  uint32_t RD_CMD_CH  : 8;            /*!< [11..4] Channel SM Current State                                          */
      __IM  uint32_t RD_SM_CS   : 2;            /*!< [13..12] Read SM current state                                            */
      __IM  uint32_t WR_SM_CS   : 2;            /*!< [15..14] Write SM current state                                           */
      __IM  uint32_t CMD_FETCHR_SM_CS : 3;      /*!< [18..16] CMD Fecther SM current state                                     */
            uint32_t            : 1;
      __IM  uint32_t STAT_DISPATCHER_SM_CS : 3; /*!< [22..20] STAT Dispacther SM current state                                 */
            uint32_t            : 9;
    } MAIN_SM_STAT_b;
  } ;
  
  union {
    __IOM uint32_t WR_SM_STAT;                  /*!< (@ 0x00000C04) WR_SM_STAT                                                 */
    
    struct {
      __IM  uint32_t BUFF_CS    : 3;            /*!< [2..0] WR Buffer Atomic SM Current State                                  */
            uint32_t            : 5;
      __IM  uint32_t BD_CS      : 3;            /*!< [10..8] WR BD Atomic SM Current State                                     */
            uint32_t            : 5;
      __IM  uint32_t CMD_RESP_CNT : 5;          /*!< [20..16] WR Buffer resposnse outstanding counter                          */
            uint32_t            : 11;
    } WR_SM_STAT_b;
  } ;
  
  union {
    __IOM uint32_t RD_SM_STAT;                  /*!< (@ 0x00000C08) RD_SM_STAT                                                 */
    
    struct {
      __IM  uint32_t BUFF_CS    : 3;            /*!< [2..0] RD Buffer Atomic SM Current State                                  */
            uint32_t            : 5;
      __IM  uint32_t BD_CS      : 3;            /*!< [10..8] RD BD Atomic SM Current State                                     */
            uint32_t            : 5;
      __IM  uint32_t CMD_RESP_CNT : 5;          /*!< [20..16] RD Buffer resposne outstanding counter                           */
            uint32_t            : 11;
    } RD_SM_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_RD_ADDR_STAT;            /*!< (@ 0x00000C0C) CUR_RD_ADDR_STAT                                           */
    
    struct {
      __IM  uint32_t ADDR       : 32;           /*!< [31..0] current read address                                              */
    } CUR_RD_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_RD_BD_STAT;              /*!< (@ 0x00000C10) CUR_RD_BD_STAT                                             */
    
    struct {
      __IM  uint32_t BD         : 32;           /*!< [31..0] current read BD address                                           */
    } CUR_RD_BD_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_RD_LEN_STAT;             /*!< (@ 0x00000C14) CUR_RD_LEN_STAT                                            */
    
    struct {
      __IM  uint32_t LEN        : 16;           /*!< [15..0] current read BD length                                            */
            uint32_t            : 16;
    } CUR_RD_LEN_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_WR_ADDR_STAT;            /*!< (@ 0x00000C18) CUR_WR_ADDR_STAT                                           */
    
    struct {
      __IM  uint32_t ADDR       : 32;           /*!< [31..0] current write address                                             */
    } CUR_WR_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_WR_BD_STAT;              /*!< (@ 0x00000C1C) CUR_WR_BD_STAT                                             */
    
    struct {
      __IM  uint32_t BD         : 32;           /*!< [31..0] current write BD address                                          */
    } CUR_WR_BD_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_WR_LEN_STAT;             /*!< (@ 0x00000C20) CUR_WR_LEN_STAT                                            */
    
    struct {
      __IM  uint32_t LEN        : 16;           /*!< [15..0] current write BD length                                           */
            uint32_t            : 16;
    } CUR_WR_LEN_STAT_b;
  } ;
  
  union {
    __IOM uint32_t CUR_CMD_IDX;                 /*!< (@ 0x00000C24) CUR_CMD_IDX                                                */
    
    struct {
      __IM  uint32_t ID         : 8;            /*!< [7..0] Current command ID in process                                      */
            uint32_t            : 24;
    } CUR_CMD_IDX_b;
  } ;
  __IM  uint32_t  RESERVED19[6];
  
  union {
    __IOM uint32_t ERRORS_STAT;                 /*!< (@ 0x00000C40) ERRORS_STAT                                                */
    
    struct {
      __IM  uint32_t CMD_FETCHER : 1;           /*!< [0..0] CMD_FETCHER                                                        */
      __IM  uint32_t RD_BD      : 1;            /*!< [1..1] RD_BD                                                              */
      __IM  uint32_t RD_BD_SAMP_CNTR : 1;       /*!< [2..2] The RD BD SM is out of sync                                        */
      __IM  uint32_t RD_BD_ADDR : 1;            /*!< [3..3] The RD BD address is not 4 words aligned                           */
      __IM  uint32_t RD_BD_NEXT_ADDR : 1;       /*!< [4..4] The RD BD structure next address field is not 4 words
                                                     aligned                                                                   */
            uint32_t            : 1;
      __IM  uint32_t WR_BD      : 1;            /*!< [6..6] WR_BD                                                              */
      __IM  uint32_t WR_BD_SAMP_CNTR : 1;       /*!< [7..7] The WR BD SM is out of sync                                        */
      __IM  uint32_t WR_BD_ADDR : 1;            /*!< [8..8] The WR BD address is not 4 words aligned                           */
      __IM  uint32_t WR_BD_NEXT_ADDR : 1;       /*!< [9..9] The WR BD structure next address field is not 4 words
                                                     aligned                                                                   */
            uint32_t            : 22;
    } ERRORS_STAT_b;
  } ;
  
  union {
    __IOM uint32_t TRANS_CNTR;                  /*!< (@ 0x00000C44) TRANS_CNTR                                                 */
    
    struct {
      __IM  uint32_t DMA_TRANS_CNTR : 8;        /*!< [7..0] Transaction counter - for debug                                    */
            uint32_t            : 24;
    } TRANS_CNTR_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CUR_RD_ACUM_LEN_STAT;    /*!< (@ 0x00000C48) DMA_CUR_RD_ACUM_LEN_STAT                                   */
    
    struct {
      __IM  uint32_t CUR_RD_ACUM_LEN : 24;      /*!< [23..0] Current RD accumulated length - for debug                         */
            uint32_t            : 8;
    } DMA_CUR_RD_ACUM_LEN_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_NEXT_RD_BD_ADDR_STAT;    /*!< (@ 0x00000C4C) DMA_NEXT_RD_BD_ADDR_STAT                                   */
    
    struct {
      __IM  uint32_t NEXT_BD_RD_ADDR : 32;      /*!< [31..0] Next RD BD address - for debug                                    */
    } DMA_NEXT_RD_BD_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_START_RD_ADDR_STAT;      /*!< (@ 0x00000C50) DMA_START_RD_ADDR_STAT                                     */
    
    struct {
      __IM  uint32_t START_RD_ADDR : 32;        /*!< [31..0] Read start address - for debug                                    */
    } DMA_START_RD_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CUR_WR_ACUM_LEN_STAT;    /*!< (@ 0x00000C54) DMA_CUR_WR_ACUM_LEN_STAT                                   */
    
    struct {
      __IM  uint32_t CUR_WR_ACUM_LEN : 24;      /*!< [23..0] Current WR accumulated length - for debug                         */
            uint32_t            : 8;
    } DMA_CUR_WR_ACUM_LEN_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_NEXT_WR_BD_ADDR_STAT;    /*!< (@ 0x00000C58) DMA_NEXT_WR_BD_ADDR_STAT                                   */
    
    struct {
      __IM  uint32_t NEXT_BD_WR_ADDR : 32;      /*!< [31..0] Next WR BD address - for debug                                    */
    } DMA_NEXT_WR_BD_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_START_WR_ADDR_STAT;      /*!< (@ 0x00000C5C) DMA_START_WR_ADDR_STAT                                     */
    
    struct {
      __IM  uint32_t START_WR_ADDR : 32;        /*!< [31..0] Write start address - for debug                                   */
    } DMA_START_WR_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_ALIGN_F2AL_AVAIL;        /*!< (@ 0x00000C60) DMA_ALIGN_F2AL_AVAIL                                       */
    
    struct {
      __IM  uint32_t DATA       : 9;            /*!< [8..0] How much place is available for the WR machine to read
                                                     from the FIFO                                                             */
            uint32_t            : 23;
    } DMA_ALIGN_F2AL_AVAIL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_ALIGN_AL2F_AVAIL;        /*!< (@ 0x00000C64) DMA_ALIGN_AL2F_AVAIL                                       */
    
    struct {
      __IM  uint32_t DATA       : 9;            /*!< [8..0] How much place is not available for the RD machine to
                                                     write to the FIFO                                                         */
            uint32_t            : 23;
    } DMA_ALIGN_AL2F_AVAIL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_RD_BW_CTRL_STAT;         /*!< (@ 0x00000C68) DMA_RD_BW_CTRL_STAT                                        */
    
    struct {
      __IOM uint32_t LIMIT      : 16;           /*!< [15..0] The start value of the RD Buff BW counter                         */
      __IM  uint32_t COUNTER    : 16;           /*!< [31..16] The current value of the RD Buff BW counter                      */
    } DMA_RD_BW_CTRL_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_WR_BW_CTRL_STAT;         /*!< (@ 0x00000C6C) DMA_WR_BW_CTRL_STAT                                        */
    
    struct {
      __IOM uint32_t LIMIT      : 16;           /*!< [15..0] The start value of the WR Buff BW counter                         */
      __IM  uint32_t COUNTER    : 16;           /*!< [31..16] The current value of the WR Buff BW counter                      */
    } DMA_WR_BW_CTRL_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_RD_BW_CTRL_INT;          /*!< (@ 0x00000C70) DMA_RD_BW_CTRL_INT                                         */
    
    struct {
      __IOM uint32_t WAIT_FOR_FIFO : 1;         /*!< [0..0] The RD Buff BW counter is zero but there is not enough
                                                     space in the FIFO for the read data                                       */
      __IOM uint32_t LIMIT      : 1;            /*!< [1..1] The RD Buff BW counter is zero but the RD data did not
                                                     arrived                                                                   */
            uint32_t            : 30;
    } DMA_RD_BW_CTRL_INT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_WR_BW_CTRL_INT;          /*!< (@ 0x00000C74) DMA_WR_BW_CTRL_INT                                         */
    
    struct {
      __IOM uint32_t WAIT_FOR_DATA : 1;         /*!< [0..0] The WR Buff BW counter is zero but there is not enough
                                                     data in the FIFO to write                                                 */
      __IOM uint32_t LIMIT      : 1;            /*!< [1..1] The WR Buff BW counter is zero but the WR data was not
                                                     accepted                                                                  */
            uint32_t            : 30;
    } DMA_WR_BW_CTRL_INT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CMD_RD_ADDR_STAT;        /*!< (@ 0x00000C78) DMA_CMD_RD_ADDR_STAT                                       */
    
    struct {
      __IM  uint32_t DATA       : 32;           /*!< [31..0] The current command RD address                                    */
    } DMA_CMD_RD_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CMD_WR_ADDR_STAT;        /*!< (@ 0x00000C7C) DMA_CMD_WR_ADDR_STAT                                       */
    
    struct {
      __IM  uint32_t DATA       : 32;           /*!< [31..0] The current command WR address                                    */
    } DMA_CMD_WR_ADDR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CMD_CMD_LEN_STAT;        /*!< (@ 0x00000C80) DMA_CMD_CMD_LEN_STAT                                       */
    
    struct {
      __IM  uint32_t LENGTH     : 24;           /*!< [23..0] The current command transaction length                            */
      __IM  uint32_t CMD_ID     : 8;            /*!< [31..24] The current command CMD ID                                       */
    } DMA_CMD_CMD_LEN_STAT_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CMD_CTRL_STAT;           /*!< (@ 0x00000C84) DMA_CMD_CTRL_STAT                                          */
    
    struct {
      __IM  uint32_t DATA       : 32;           /*!< [31..0] The current command CTRL                                          */
    } DMA_CMD_CTRL_STAT_b;
  } ;
  __IM  uint32_t  RESERVED20[14];
  
  union {
    __IOM uint32_t DMA_CH0_SEL;                 /*!< (@ 0x00000CC0) DMA_CH0_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH0_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH1_SEL;                 /*!< (@ 0x00000CC4) DMA_CH1_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH1_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH2_SEL;                 /*!< (@ 0x00000CC8) DMA_CH2_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH2_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH3_SEL;                 /*!< (@ 0x00000CCC) DMA_CH3_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH3_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH4_SEL;                 /*!< (@ 0x00000CD0) DMA_CH4_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH4_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH5_SEL;                 /*!< (@ 0x00000CD4) DMA_CH5_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH5_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH6_SEL;                 /*!< (@ 0x00000CD8) DMA_CH6_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH6_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DMA_CH7_SEL;                 /*!< (@ 0x00000CDC) DMA_CH7_SEL                                                */
    
    struct {
      __IOM uint32_t DATA       : 4;            /*!< [3..0] Channel HW handshake selection.This field allows enabling
                                                     HW handshake between DMA channel and HW engine by using
                                                     WAIT indication from the HW engine0 - I2C01 - I2C12 - SPI
                                                     Master1 wdata3 - SPI Master0 wdata4 - external device handshake
                                                     ready signal5 - PCM DMA Ts 0 Rx6 - PCM DMA Ts 1 Rx7 - PCM
                                                     DMA Ts 0 Tx8 - PCM DMA Ts 1 Tx9 - SPI Master1 rdata10 -
                                                     SPI Master0 rdata11 - 12 - 13 - 14 -15 -                                  */
            uint32_t            : 28;
    } DMA_CH7_SEL_b;
  } ;
  __IM  uint32_t  RESERVED21[24];
  
  union {
    __IOM uint32_t DMA_ENDLESS_TRANS_EN;        /*!< (@ 0x00000D40) DMA_ENDLESS_TRANS_EN                                       */
    
    struct {
      __IOM uint32_t ENDLESS_RD_TRANS_EN : 1;   /*!< [0..0] Endless read transaction enable. When enabled; read burst
                                                     will perform endless read transfers from source address
                                                     to FIFO.Endless mode can be either for read or for write
                                                     - not both                                                                */
      __IOM uint32_t ENDLESS_WR_TRANS_EN : 1;   /*!< [1..1] Endless write transaction enable. When enabled; write
                                                     burst will perform endless write transfers from FIFO to
                                                     destination address.Endless mode can be either for read
                                                     or for write - not both                                                   */
            uint32_t            : 30;
    } DMA_ENDLESS_TRANS_EN_b;
  } ;
  
  union {
    __IOM uint32_t DMA_ENDLESS_TRANS_START_ADDR;/*!< (@ 0x00000D44) DMA_ENDLESS_TRANS_START_ADDR                               */
    
    struct {
      __IOM uint32_t ENDLESS_TRANS_START_ADDR : 32;/*!< [31..0] Endless transaction start address. When endless transaction
                                                     is enabled; read/write burst will perform endless data
                                                     transfers. When they reach END_ADDR; they will wrap around
                                                     to START_ADDR. Hence; the transfer will be cyclic. Note
                                                     that the first cycle start address is taken from command.
                                                     Only from the 2nd cycle the start address is taken from
                                                     START_ADDR.                                                               */
    } DMA_ENDLESS_TRANS_START_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t DMA_ENDLESS_TRANS_END_ADDR;  /*!< (@ 0x00000D48) DMA_ENDLESS_TRANS_END_ADDR                                 */
    
    struct {
      __IOM uint32_t ENDLESS_TRANS_END_ADDR : 32;/*!< [31..0] Endless transaction end address. When endless transaction
                                                     is enabled; read/write burst will perform endless data
                                                     transfers. When they reach END_ADDR; they will wrap around
                                                     to START_ADDR. Hence; the transfer will be cyclic. Note
                                                     that the first cycle start address is taken from command.
                                                     Only from the 2nd cycle the start address is taken from
                                                     START_ADDR.                                                               */
    } DMA_ENDLESS_TRANS_END_ADDR_b;
  } ;
} GDMA_Type;                                    /*!< Size = 3404 (0xd4c)                                                       */



/* =========================================================================================================================== */
/* ================                                        UARTF0_CFG                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief UART controller #0 DMA (UARTF0_CFG)
  */

typedef struct {                                /*!< (@ 0x01000000) UARTF0_CFG Structure                                       */
  
  union {
    __IOM uint32_t OCPM_CFG;                    /*!< (@ 0x00000000) OCPM_CFG                                                   */
    
    struct {
      __IOM uint32_t WR_FIFO_THRES_VALUE : 4;   /*!< [3..0] WR_FIFO_THRES_VALUE                                                */
      __IOM uint32_t THRES_WR_SW_BYPASS : 1;    /*!< [4..4] THRES_WR_SW_BYPASS                                                 */
            uint32_t            : 3;
      __IM  uint32_t WR_FIFO_THRES : 4;         /*!< [11..8] WR_FIFO_THRES                                                     */
      __IOM uint32_t RD_FIFO_THRES_VALUE : 4;   /*!< [15..12] RD_FIFO_THRES_VALUE                                              */
      __IOM uint32_t THRES_RD_SW_BYPASS : 1;    /*!< [16..16] THRES_RD_SW_BYPASS                                               */
            uint32_t            : 3;
      __IM  uint32_t RD_FIFO_THRES : 4;         /*!< [23..20] RD_FIFO_THRES                                                    */
      __IOM uint32_t OCP_BRST_ALIGN : 1;        /*!< [24..24] OCP_BRST_ALIGN                                                   */
            uint32_t            : 3;
      __IOM uint32_t MISO_BIG_ENDIAN : 1;       /*!< [28..28] byte endianity of the data input from the bus fabric1
                                                     - big endian0 - little endian                                             */
      __IOM uint32_t MOSI_BIG_ENDIAN : 1;       /*!< [29..29] byte endianity of the data output to the bus fabric1
                                                     - big endian0 - little endian                                             */
            uint32_t            : 2;
    } OCPM_CFG_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_INIT;                   /*!< (@ 0x00000004) OCPM_INIT                                                  */
    
    struct {
      __IOM uint32_t MOSI_RESET_FLUSH : 1;      /*!< [0..0] MOSI_RESET_FLUSH                                                   */
      __IOM uint32_t MISO_RESET_FLUSH : 1;      /*!< [1..1] MISO_RESET_FLUSH                                                   */
            uint32_t            : 6;
      __IOM uint32_t WR_BD_LIST_SIZE_FLUSH : 1; /*!< [8..8] WR_BD_LIST_SIZE_FLUSH                                              */
      __IOM uint32_t WR_BD_LIST_ADDR_FLUSH : 1; /*!< [9..9] WR_BD_LIST_ADDR_FLUSH                                              */
      __IOM uint32_t RD_BD_LIST_SIZE_FLUSH : 1; /*!< [10..10] RD_BD_LIST_SIZE_FLUSH                                            */
      __IOM uint32_t RD_BD_LIST_ADDR_FLUSH : 1; /*!< [11..11] RD_BD_LIST_ADDR_FLUSH                                            */
            uint32_t            : 4;
      __IOM uint32_t RESET_WR_BUFF : 1;         /*!< [16..16] RESET_WR_BUFF                                                    */
            uint32_t            : 7;
      __IOM uint32_t RESET_RD_BUFF : 1;         /*!< [24..24] RESET_RD_BUFF                                                    */
            uint32_t            : 7;
    } OCPM_INIT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_ADDR;                /*!< (@ 0x00000008) OCPM_RD_ADDR                                               */
    
    struct {
      __IOM uint32_t RD_BUFF_START_ADDR : 29;   /*!< [28..0] RD_BUFF_START_ADDR                                                */
            uint32_t            : 3;
    } OCPM_RD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_ADDR;                /*!< (@ 0x0000000C) OCPM_WR_ADDR                                               */
    
    struct {
      __IOM uint32_t WR_BUFF_START_ADDR : 29;   /*!< [28..0] WR_BUFF_START_ADDR                                                */
            uint32_t            : 3;
    } OCPM_WR_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_LEN_CFG;                /*!< (@ 0x00000010) OCPM_LEN_CFG                                               */
    
    struct {
      __IOM uint32_t WR_BUFF_LEN : 16;          /*!< [15..0] WR_BUFF_LEN                                                       */
      __IOM uint32_t RD_BUFF_LEN : 16;          /*!< [31..16] RD_BUFF_LEN                                                      */
    } OCPM_LEN_CFG_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_INT;                 /*!< (@ 0x00000014) OCPM_RD_INT                                                */
    
    struct {
      __IM  uint32_t RD_BD_SIZE_INT : 1;        /*!< [0..0] RD_BD_SIZE_INT                                                     */
      __IM  uint32_t RD_BD_ADDR_INT : 1;        /*!< [1..1] RD_BD_ADDR_INT                                                     */
      __IM  uint32_t WR_BD_SIZE_INT : 1;        /*!< [2..2] WR_BD_SIZE_INT                                                     */
      __IM  uint32_t WR_BD_ADDR_INT : 1;        /*!< [3..3] WR_BD_ADDR_INT                                                     */
            uint32_t            : 28;
    } OCPM_RD_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_CLR_INT;             /*!< (@ 0x00000018) OCPM_RD_CLR_INT                                            */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_INT : 1;        /*!< [0..0] RD_BD_SIZE_INT                                                     */
      __IOM uint32_t RD_BD_ADDR_INT : 1;        /*!< [1..1] RD_BD_ADDR_INT                                                     */
      __IOM uint32_t WR_BD_SIZE_INT : 1;        /*!< [2..2] WR_BD_SIZE_INT                                                     */
      __IOM uint32_t WR_BD_ADDR_INT : 1;        /*!< [3..3] WR_BD_ADDR_INT                                                     */
            uint32_t            : 28;
    } OCPM_RD_CLR_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_MASK_INT;               /*!< (@ 0x0000001C) OCPM_MASK_INT                                              */
    
    struct {
      __IOM uint32_t MASK_RD_BD_SIZE_INT : 1;   /*!< [0..0] MASK_RD_BD_SIZE_INT                                                */
      __IOM uint32_t MASK_RD_BD_ADDR_INT : 1;   /*!< [1..1] MASK_RD_BD_ADDR_INT                                                */
      __IOM uint32_t MASK_WR_BD_SIZE_INT : 1;   /*!< [2..2] MASK_WR_BD_SIZE_INT                                                */
      __IOM uint32_t MASK_WR_BD_ADDR_INT : 1;   /*!< [3..3] MASK_WR_BD_ADDR_INT                                                */
            uint32_t            : 28;
    } OCPM_MASK_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_INT_EN;                 /*!< (@ 0x00000020) OCPM_INT_EN                                                */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_INT_EN : 1;     /*!< [0..0] RD_BD_SIZE_INT_EN                                                  */
      __IOM uint32_t RD_BD_ADDR_INT_EN : 1;     /*!< [1..1] RD_BD_ADDR_INT_EN                                                  */
      __IOM uint32_t WR_BD_SIZE_INT_EN : 1;     /*!< [2..2] WR_BD_SIZE_INT_EN                                                  */
      __IOM uint32_t WR_BD_ADDR_INT_EN : 1;     /*!< [3..3] WR_BD_ADDR_INT_EN                                                  */
            uint32_t            : 28;
    } OCPM_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BUFF_ACTIVE;            /*!< (@ 0x00000024) OCPM_BUFF_ACTIVE                                           */
    
    struct {
      __IOM uint32_t WR_BUFF_ACTIVE : 1;        /*!< [0..0] WR_BUFF_ACTIVE                                                     */
            uint32_t            : 7;
      __IOM uint32_t RD_BUFF_ACTIVE : 1;        /*!< [8..8] RD_BUFF_ACTIVE                                                     */
            uint32_t            : 7;
      __IOM uint32_t RD_BUFF_CYCLIC_EN : 1;     /*!< [16..16] RD_BUFF_CYCLIC_EN                                                */
            uint32_t            : 7;
      __IOM uint32_t WR_BUFF_CYCLIC_EN : 1;     /*!< [24..24] WR_BUFF_CYCLIC_EN                                                */
            uint32_t            : 7;
    } OCPM_BUFF_ACTIVE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_ADDR;             /*!< (@ 0x00000028) OCPM_WR_BD_ADDR                                            */
    
    struct {
      __IOM uint32_t WR_BD_ADDR : 32;           /*!< [31..0] WR_BD_ADDR                                                        */
    } OCPM_WR_BD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_SIZE;             /*!< (@ 0x0000002C) OCPM_WR_BD_SIZE                                            */
    
    struct {
      __IOM uint32_t WR_BD_SIZE : 16;           /*!< [15..0] WR_BD_SIZE                                                        */
            uint32_t            : 16;
    } OCPM_WR_BD_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_ADDR;             /*!< (@ 0x00000030) OCPM_RD_BD_ADDR                                            */
    
    struct {
      __IOM uint32_t RD_BD_ADDR : 32;           /*!< [31..0] RD_BD_ADDR                                                        */
    } OCPM_RD_BD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_SIZE;             /*!< (@ 0x00000034) OCPM_RD_BD_SIZE                                            */
    
    struct {
      __IOM uint32_t RD_BD_SIZE : 16;           /*!< [15..0] RD_BD_SIZE                                                        */
            uint32_t            : 16;
    } OCPM_RD_BD_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_ADDR_STATE;       /*!< (@ 0x00000038) OCPM_WR_BD_ADDR_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_WR_BD_ADDR_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_SIZE_STATE;       /*!< (@ 0x0000003C) OCPM_WR_BD_SIZE_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_WR_BD_SIZE_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_ADDR_STATE;       /*!< (@ 0x00000040) OCPM_RD_BD_ADDR_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_RD_BD_ADDR_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_SIZE_STATE;       /*!< (@ 0x00000044) OCPM_RD_BD_SIZE_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_RD_BD_SIZE_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BD_CFG_THRES;           /*!< (@ 0x00000048) OCPM_BD_CFG_THRES                                          */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_THRES : 5;      /*!< [4..0] RD_BD_SIZE_THRES                                                   */
            uint32_t            : 3;
      __IOM uint32_t RD_BD_ADDR_THRES : 5;      /*!< [12..8] RD_BD_ADDR_THRES                                                  */
            uint32_t            : 3;
      __IOM uint32_t WR_BD_SIZE_THRES : 5;      /*!< [20..16] WR_BD_SIZE_THRES                                                 */
            uint32_t            : 3;
      __IOM uint32_t WR_BD_ADDR_THRES : 5;      /*!< [28..24] WR_BD_ADDR_THRES                                                 */
            uint32_t            : 3;
    } OCPM_BD_CFG_THRES_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_OCP_LEN_STATUS;         /*!< (@ 0x0000004C) OCPM_OCP_LEN_STATUS                                        */
    
    struct {
      __IM  uint32_t OCP_RD_LEN_CNT : 16;       /*!< [15..0] OCP_RD_LEN_CNT                                                    */
      __IM  uint32_t OCP_WR_LEN_CNT : 16;       /*!< [31..16] OCP_WR_LEN_CNT                                                   */
    } OCPM_OCP_LEN_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BUF_FIFO_STATUS;        /*!< (@ 0x00000050) OCPM_BUF_FIFO_STATUS                                       */
    
    struct {
      __IM  uint32_t OCPM_MOSI_FIFO_STATUS : 4; /*!< [3..0] OCPM_MOSI_FIFO_STATUS                                              */
            uint32_t            : 4;
      __IM  uint32_t OCPM_MOSI_FIFO_RD_PTR : 3; /*!< [10..8] OCPM_MOSI_FIFO_RD_PTR                                             */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MOSI_FIFO_WR_PTR : 3; /*!< [14..12] OCPM_MOSI_FIFO_WR_PTR                                            */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MISO_FIFO_STATUS : 4; /*!< [19..16] OCPM_MISO_FIFO_STATUS                                            */
            uint32_t            : 4;
      __IM  uint32_t OCPM_MISO_FIFO_RD_PTR : 3; /*!< [26..24] OCPM_MISO_FIFO_RD_PTR                                            */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MISO_FIFO_WR_PTR : 3; /*!< [30..28] OCPM_MISO_FIFO_WR_PTR                                            */
            uint32_t            : 1;
    } OCPM_BUF_FIFO_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED[11];
  
  union {
    __IOM uint32_t CFG;                         /*!< (@ 0x00000080) CFG                                                        */
    
    struct {
      __IOM uint32_t APB_MUX_CTRL : 1;          /*!< [0..0] who controls the abp - 1=sw 0 = hw                                 */
      __IOM uint32_t UARTF_HALT : 1;            /*!< [1..1] disable the hw new logic - work as legacy                          */
      __IOM uint32_t UARTF_FLUSH : 1;           /*!< [2..2] flush what ever in the rx assembly. Self clear bit                 */
      __IOM uint32_t UARTF_TX_ENDIAN : 1;       /*!< [3..3] endian - 1 = MSB first 0 = LSB first                               */
      __IOM uint32_t UARTF_RX_ENDIAN : 1;       /*!< [4..4] endian - 1 = MSB first 0 = LSB first                               */
      __IOM uint32_t BYTE_RESOLUTION : 1;       /*!< [5..5] byte resolution                                                    */
            uint32_t            : 26;
    } CFG_b;
  } ;
  
  union {
    __IOM uint32_t UARTF_RXFIFO_ADDR;           /*!< (@ 0x00000084) UARTF_RXFIFO_ADDR                                          */
    
    struct {
      __IOM uint32_t RXFIFO_ADDR : 10;          /*!< [9..0] RXFIFO_ADDR                                                        */
            uint32_t            : 22;
    } UARTF_RXFIFO_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t UARTF_TXFIFO_ADDR;           /*!< (@ 0x00000088) UARTF_TXFIFO_ADDR                                          */
    
    struct {
      __IOM uint32_t TXFIFO_ADDR : 10;          /*!< [9..0] TXFIFO_ADDR                                                        */
            uint32_t            : 22;
    } UARTF_TXFIFO_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t UARTF_STATUS;                /*!< (@ 0x0000008C) UARTF_STATUS                                               */
    
    struct {
      __IM  uint32_t ERR_INT    : 1;            /*!< [0..0] ERR_INT                                                            */
      __IM  uint32_t FLOW_INT   : 1;            /*!< [1..1] FLOW_INT                                                           */
      __IM  uint32_t OCPM_FLOW_INT : 1;         /*!< [2..2] OCPM_FLOW_INT                                                      */
      __IM  uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [3..3] MOSI_PACKET_CNT_INT                                                */
      __IM  uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [4..4] MISO_PACKET_CNT_INT                                                */
      __IM  uint32_t OVERRUN_ERR_INT : 1;       /*!< [5..5] OVERRUN_ERR_INT                                                    */
      __IM  uint32_t BREAK_ERR_INT : 1;         /*!< [6..6] BREAK_ERR_INT                                                      */
      __IM  uint32_t FRAME_ERR_INT : 1;         /*!< [7..7] FRAME_ERR_INT                                                      */
      __IM  uint32_t PARITY_ERR_INT : 1;        /*!< [8..8] PARITY_ERR_INT                                                     */
      __IM  uint32_t OVERFLOW_ERR_INT : 1;      /*!< [9..9] OVERFLOW_ERR_INT                                                   */
      __IM  uint32_t OCPM_ERR_INT : 1;          /*!< [10..10] OCPM_ERR_INT                                                     */
      __IM  uint32_t WR_BUFFER_ACTIVE : 1;      /*!< [11..11] WR_BUFFER_ACTIVE                                                 */
      __IM  uint32_t RD_BUFFER_ACTIVE : 1;      /*!< [12..12] RD_BUFFER_ACTIVE                                                 */
            uint32_t            : 3;
      __IM  uint32_t UARTF_RXD  : 1;            /*!< [16..16] UARTF_RXD                                                        */
            uint32_t            : 15;
    } UARTF_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_INC;         /*!< (@ 0x00000090) MOSI_PAC_AT_CNT_INC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_INC : 16;           /*!< [15..0] counter software increment.                                       */
            uint32_t            : 16;
    } MOSI_PAC_AT_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_DEC;         /*!< (@ 0x00000094) MOSI_PAC_AT_CNT_DEC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_DEC : 16;           /*!< [15..0] counter software decrement.                                       */
            uint32_t            : 16;
    } MOSI_PAC_AT_CNT_DEC_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_CTRL;        /*!< (@ 0x00000098) MOSI_PAC_AT_CNT_CTRL                                       */
    
    struct {
      __IOM uint32_t BD_CNT_INT_EN : 1;         /*!< [0..0] counter interrupt enable.                                          */
      __IOM uint32_t BD_CNT_INT_MODE : 2;       /*!< [2..1] counter interrupt mode threshold mode disabled : 0 -
                                                     not zero; 1- increment; 2 - decrement; 3 - increment or
                                                     decrement. threshold mode enabled : 0 - none; 1 - cnt bigger
                                                     than or equal to threshold ; 2- cnd smaller than or equal
                                                     to threshold ; 3- cnt equal to threshold                                  */
      __IOM uint32_t BD_CNT_HW_EN : 1;          /*!< [3..3] counter hardware increment/decrement enable.                       */
      __IOM uint32_t BD_CNT_THRS_EN : 1;        /*!< [4..4] Threshold mode :0 -disabled ;1 - enabled                           */
            uint32_t            : 11;
      __IOM uint32_t BD_CNT_THRS_VALUE : 16;    /*!< [31..16] Threshold value limited to 12 bit                                */
    } MOSI_PAC_AT_CNT_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT;             /*!< (@ 0x0000009C) MOSI_PAC_AT_CNT                                            */
    
    struct {
      __IOM uint32_t BD_CNT     : 16;           /*!< [15..0] read/write (override) counter value                               */
            uint32_t            : 16;
    } MOSI_PAC_AT_CNT_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_INC;         /*!< (@ 0x000000A0) MISO_PAC_AT_CNT_INC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_INC : 16;           /*!< [15..0] counter software increment.                                       */
            uint32_t            : 16;
    } MISO_PAC_AT_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_DEC;         /*!< (@ 0x000000A4) MISO_PAC_AT_CNT_DEC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_DEC : 16;           /*!< [15..0] counter software decrement.                                       */
            uint32_t            : 16;
    } MISO_PAC_AT_CNT_DEC_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_CTRL;        /*!< (@ 0x000000A8) MISO_PAC_AT_CNT_CTRL                                       */
    
    struct {
      __IOM uint32_t BD_CNT_INT_EN : 1;         /*!< [0..0] counter interrupt enable.                                          */
      __IOM uint32_t BD_CNT_INT_MODE : 2;       /*!< [2..1] counter interrupt mode threshold mode disabled : 0 -
                                                     not zero; 1- increment; 2 - decrement; 3 - increment or
                                                     decrement. threshold mode enabled : 0 - none; 1 - cnt bigger
                                                     than or equal to threshold ; 2- cnd smaller than or equal
                                                     to threshold ; 3- cnt equal to threshold                                  */
      __IOM uint32_t BD_CNT_HW_EN : 1;          /*!< [3..3] counter hardware increment/decrement enable.                       */
      __IOM uint32_t BD_CNT_THRS_EN : 1;        /*!< [4..4] Threshold mode :0 -disabled ;1 - enabled                           */
            uint32_t            : 11;
      __IOM uint32_t BD_CNT_THRS_VALUE : 16;    /*!< [31..16] Threshold value limited to 12 bit                                */
    } MISO_PAC_AT_CNT_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT;             /*!< (@ 0x000000AC) MISO_PAC_AT_CNT                                            */
    
    struct {
      __IOM uint32_t BD_CNT     : 16;           /*!< [15..0] read/write (override) counter value                               */
            uint32_t            : 16;
    } MISO_PAC_AT_CNT_b;
  } ;
  
  union {
    __IOM uint32_t FLOW_INT;                    /*!< (@ 0x000000B0) FLOW_INT                                                   */
    
    struct {
      __IM  uint32_t OCPM_FLOW_INT : 1;         /*!< [0..0] OCPM_FLOW_INT                                                      */
      __IM  uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [1..1] MOSI_PACKET_CNT_INT                                                */
      __IM  uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [2..2] MISO_PACKET_CNT_INT                                                */
      __IM  uint32_t UARTINT    : 1;            /*!< [3..3] UARTINT                                                            */
            uint32_t            : 28;
    } FLOW_INT_b;
  } ;
  
  union {
    __IOM uint32_t CLR_FLOW_INT;                /*!< (@ 0x000000B4) CLR_FLOW_INT                                               */
    
    struct {
      __IM  uint32_t OCPM_FLOW_INT : 1;         /*!< [0..0] OCPM_FLOW_INT                                                      */
      __IOM uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [1..1] MOSI_PACKET_CNT_INT                                                */
      __IOM uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [2..2] MISO_PACKET_CNT_INT                                                */
      __IM  uint32_t UARTINT    : 1;            /*!< [3..3] UARTINT                                                            */
            uint32_t            : 28;
    } CLR_FLOW_INT_b;
  } ;
  
  union {
    __IOM uint32_t MSK_FLOW_INT;                /*!< (@ 0x000000B8) MSK_FLOW_INT                                               */
    
    struct {
      __IOM uint32_t OCPM_FLOW_INT : 1;         /*!< [0..0] OCPM_FLOW_INT                                                      */
      __IOM uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [1..1] MOSI_PACKET_CNT_INT                                                */
      __IOM uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [2..2] MISO_PACKET_CNT_INT                                                */
      __IOM uint32_t UARTINT    : 1;            /*!< [3..3] UARTINT                                                            */
            uint32_t            : 28;
    } MSK_FLOW_INT_b;
  } ;
  
  union {
    __IOM uint32_t EN_FLOW_INT;                 /*!< (@ 0x000000BC) EN_FLOW_INT                                                */
    
    struct {
      __IOM uint32_t OCPM_FLOW_INT : 1;         /*!< [0..0] OCPM_FLOW_INT                                                      */
      __IOM uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [1..1] MOSI_PACKET_CNT_INT                                                */
      __IOM uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [2..2] MISO_PACKET_CNT_INT                                                */
      __IOM uint32_t UARTINT    : 1;            /*!< [3..3] UARTINT                                                            */
            uint32_t            : 28;
    } EN_FLOW_INT_b;
  } ;
  
  union {
    __IOM uint32_t ERR_INT;                     /*!< (@ 0x000000C0) ERR_INT                                                    */
    
    struct {
      __IM  uint32_t OVERRUN_ERR_INT : 1;       /*!< [0..0] OVERRUN_ERR_INT                                                    */
      __IM  uint32_t BREAK_ERR_INT : 1;         /*!< [1..1] BREAK_ERR_INT                                                      */
      __IM  uint32_t FRAME_ERR_INT : 1;         /*!< [2..2] FRAME_ERR_INT                                                      */
      __IM  uint32_t PARITY_ERR_INT : 1;        /*!< [3..3] PARITY_ERR_INT                                                     */
      __IM  uint32_t OVERFLOW_ERR_INT : 1;      /*!< [4..4] OVERFLOW_ERR_INT                                                   */
      __IM  uint32_t OCPM_ERR_INT : 1;          /*!< [5..5] OCPM_ERR_INT                                                       */
            uint32_t            : 26;
    } ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t CLR_ERR_INT;                 /*!< (@ 0x000000C4) CLR_ERR_INT                                                */
    
    struct {
      __IOM uint32_t OVERRUN_ERR_INT : 1;       /*!< [0..0] OVERRUN_ERR_INT                                                    */
      __IOM uint32_t BREAK_ERR_INT : 1;         /*!< [1..1] BREAK_ERR_INT                                                      */
      __IOM uint32_t FRAME_ERR_INT : 1;         /*!< [2..2] FRAME_ERR_INT                                                      */
      __IOM uint32_t PARITY_ERR_INT : 1;        /*!< [3..3] PARITY_ERR_INT                                                     */
      __IOM uint32_t OVERFLOW_ERR_INT : 1;      /*!< [4..4] OVERFLOW_ERR_INT                                                   */
      __IM  uint32_t OCPM_ERR_INT : 1;          /*!< [5..5] OCPM_ERR_INT                                                       */
            uint32_t            : 26;
    } CLR_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t MSK_ERR_INT;                 /*!< (@ 0x000000C8) MSK_ERR_INT                                                */
    
    struct {
      __IOM uint32_t OVERRUN_ERR_INT : 1;       /*!< [0..0] OVERRUN_ERR_INT                                                    */
      __IOM uint32_t BREAK_ERR_INT : 1;         /*!< [1..1] BREAK_ERR_INT                                                      */
      __IOM uint32_t FRAME_ERR_INT : 1;         /*!< [2..2] FRAME_ERR_INT                                                      */
      __IOM uint32_t PARITY_ERR_INT : 1;        /*!< [3..3] PARITY_ERR_INT                                                     */
      __IOM uint32_t OVERFLOW_ERR_INT : 1;      /*!< [4..4] OVERFLOW_ERR_INT                                                   */
      __IOM uint32_t OCPM_ERR_INT : 1;          /*!< [5..5] OCPM_ERR_INT                                                       */
            uint32_t            : 26;
    } MSK_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t EN_ERR_INT;                  /*!< (@ 0x000000CC) EN_ERR_INT                                                 */
    
    struct {
      __IOM uint32_t OVERRUN_ERR_INT : 1;       /*!< [0..0] OVERRUN_ERR_INT                                                    */
      __IOM uint32_t BREAK_ERR_INT : 1;         /*!< [1..1] BREAK_ERR_INT                                                      */
      __IOM uint32_t FRAME_ERR_INT : 1;         /*!< [2..2] FRAME_ERR_INT                                                      */
      __IOM uint32_t PARITY_ERR_INT : 1;        /*!< [3..3] PARITY_ERR_INT                                                     */
      __IOM uint32_t OVERFLOW_ERR_INT : 1;      /*!< [4..4] OVERFLOW_ERR_INT                                                   */
      __IOM uint32_t OCPM_ERR_INT : 1;          /*!< [5..5] OCPM_ERR_INT                                                       */
            uint32_t            : 26;
    } EN_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t UBUS_CTRL;                   /*!< (@ 0x000000D0) UBUS_CTRL                                                  */
    
    struct {
      __IOM uint32_t RX_INV     : 1;            /*!< [0..0] when set the TXD is inverted before going out                      */
      __IOM uint32_t TX_INV     : 1;            /*!< [1..1] when set the RXD is inverted before going to the UART              */
      __IOM uint32_t RTS_SEL    : 1;            /*!< [2..2] when set the RTS output is driven from the logic                   */
      __IOM uint32_t UA1_STABLE_MODE : 1;       /*!< [3..3] when set the RTS output is stable (0) in TX and (1) in
                                                     RX; when reset the RTS is (1) in RX and TXD# in TX                        */
            uint32_t            : 28;
    } UBUS_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t UBUS_RX_TX_SEL;              /*!< (@ 0x000000D4) UBUS_RX_TX_SEL                                             */
    
    struct {
      __IOM uint32_t RX_N_TX    : 1;            /*!< [0..0] when set theUBUS if reset is in standby or receive; when
                                                     set it is in transmit                                                     */
            uint32_t            : 31;
    } UBUS_RX_TX_SEL_b;
  } ;
  
  union {
    __IOM uint32_t UART_8PIN_MODE;              /*!< (@ 0x000000D8) UART_8PIN_MODE                                             */
    
    struct {
      __IOM uint32_t MODE_DCE_N : 1;            /*!< [0..0] For UART with 8 pins:0 - DCE mode1 - DTE mode                      */
            uint32_t            : 31;
    } UART_8PIN_MODE_b;
  } ;
} UARTF_CFG_Type;                               /*!< Size = 220 (0xdc)                                                         */



/* =========================================================================================================================== */
/* ================                                          UARTF0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART controller #0 (UARTF0)
  */

typedef struct {                                /*!< (@ 0x00100000) UARTF0 Structure                                           */
  
  union {
    __IOM uint32_t DR;                          /*!< (@ 0x00000000) data register. write operation initiates transmission
                                                                    from the UART The received data byte is
                                                                    read by performing reads from the UARTDR                   */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] If the FIFOs are enabled: * Data written to this location
                                                     is pushed onto the transmit fifo. * The received data byte
                                                     is read by performing reads from this register. The data
                                                     byte and the 4-bit status fields are pushed onto the receive
                                                     fifo.                                                                     */
      __IOM uint32_t FE         : 1;            /*!< [8..8] Framing error. When this bit is set to 1; it indicates
                                                     that the received character did not have a valid stop bit
                                                     (a valid stop bit is 1).                                                  */
      __IOM uint32_t PE         : 1;            /*!< [9..9] Parity error. When this bit is set to 1; it indicates
                                                     that the parity of the received data character does not
                                                     match the parity selected as defined by bits 2 and 7 of
                                                     the UARTLCR_H register.                                                   */
      __IOM uint32_t BE         : 1;            /*!< [10..10] Break error. This bit is set to 1 if a break condition
                                                     was detected; indicating that the received data input was
                                                     held LOW for longer than a full-word transmission time.                   */
      __IOM uint32_t OE         : 1;            /*!< [11..11] Overrun error. This bit is set to 1 if data is received
                                                     and the receive FIFO is already full.This is cleared to
                                                     0 once there is an empty space in the fifo.                               */
            uint32_t            : 20;
    } DR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t RSR;                       /*!< (@ 0x00000004) Receive status register                                    */
      
      struct {
        __IM  uint32_t FE       : 1;            /*!< [0..0] Framing error. When this bit is set to 1; it indicates
                                                     that the received character did not have a valid stop bit
                                                     (a valid stop bit is 1). This bit is cleared to 0 by a
                                                     write to UARTECR.                                                         */
        __IM  uint32_t PE       : 1;            /*!< [1..1] Parity error. When this bit is set to 1; it indicates
                                                     that the parity of the received data character does not
                                                     match the parity selected as defined by bits 2 and 7 of
                                                     the UARTLCR_H register. This bit is cleared to 0 by a write
                                                     to UARTECR.                                                               */
        __IM  uint32_t BE       : 1;            /*!< [2..2] Break error. This bit is set to 1 if a break condition
                                                     was detected; indicating that the received data input was
                                                     held LOW for longer than a full-word transmission time
                                                     (defined as start; data; parity; and stop bits). This bit
                                                     is cleared to 0 after a write to UARTECR.                                 */
        __IM  uint32_t OE       : 1;            /*!< [3..3] Overrun error. This bit is set to 1 if data is received
                                                     and the FIFO is already full.This bit is cleared to 0 by
                                                     a write to UARTECR.                                                       */
              uint32_t          : 28;
      } RSR_b;
    } ;
    
    union {
      __IOM uint32_t ECR;                       /*!< (@ 0x00000004) error clear register A write to UARTECR clears
                                                                    the framing parity break and overrun errors                */
      
      struct {
        __OM  uint32_t CLEAR_ALL : 8;           /*!< [7..0] See UARTRSR above.                                                 */
              uint32_t          : 24;
      } ECR_b;
    } ;
  };
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t FR;                          /*!< (@ 0x00000018) The flag register.                                         */
    
    struct {
      __IM  uint32_t CTS        : 1;            /*!< [0..0] Clear to send. This bit is the complement of the UART
                                                     clear to send (nUARTCTS) modem status input. That is; the
                                                     bit is 1 when the modem status input is 0.                                */
      __IM  uint32_t DSR        : 1;            /*!< [1..1] Data set ready. This bit is the complement of the UART
                                                     data set ready (nUARTDSR) modem status input. That is;
                                                     the bit is 1 when the modem status input is 0.                            */
      __IM  uint32_t DCD        : 1;            /*!< [2..2] Data carrier detect. This bit is the complement of the
                                                     UART data carrier detect (nUARTDCD) modem status input.
                                                     That is; the bit is 1 when the modem status input is 0.                   */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] UART busy. If this bit is set to 1; the UART is busy
                                                     transmitting data. This bit remains set until the complete
                                                     byte; including all the stop bits; has been sent from the
                                                     shift register.This bit is set as soon as the transmit
                                                     FIFO becomes non-empty (regardless of whether the UART
                                                     is enabled or not).                                                       */
      __IM  uint32_t RXFE       : 1;            /*!< [4..4] Receive FIFO empty. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H register. If
                                                     the FIFO is disabled; this bit is set when the receive
                                                     holding register is empty. If the FIFO is enabled; the
                                                     RXFE bit is set when the receive FIFO is empty.                           */
      __IM  uint32_t TXFF       : 1;            /*!< [5..5] Transmit FIFO full. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H register. If
                                                     the FIFO is disabled; this bit is set when the transmit
                                                     holding register is full. If the FIFO is enabled; the TXFF
                                                     bit is set when the transmit FIFO is full.                                */
      __IM  uint32_t RXFF       : 1;            /*!< [6..6] Receive FIFO full. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H register. If
                                                     the FIFO is disabled; this bit is set when the receive
                                                     holding register is full. If the FIFO is enabled; the RXFF
                                                     bit is set when the receive FIFO is full.                                 */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty. The meaning of this bit depends
                                                     on the state of the FEN bit in the UARTLCR_H register.
                                                     If the FIFO is disabled; this bit is set when the transmit
                                                     holding register is empty. If the FIFO is enabled; the
                                                     TXFE bit is set when the transmit FIFO is empty. This bit
                                                     does not indicate if there is data in the transmit shift
                                                     register.                                                                 */
      __IM  uint32_t RI         : 1;            /*!< [8..8] Ring indicator. This bit is the complement of the UART
                                                     ring indicator (nUARTRI) modem status input. That is; the
                                                     bit is 1 when the modem status input is 0.                                */
            uint32_t            : 23;
    } FR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t ILPR;                        /*!< (@ 0x00000020) IrDA low-power counter register. This is an 8-bit
                                                                    read/write register that stores the low-power
                                                                    counter divisor value used to generate the
                                                                    IrLPBaud16 signal by dividing down of UARTCLK              */
    
    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< [7..0] 8-bit low-power divisor value.                                     */
            uint32_t            : 24;
    } ILPR_b;
  } ;
  
  union {
    __IOM uint32_t IBRD;                        /*!< (@ 0x00000024) integer part of the baud rate divisor value Baud
                                                                    rate divisor BAUDDIV = (FUARTCLK/ {16 *
                                                                    Baud rate}) where FUARTCLK is the UART reference
                                                                    clock frequency. The BAUDDIV is comprised
                                                                    of the integer value (BAUD DIVINT) and the
                                                                    fractional value (BAUD DIVFRAC).                           */
    
    struct {
      __IOM uint32_t BAUD_DIVINT : 16;          /*!< [15..0] integer part of the baud rate divisor value                       */
            uint32_t            : 16;
    } IBRD_b;
  } ;
  
  union {
    __IOM uint32_t FBRD;                        /*!< (@ 0x00000028) fractional part of the baud rate divisor value
                                                                    Baud rate divisor BAUDDIV = (FUARTCLK/ {16
                                                                    * Baud rate}) where FUARTCLK is the UART
                                                                    reference clock frequency. The BAUDDIV is
                                                                    comprised of the integer value (BAUD DIVINT)
                                                                    and the fractional value (BAUD DIVFRAC).                   */
    
    struct {
      __IOM uint32_t BAUD_DIVFRAC : 6;          /*!< [5..0] The fractional baud rate divisor.                                  */
            uint32_t            : 26;
    } FBRD_b;
  } ;
  
  union {
    __IOM uint32_t LCR_H;                       /*!< (@ 0x0000002C) Accesses bits 29 to 22 of UARTLCR.                         */
    
    struct {
      __IOM uint32_t BRK        : 1;            /*!< [0..0] Send break. If this bit is set to 1; a low-level is continually
                                                     output on the UARTTXD output; aftercompleting transmission
                                                     of the current character. For the proper execution of the
                                                     break command; the software must set this bit for at least
                                                     two complete frames. For normal use; this bit must be cleared
                                                     to 0.                                                                     */
      __IOM uint32_t PEN        : 1;            /*!< [1..1] Parity enable. If this bit is set to 1; parity checking
                                                     and generation is enabled.                                                */
      __IOM uint32_t EPS        : 1;            /*!< [2..2] Even parity select. If this bit is set to 1; even parity
                                                     generation and checking is performed during transmission
                                                     and reception; which checks for an even number of 1s in
                                                     data and parity bits. When cleared to 0 then odd parity
                                                     is performed which checks for an odd number of 1s. This
                                                     bit has no effect when parity is disabled by Parity Enable
                                                     (bit 1) being cleared to 0.                                               */
      __IOM uint32_t STP2       : 1;            /*!< [3..3] Two stop bits select. If this bit is set to 1; two stop
                                                     bits are transmitted at the end of the frame. The receive
                                                     logic does not check for two stop bits being received.                    */
      __IOM uint32_t FEN        : 1;            /*!< [4..4] Enable FIFOs. If this bit is set to 1; transmit and receive
                                                     FIFO buffers are enabled (FIFO mode). When cleared to 0
                                                     the FIFOs are disabled (character mode) that is; the FIFOs
                                                     become 1-byte-deep holding registers.                                     */
      __IOM uint32_t WLEN       : 2;            /*!< [6..5] Word length. The select bits indicate the number of data
                                                     bits transmitted or received in a frame: 11 = 8 bits; 10
                                                     = 7 bits; 01 = 6 bits; 00 = 5 bits.                                       */
      __IOM uint32_t SPS        : 1;            /*!< [7..7] Stick parity select. When bits 1; 2; and 7 of the UARTLCR_H
                                                     register are set; the parity bit is transmitted and checked
                                                     as a 0. When bits 1 and 7 are set; and bit 2 is 0; the
                                                     parity bit is transmitted and checked as a 1. When this
                                                     bit is cleared stick parity is disabled.                                  */
            uint32_t            : 24;
    } LCR_H_b;
  } ;
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000030) UART control register                                      */
    
    struct {
      __IOM uint32_t UARTEN     : 1;            /*!< [0..0] UART enable. If this bit is set to 1; the UART is enabled.
                                                     When the UART is disabled in the middle of transmission
                                                     or reception; it completes the current character before
                                                     stopping.                                                                 */
      __IOM uint32_t SIREN      : 1;            /*!< [1..1] SIR enable. If this bit is set to 1; the IrDA SIR ENDEC
                                                     is enabled. This bit has no effect if the UART is not enabled
                                                     by bit 0 being set to 1.                                                  */
      __IOM uint32_t SIRLP      : 1;            /*!< [2..2] IrDA SIR low power mode. This bit selects the IrDA encoding
                                                     mode.                                                                     */
      __IOM uint32_t RSRVD      : 4;            /*!< [6..3] RSRVD                                                              */
      __IOM uint32_t LBE        : 1;            /*!< [7..7] Loop back enable. If this bit is set to 1 and the SIR
                                                     Enable bit is set to 1 and the test registerUARTTCR bit
                                                     2 (SIRTEST) is set to 1; then the nSIROUT path is inverted;
                                                     and fed through to theSIRIN path.                                         */
      __IOM uint32_t TXE        : 1;            /*!< [8..8] Transmit enable. If this bit is set to 1; the transmit
                                                     section of the UART is enabled. When the UART is disabled
                                                     in the middle of transmission; it completes the current
                                                     character before stopping.                                                */
      __IOM uint32_t RXE        : 1;            /*!< [9..9] Receive enable. If this bit is set to 1; the receive
                                                     section of the UART is enabled. When the UART is disabled
                                                     in the middle of transmission; it completes the current
                                                     character before stopping.                                                */
      __IOM uint32_t DTR        : 1;            /*!< [10..10] Data transmit ready. This bit is the complement of
                                                     nUARTDTR. That is; when the bit is programmed to a 1; the
                                                     output is 0.                                                              */
      __IOM uint32_t RTS        : 1;            /*!< [11..11] Request to send. This bit is the complement of the
                                                     UART nUARTRTS. That is; when the bit is programmed to a
                                                     1; the output is 0.                                                       */
      __IOM uint32_t OUT1       : 1;            /*!< [12..12] This bit is the complement of the UART nUARTOut1. That
                                                     is; when thebit is programmed to a 1 the output is 0. For
                                                     DTE this can be used as Data Carrier Detect (DCD).                        */
      __IOM uint32_t OUT2       : 1;            /*!< [13..13] This bit is the complement of nUARTOut2. That is; when
                                                     the bit is programmed to a 1; the output is 0. For DTE
                                                     this can be used as Ring Indicator (RI).                                  */
      __IOM uint32_t RTSEN      : 1;            /*!< [14..14] RTS hardware flow control enable. If this bit is set
                                                     to 1; RTS hardware flow control is enabled. Data is only
                                                     requested when there is space in the receive FIFO for it
                                                     to be received.                                                           */
      __IOM uint32_t CTSEN      : 1;            /*!< [15..15] CTS hardware flow control enable. If this bit is set
                                                     to 1; CTS hardware flow control is enabled. Data is only
                                                     transmitted when the nUARTCTS signal is asserted.                         */
            uint32_t            : 16;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t IFLS;                        /*!< (@ 0x00000034) Interrupt FIFO level select register.                      */
    
    struct {
      __IOM uint32_t TXIFLSEL   : 4;            /*!< [3..0] TXIFLSEL                                                           */
      __IOM uint32_t RXIFLSEL   : 4;            /*!< [7..4] RXIFLSEL                                                           */
            uint32_t            : 24;
    } IFLS_b;
  } ;
  
  union {
    __IOM uint32_t IMSC;                        /*!< (@ 0x00000038) Interrupt mask set/clear register.                         */
    
    struct {
      __IOM uint32_t RIMIM      : 1;            /*!< [0..0] nUARTRI modem interrupt mask. On a read the current mask
                                                     for the RIMIM interrupt isreturned. On a write of 1; the
                                                     mask of the RIMIM interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t CTSMIM     : 1;            /*!< [1..1] nUARTCTS modem interrupt mask. On a read the current
                                                     mask for the CTSMIM interrupt isreturned.On a write of
                                                     1; the mask of the CTSMIM interrupt is set. A write of
                                                     0 clears the mask.                                                        */
      __IOM uint32_t DCDMIM     : 1;            /*!< [2..2] nUARTDCD modem interrupt mask. On a read the current
                                                     mask for the DCDMIM interrupt isreturned. On a write of
                                                     1; the mask of the DCDMIM interrupt is set. A write of
                                                     0 clears the mask.                                                        */
      __IOM uint32_t DSRMIM     : 1;            /*!< [3..3] nUARTDSR modem interrupt mask. On a read the current
                                                     mask for the DSRMIM interrupt isreturned. On a write of
                                                     1; the mask of the DSRMIM interrupt is set. A write of
                                                     0 clears the mask.                                                        */
      __IOM uint32_t RXIM       : 1;            /*!< [4..4] Receive interrupt mask. On a read the current mask for
                                                     the RXIM interrupt is returned.On a write of 1; the mask
                                                     of the RXIM interrupt is set. A write of 0 clears the mask.               */
      __IOM uint32_t TXIM       : 1;            /*!< [5..5] Transmit interrupt mask. On a read the current mask for
                                                     the TXIM interrupt is returned.On a write of 1; the mask
                                                     of the TXIM interrupt is set. A write of 0 clears the mask.               */
      __IOM uint32_t RTIM       : 1;            /*!< [6..6] Receive timeout interrupt mask. On a read the current
                                                     mask for the RTIM interrupt is returned. On a write of
                                                     1; the mask of the RTIM interrupt is set. A write of 0
                                                     clears the mask.                                                          */
      __IOM uint32_t FEIM       : 1;            /*!< [7..7] Framing error interrupt mask. On a read the current mask
                                                     for the FEIM interrupt is returned.On a write of 1; the
                                                     mask of the FEIM interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t PEIM       : 1;            /*!< [8..8] Parity error interrupt mask. On a read the current mask
                                                     for the PEIM interrupt is returned.On a write of 1; the
                                                     mask of the PEIM interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t BEIM       : 1;            /*!< [9..9] Break error interrupt mask. On a read the current mask
                                                     for the BEIM interrupt is returned. On a write of 1; the
                                                     mask of the BEIM interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t OEIM       : 1;            /*!< [10..10] Overrun error interrupt mask. On a read; the current
                                                     mask for the OEIM interrupt is returned. On a write of
                                                     1; the mask of the OEIM interrupt is set. A write of 0
                                                     clears the mask.                                                          */
            uint32_t            : 21;
    } IMSC_b;
  } ;
  
  union {
    __IOM uint32_t RIS;                         /*!< (@ 0x0000003C) Raw interrupt status register. Before masking              */
    
    struct {
      __IM  uint32_t RIRMIS     : 1;            /*!< [0..0] nUARTRI modem interrupt status.                                    */
      __IM  uint32_t CTSRMIS    : 1;            /*!< [1..1] nUARTCTS modem interrupt status.                                   */
      __IM  uint32_t DCDRMIS    : 1;            /*!< [2..2] nUARTDCD modem interrupt status.                                   */
      __IM  uint32_t DSRRMIS    : 1;            /*!< [3..3] nUARTDSR modem interrupt status.                                   */
      __IM  uint32_t RXRIS      : 1;            /*!< [4..4] Receive interrupt status.                                          */
      __IM  uint32_t TXRIS      : 1;            /*!< [5..5] Transmit interrupt status.                                         */
      __IM  uint32_t RTRIS      : 1;            /*!< [6..6] Receive timeout interrupt status.                                  */
      __IM  uint32_t FERIS      : 1;            /*!< [7..7] Framing error interrupt status.                                    */
      __IM  uint32_t PERIS      : 1;            /*!< [8..8] Parity error interrupt status.                                     */
      __IM  uint32_t BERIS      : 1;            /*!< [9..9] Break error interrupt status.                                      */
      __IM  uint32_t OERIS      : 1;            /*!< [10..10] Overrun error interrupt status.                                  */
            uint32_t            : 21;
    } RIS_b;
  } ;
  
  union {
    __IOM uint32_t MIS;                         /*!< (@ 0x00000040) Masked interrupt status register.                          */
    
    struct {
      __IM  uint32_t RIMMIS     : 1;            /*!< [0..0] nUARTRI modem masked interrupt status.                             */
      __IM  uint32_t CTSMMIS    : 1;            /*!< [1..1] nUARTCTS modem masked interrupt status.                            */
      __IM  uint32_t DCDMMIS    : 1;            /*!< [2..2] nUARTDCD modem masked interrupt status.                            */
      __IM  uint32_t DSRMMIS    : 1;            /*!< [3..3] nUARTDSR modem masked interrupt status.                            */
      __IM  uint32_t RXMIS      : 1;            /*!< [4..4] Receive masked interrupt status.                                   */
      __IM  uint32_t TXMIS      : 1;            /*!< [5..5] Transmit masked interrupt status.                                  */
      __IM  uint32_t RTMIS      : 1;            /*!< [6..6] Receive timeout masked interrupt status.                           */
      __IM  uint32_t FEMIS      : 1;            /*!< [7..7] Framing error masked interrupt status.                             */
      __IM  uint32_t PEMIS      : 1;            /*!< [8..8] Parity error masked interrupt status.                              */
      __IM  uint32_t BEMIS      : 1;            /*!< [9..9] Break error masked interrupt status.                               */
      __IM  uint32_t OEMIS      : 1;            /*!< [10..10] Overrun error masked interrupt status.                           */
            uint32_t            : 21;
    } MIS_b;
  } ;
  
  union {
    __IOM uint32_t ICR;                         /*!< (@ 0x00000044) Interrupt clear register                                   */
    
    struct {
      __OM  uint32_t RIMIC      : 1;            /*!< [0..0] nUARTRI modem interrupt clear.                                     */
      __OM  uint32_t CTSMIC     : 1;            /*!< [1..1] nUARTCTS modem interrupt clear.                                    */
      __OM  uint32_t DCDMIC     : 1;            /*!< [2..2] nUARTDCD modem interrupt clear.                                    */
      __OM  uint32_t DSRMIC     : 1;            /*!< [3..3] nUARTDSR modem interrupt clear.                                    */
      __OM  uint32_t RXIC       : 1;            /*!< [4..4] Receive interrupt clear.                                           */
      __OM  uint32_t TXIC       : 1;            /*!< [5..5] Transmit interrupt clear.                                          */
      __OM  uint32_t RTIC       : 1;            /*!< [6..6] Receive timeout interrupt clear.                                   */
      __OM  uint32_t FEIC       : 1;            /*!< [7..7] Framing error interrupt clear.                                     */
      __OM  uint32_t PEIC       : 1;            /*!< [8..8] Parity error interrupt clear.                                      */
      __OM  uint32_t BEIC       : 1;            /*!< [9..9] Break error interrupt clear.                                       */
      __OM  uint32_t OEIC       : 1;            /*!< [10..10] Overrun error interrupt clear.                                   */
            uint32_t            : 21;
    } ICR_b;
  } ;
} UART_Type;                                    /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                         SPI_SLAVE                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave controller (SPI_SLAVE)
  */

typedef struct {                                /*!< (@ 0x01200000) SPI_SLAVE Structure                                        */
  
  union {
    __IOM uint32_t CFG;                         /*!< (@ 0x00000000) CFG                                                        */
    
    struct {
      __IOM uint32_t WORD_SIZE  : 6;            /*!< [5..0] The bit size of the word to be transmitted. Ranges from
                                                     4 to 32 bit. Each word has its own row in the data FIFO
                                                     (when it is not in infinite mode)                                         */
      __IOM uint32_t INFINITE   : 1;            /*!< [6..6] INFINITE                                                           */
      __IOM uint32_t ENDIAN_SWITCH : 1;         /*!< [7..7] Byte endianity of the received/transmitted bit stream
                                                     - only relevant in infinite mode0: Big endian - MsB to
                                                     LsB 1: Little endian - LsB to MsB                                         */
      __IOM uint32_t REVERSAL   : 1;            /*!< [8..8] Bit endianity of the received/transmitted bit stream.0:
                                                     Msb to Lsb (normal)1: Lsb to Msb (reversed)                               */
      __IOM uint32_t CPOL       : 1;            /*!< [9..9] CPOL                                                               */
      __IOM uint32_t CPHA       : 1;            /*!< [10..10] CPHA                                                             */
            uint32_t            : 5;
      __IOM uint32_t SS_BOTH_EDGE_INT_EN : 1;   /*!< [16..16] if set to 1 the ss ss will be set on any edge change             */
            uint32_t            : 6;
      __IOM uint32_t SS_ACTIVE_HIGH : 1;        /*!< [23..23] SS_ACTIVE_HIGH                                                   */
      __IOM uint32_t MISO_IDLE_VALUE : 1;       /*!< [24..24] MISO_IDLE_VALUE                                                  */
            uint32_t            : 3;
      __IOM uint32_t FLUSH_LINE_DRIVER : 1;     /*!< [28..28] clear all the counters and fifos in the line driver
                                                     incase the driver wants to flush out all current trans                    */
            uint32_t            : 2;
      __IOM uint32_t CHAR_EN    : 1;            /*!< [31..31] set to 1 will enable to work in character mode                   */
    } CFG_b;
  } ;
  
  union {
    __IOM uint32_t CFG_PACKET;                  /*!< (@ 0x00000004) CFG_PACKET                                                 */
    
    struct {
      __IOM uint32_t PACKET_SIZE : 16;          /*!< [15..0] PACKET_SIZE                                                       */
      __IOM uint32_t MULTI_PACKET_SIZE : 16;    /*!< [31..16] MULTI_PACKET_SIZE                                                */
    } CFG_PACKET_b;
  } ;
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t SRDY;                        /*!< (@ 0x00000018) SRDY                                                       */
    
    struct {
      __IOM uint32_t SPI_SW_SRDY_VALUE : 1;     /*!< [0..0] SPI_SW_SRDY_VALUE                                                  */
      __IOM uint32_t SPI_SW_SRDY_IDLE : 1;      /*!< [1..1] SPI_SW_SRDY_IDLE                                                   */
      __IOM uint32_t SPI_SW_BYPASS_SRDY : 1;    /*!< [2..2] SPI_SW_BYPASS_SRDY                                                 */
            uint32_t            : 28;
      __IM  uint32_t SPI_SS_IN_HCLK_MUXED : 1;  /*!< [31..31] SPI_SS_IN_HCLK_MUXED                                             */
    } SRDY_b;
  } ;
  
  union {
    __IOM uint32_t RD_INT;                      /*!< (@ 0x0000001C) RD_INT                                                     */
    
    struct {
      __IM  uint32_t MASTER_READY_INT : 1;      /*!< [0..0] MASTER_READY_INT                                                   */
      __IM  uint32_t OCPM_FLOW_INT : 1;         /*!< [1..1] OCPM_FLOW_INT                                                      */
            uint32_t            : 3;
      __IM  uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [5..5] MOSI_PACKET_CNT_INT                                                */
      __IM  uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [6..6] MISO_PACKET_CNT_INT                                                */
      __IM  uint32_t MULTI_PACKET_COMPLETE_INT : 1;/*!< [7..7] MULTI_PACKET_COMPLETE_INT                                       */
            uint32_t            : 24;
    } RD_INT_b;
  } ;
  
  union {
    __IOM uint32_t RD_CLR_INT;                  /*!< (@ 0x00000020) RD_CLR_INT                                                 */
    
    struct {
      __IOM uint32_t MASTER_READY_INT : 1;      /*!< [0..0] MASTER_READY_INT                                                   */
      __IM  uint32_t OCPM_FLOW_INT : 1;         /*!< [1..1] OCPM_FLOW_INT                                                      */
            uint32_t            : 3;
      __IOM uint32_t MOSI_PACKET_CNT_INT : 1;   /*!< [5..5] MOSI_PACKET_CNT_INT                                                */
      __IOM uint32_t MISO_PACKET_CNT_INT : 1;   /*!< [6..6] MISO_PACKET_CNT_INT                                                */
      __IOM uint32_t MULTI_PACKET_COMPLETE_INT : 1;/*!< [7..7] MULTI_PACKET_COMPLETE_INT                                       */
            uint32_t            : 24;
    } RD_CLR_INT_b;
  } ;
  
  union {
    __IOM uint32_t MASK_INT;                    /*!< (@ 0x00000024) MASK_INT                                                   */
    
    struct {
      __IOM uint32_t MASK_MASTER_READY_INT : 1; /*!< [0..0] MASK_MASTER_READY_INT                                              */
            uint32_t            : 4;
      __IOM uint32_t MASK_MOSI_PACKET_CNT_INT : 1;/*!< [5..5] MASK_MOSI_PACKET_CNT_INT                                         */
      __IOM uint32_t MASK_MISO_PACKET_CNT_INT : 1;/*!< [6..6] MASK_MISO_PACKET_CNT_INT                                         */
      __IOM uint32_t MASK_MULTI_PACKET_COMPLETE_INT : 1;/*!< [7..7] MASK_MULTI_PACKET_COMPLETE_INT                             */
            uint32_t            : 24;
    } MASK_INT_b;
  } ;
  
  union {
    __IOM uint32_t INT_EN;                      /*!< (@ 0x00000028) INT_EN                                                     */
    
    struct {
      __IOM uint32_t MASTER_READY_INT_EN : 1;   /*!< [0..0] MASTER_READY_INT_EN                                                */
            uint32_t            : 6;
      __IOM uint32_t MULTI_PACKET_COMPLETE_INT_EN : 1;/*!< [7..7] MULTI_PACKET_COMPLETE_INT_EN                                 */
            uint32_t            : 24;
    } INT_EN_b;
  } ;
  __IM  uint32_t  RESERVED1[10];
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_INC;         /*!< (@ 0x00000054) MOSI_PAC_AT_CNT_INC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_INC : 8;            /*!< [7..0] counter software increment.                                        */
            uint32_t            : 24;
    } MOSI_PAC_AT_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_DEC;         /*!< (@ 0x00000058) MOSI_PAC_AT_CNT_DEC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_DEC : 8;            /*!< [7..0] counter software decrement.                                        */
            uint32_t            : 24;
    } MOSI_PAC_AT_CNT_DEC_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT_CTRL;        /*!< (@ 0x0000005C) MOSI_PAC_AT_CNT_CTRL                                       */
    
    struct {
      __IOM uint32_t BD_CNT_INT_EN : 1;         /*!< [0..0] counter interrupt enable.                                          */
      __IOM uint32_t BD_CNT_INT_MODE : 2;       /*!< [2..1] counter interrupt mode threshold mode disabled : 0 -
                                                     not zero; 1- increment; 2 - decrement; 3 - increment or
                                                     decrement. threshold mode enabled : 0 - none; 1 - cnt bigger
                                                     than or equal to threshold ; 2- cnd smaller than or equal
                                                     to threshold ; 3- cnt equal to threshold                                  */
      __IOM uint32_t BD_CNT_HW_EN : 1;          /*!< [3..3] counter hardware increment/decrement enable.                       */
      __IOM uint32_t BD_CNT_THRS_EN : 1;        /*!< [4..4] Threshold mode :0 -disabled ;1 - enabled                           */
            uint32_t            : 11;
      __IOM uint32_t BD_CNT_THRS_VALUE : 8;     /*!< [23..16] Threshold value limited to 12 bit                                */
            uint32_t            : 8;
    } MOSI_PAC_AT_CNT_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MOSI_PAC_AT_CNT;             /*!< (@ 0x00000060) MOSI_PAC_AT_CNT                                            */
    
    struct {
      __IOM uint32_t BD_CNT     : 8;            /*!< [7..0] read/write (override) counter value                                */
            uint32_t            : 24;
    } MOSI_PAC_AT_CNT_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_INC;         /*!< (@ 0x00000064) MISO_PAC_AT_CNT_INC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_INC : 8;            /*!< [7..0] counter software increment.                                        */
            uint32_t            : 24;
    } MISO_PAC_AT_CNT_INC_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_DEC;         /*!< (@ 0x00000068) MISO_PAC_AT_CNT_DEC                                        */
    
    struct {
      __IOM uint32_t BD_CNT_DEC : 8;            /*!< [7..0] counter software decrement.                                        */
            uint32_t            : 24;
    } MISO_PAC_AT_CNT_DEC_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT_CTRL;        /*!< (@ 0x0000006C) MISO_PAC_AT_CNT_CTRL                                       */
    
    struct {
      __IOM uint32_t BD_CNT_INT_EN : 1;         /*!< [0..0] counter interrupt enable.                                          */
      __IOM uint32_t BD_CNT_INT_MODE : 2;       /*!< [2..1] counter interrupt mode threshold mode disabled : 0 -
                                                     not zero; 1- increment; 2 - decrement; 3 - increment or
                                                     decrement. threshold mode enabled : 0 - none; 1 - cnt bigger
                                                     than or equal to threshold ; 2- cnd smaller than or equal
                                                     to threshold ; 3- cnt equal to threshold                                  */
      __IOM uint32_t BD_CNT_HW_EN : 1;          /*!< [3..3] counter hardware increment/decrement enable.                       */
      __IOM uint32_t BD_CNT_THRS_EN : 1;        /*!< [4..4] Threshold mode :0 -disabled ;1 - enabled                           */
            uint32_t            : 11;
      __IOM uint32_t BD_CNT_THRS_VALUE : 8;     /*!< [23..16] Threshold value limited to 12 bit                                */
            uint32_t            : 8;
    } MISO_PAC_AT_CNT_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MISO_PAC_AT_CNT;             /*!< (@ 0x00000070) MISO_PAC_AT_CNT                                            */
    
    struct {
      __IOM uint32_t BD_CNT     : 8;            /*!< [7..0] read/write (override) counter value                                */
            uint32_t            : 24;
    } MISO_PAC_AT_CNT_b;
  } ;
  
  union {
    __IOM uint32_t MULTI_PACKET_STATUS;         /*!< (@ 0x00000074) MULTI_PACKET_STATUS                                        */
    
    struct {
      __IM  uint32_t PACKET_COUNTER_MISO : 16;  /*!< [15..0] number of packet wrtten to host (TX)                              */
      __IM  uint32_t PACKET_COUNTER_MOSI : 16;  /*!< [31..16] number of packets written from host (RX)                         */
    } MULTI_PACKET_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED2[34];
  
  union {
    __IOM uint32_t OCPM_CFG;                    /*!< (@ 0x00000100) OCPM_CFG                                                   */
    
    struct {
      __IOM uint32_t WR_FIFO_THRES_VALUE : 4;   /*!< [3..0] WR_FIFO_THRES_VALUE                                                */
      __IOM uint32_t THRES_WR_SW_BYPASS : 1;    /*!< [4..4] THRES_WR_SW_BYPASS                                                 */
            uint32_t            : 3;
      __IM  uint32_t WR_FIFO_THRES : 4;         /*!< [11..8] WR_FIFO_THRES                                                     */
      __IOM uint32_t RD_FIFO_THRES_VALUE : 4;   /*!< [15..12] RD_FIFO_THRES_VALUE                                              */
      __IOM uint32_t THRES_RD_SW_BYPASS : 1;    /*!< [16..16] THRES_RD_SW_BYPASS                                               */
            uint32_t            : 3;
      __IM  uint32_t RD_FIFO_THRES : 4;         /*!< [23..20] RD_FIFO_THRES                                                    */
      __IOM uint32_t OCP_BRST_ALIGN : 1;        /*!< [24..24] OCP_BRST_ALIGN                                                   */
            uint32_t            : 3;
      __IOM uint32_t MISO_BIG_ENDIAN : 1;       /*!< [28..28] byte endianity of the data input from the bus fabric1
                                                     - big endian0 - little endian                                             */
      __IOM uint32_t MOSI_BIG_ENDIAN : 1;       /*!< [29..29] byte endianity of the data output to the bus fabric1
                                                     - big endian0 - little endian                                             */
            uint32_t            : 2;
    } OCPM_CFG_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_INIT;                   /*!< (@ 0x00000104) OCPM_INIT                                                  */
    
    struct {
      __IOM uint32_t MOSI_RESET_FLUSH : 1;      /*!< [0..0] MOSI_RESET_FLUSH                                                   */
      __IOM uint32_t MISO_RESET_FLUSH : 1;      /*!< [1..1] MISO_RESET_FLUSH                                                   */
            uint32_t            : 6;
      __IOM uint32_t WR_BD_LIST_SIZE_FLUSH : 1; /*!< [8..8] WR_BD_LIST_SIZE_FLUSH                                              */
      __IOM uint32_t WR_BD_LIST_ADDR_FLUSH : 1; /*!< [9..9] WR_BD_LIST_ADDR_FLUSH                                              */
      __IOM uint32_t RD_BD_LIST_SIZE_FLUSH : 1; /*!< [10..10] RD_BD_LIST_SIZE_FLUSH                                            */
      __IOM uint32_t RD_BD_LIST_ADDR_FLUSH : 1; /*!< [11..11] RD_BD_LIST_ADDR_FLUSH                                            */
            uint32_t            : 4;
      __IOM uint32_t RESET_WR_BUFF : 1;         /*!< [16..16] RESET_WR_BUFF                                                    */
            uint32_t            : 7;
      __IOM uint32_t RESET_RD_BUFF : 1;         /*!< [24..24] RESET_RD_BUFF                                                    */
            uint32_t            : 7;
    } OCPM_INIT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_ADDR;                /*!< (@ 0x00000108) OCPM_RD_ADDR                                               */
    
    struct {
      __IOM uint32_t RD_BUFF_START_ADDR : 29;   /*!< [28..0] RD_BUFF_START_ADDR                                                */
            uint32_t            : 3;
    } OCPM_RD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_ADDR;                /*!< (@ 0x0000010C) OCPM_WR_ADDR                                               */
    
    struct {
      __IOM uint32_t WR_BUFF_START_ADDR : 29;   /*!< [28..0] WR_BUFF_START_ADDR                                                */
            uint32_t            : 3;
    } OCPM_WR_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_LEN_CFG;                /*!< (@ 0x00000110) OCPM_LEN_CFG                                               */
    
    struct {
      __IOM uint32_t WR_BUFF_LEN : 16;          /*!< [15..0] WR_BUFF_LEN                                                       */
      __IOM uint32_t RD_BUFF_LEN : 16;          /*!< [31..16] RD_BUFF_LEN                                                      */
    } OCPM_LEN_CFG_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_INT;                 /*!< (@ 0x00000114) OCPM_RD_INT                                                */
    
    struct {
      __IM  uint32_t RD_BD_SIZE_INT : 1;        /*!< [0..0] RD_BD_SIZE_INT                                                     */
      __IM  uint32_t RD_BD_ADDR_INT : 1;        /*!< [1..1] RD_BD_ADDR_INT                                                     */
      __IM  uint32_t WR_BD_SIZE_INT : 1;        /*!< [2..2] WR_BD_SIZE_INT                                                     */
      __IM  uint32_t WR_BD_ADDR_INT : 1;        /*!< [3..3] WR_BD_ADDR_INT                                                     */
            uint32_t            : 28;
    } OCPM_RD_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_CLR_INT;             /*!< (@ 0x00000118) OCPM_RD_CLR_INT                                            */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_INT : 1;        /*!< [0..0] RD_BD_SIZE_INT                                                     */
      __IOM uint32_t RD_BD_ADDR_INT : 1;        /*!< [1..1] RD_BD_ADDR_INT                                                     */
      __IOM uint32_t WR_BD_SIZE_INT : 1;        /*!< [2..2] WR_BD_SIZE_INT                                                     */
      __IOM uint32_t WR_BD_ADDR_INT : 1;        /*!< [3..3] WR_BD_ADDR_INT                                                     */
            uint32_t            : 28;
    } OCPM_RD_CLR_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_MASK_INT;               /*!< (@ 0x0000011C) OCPM_MASK_INT                                              */
    
    struct {
      __IOM uint32_t MASK_RD_BD_SIZE_INT : 1;   /*!< [0..0] MASK_RD_BD_SIZE_INT                                                */
      __IOM uint32_t MASK_RD_BD_ADDR_INT : 1;   /*!< [1..1] MASK_RD_BD_ADDR_INT                                                */
      __IOM uint32_t MASK_WR_BD_SIZE_INT : 1;   /*!< [2..2] MASK_WR_BD_SIZE_INT                                                */
      __IOM uint32_t MASK_WR_BD_ADDR_INT : 1;   /*!< [3..3] MASK_WR_BD_ADDR_INT                                                */
            uint32_t            : 28;
    } OCPM_MASK_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_INT_EN;                 /*!< (@ 0x00000120) OCPM_INT_EN                                                */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_INT_EN : 1;     /*!< [0..0] RD_BD_SIZE_INT_EN                                                  */
      __IOM uint32_t RD_BD_ADDR_INT_EN : 1;     /*!< [1..1] RD_BD_ADDR_INT_EN                                                  */
      __IOM uint32_t WR_BD_SIZE_INT_EN : 1;     /*!< [2..2] WR_BD_SIZE_INT_EN                                                  */
      __IOM uint32_t WR_BD_ADDR_INT_EN : 1;     /*!< [3..3] WR_BD_ADDR_INT_EN                                                  */
            uint32_t            : 28;
    } OCPM_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BUFF_ACTIVE;            /*!< (@ 0x00000124) OCPM_BUFF_ACTIVE                                           */
    
    struct {
      __IOM uint32_t WR_BUFF_ACTIVE : 1;        /*!< [0..0] WR_BUFF_ACTIVE                                                     */
            uint32_t            : 7;
      __IOM uint32_t RD_BUFF_ACTIVE : 1;        /*!< [8..8] RD_BUFF_ACTIVE                                                     */
            uint32_t            : 7;
      __IOM uint32_t RD_BUFF_CYCLIC_EN : 1;     /*!< [16..16] RD_BUFF_CYCLIC_EN                                                */
            uint32_t            : 7;
      __IOM uint32_t WR_BUFF_CYCLIC_EN : 1;     /*!< [24..24] WR_BUFF_CYCLIC_EN                                                */
            uint32_t            : 7;
    } OCPM_BUFF_ACTIVE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_ADDR;             /*!< (@ 0x00000128) OCPM_WR_BD_ADDR                                            */
    
    struct {
      __IOM uint32_t WR_BD_ADDR : 32;           /*!< [31..0] WR_BD_ADDR                                                        */
    } OCPM_WR_BD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_SIZE;             /*!< (@ 0x0000012C) OCPM_WR_BD_SIZE                                            */
    
    struct {
      __IOM uint32_t WR_BD_SIZE : 16;           /*!< [15..0] WR_BD_SIZE                                                        */
            uint32_t            : 16;
    } OCPM_WR_BD_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_ADDR;             /*!< (@ 0x00000130) OCPM_RD_BD_ADDR                                            */
    
    struct {
      __IOM uint32_t RD_BD_ADDR : 32;           /*!< [31..0] RD_BD_ADDR                                                        */
    } OCPM_RD_BD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_SIZE;             /*!< (@ 0x00000134) OCPM_RD_BD_SIZE                                            */
    
    struct {
      __IOM uint32_t RD_BD_SIZE : 16;           /*!< [15..0] RD_BD_SIZE                                                        */
            uint32_t            : 16;
    } OCPM_RD_BD_SIZE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_ADDR_STATE;       /*!< (@ 0x00000138) OCPM_WR_BD_ADDR_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_WR_BD_ADDR_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_WR_BD_SIZE_STATE;       /*!< (@ 0x0000013C) OCPM_WR_BD_SIZE_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_WR_BD_SIZE_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_ADDR_STATE;       /*!< (@ 0x00000140) OCPM_RD_BD_ADDR_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_RD_BD_ADDR_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_BD_SIZE_STATE;       /*!< (@ 0x00000144) OCPM_RD_BD_SIZE_STATE                                      */
    
    struct {
      __IM  uint32_t FIFO_STATUS : 5;           /*!< [4..0] FIFO_STATUS                                                        */
            uint32_t            : 3;
      __IM  uint32_t RD_PTR     : 4;            /*!< [11..8] RD_PTR                                                            */
            uint32_t            : 4;
      __IM  uint32_t WR_PTR     : 4;            /*!< [19..16] WR_PTR                                                           */
            uint32_t            : 4;
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [24..24] FIFO_EMPTY                                                       */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [25..25] FIFO_FULL                                                        */
            uint32_t            : 6;
    } OCPM_RD_BD_SIZE_STATE_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BD_CFG_THRES;           /*!< (@ 0x00000148) OCPM_BD_CFG_THRES                                          */
    
    struct {
      __IOM uint32_t RD_BD_SIZE_THRES : 5;      /*!< [4..0] RD_BD_SIZE_THRES                                                   */
            uint32_t            : 3;
      __IOM uint32_t RD_BD_ADDR_THRES : 5;      /*!< [12..8] RD_BD_ADDR_THRES                                                  */
            uint32_t            : 3;
      __IOM uint32_t WR_BD_SIZE_THRES : 5;      /*!< [20..16] WR_BD_SIZE_THRES                                                 */
            uint32_t            : 3;
      __IOM uint32_t WR_BD_ADDR_THRES : 5;      /*!< [28..24] WR_BD_ADDR_THRES                                                 */
            uint32_t            : 3;
    } OCPM_BD_CFG_THRES_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_OCP_LEN_STATUS;         /*!< (@ 0x0000014C) OCPM_OCP_LEN_STATUS                                        */
    
    struct {
      __IM  uint32_t OCP_RD_LEN_CNT : 16;       /*!< [15..0] OCP_RD_LEN_CNT                                                    */
      __IM  uint32_t OCP_WR_LEN_CNT : 16;       /*!< [31..16] OCP_WR_LEN_CNT                                                   */
    } OCPM_OCP_LEN_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_BUF_FIFO_STATUS;        /*!< (@ 0x00000150) OCPM_BUF_FIFO_STATUS                                       */
    
    struct {
      __IM  uint32_t OCPM_MOSI_FIFO_STATUS : 4; /*!< [3..0] OCPM_MOSI_FIFO_STATUS                                              */
            uint32_t            : 4;
      __IM  uint32_t OCPM_MOSI_FIFO_RD_PTR : 3; /*!< [10..8] OCPM_MOSI_FIFO_RD_PTR                                             */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MOSI_FIFO_WR_PTR : 3; /*!< [14..12] OCPM_MOSI_FIFO_WR_PTR                                            */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MISO_FIFO_STATUS : 4; /*!< [19..16] OCPM_MISO_FIFO_STATUS                                            */
            uint32_t            : 4;
      __IM  uint32_t OCPM_MISO_FIFO_RD_PTR : 3; /*!< [26..24] OCPM_MISO_FIFO_RD_PTR                                            */
            uint32_t            : 1;
      __IM  uint32_t OCPM_MISO_FIFO_WR_PTR : 3; /*!< [30..28] OCPM_MISO_FIFO_WR_PTR                                            */
            uint32_t            : 1;
    } OCPM_BUF_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_ERR_INT;             /*!< (@ 0x00000154) OCPM_RD_ERR_INT                                            */
    
    struct {
      __IM  uint32_t WR_BD_SIZE_UNDERFLOW : 1;  /*!< [0..0] WR_BD_SIZE_UNDERFLOW                                               */
      __IM  uint32_t WR_BD_SIZE_OVERFLOW : 1;   /*!< [1..1] WR_BD_SIZE_OVERFLOW                                                */
      __IM  uint32_t WR_BD_ADDR_UNDERFLOW : 1;  /*!< [2..2] WR_BD_ADDR_UNDERFLOW                                               */
      __IM  uint32_t WR_BD_ADDR_OVERFLOW : 1;   /*!< [3..3] WR_BD_ADDR_OVERFLOW                                                */
      __IM  uint32_t RD_BD_SIZE_UNDERFLOW : 1;  /*!< [4..4] RD_BD_SIZE_UNDERFLOW                                               */
      __IM  uint32_t RD_BD_SIZE_OVERFLOW : 1;   /*!< [5..5] RD_BD_SIZE_OVERFLOW                                                */
      __IM  uint32_t RD_BD_ADDR_UNDERFLOW : 1;  /*!< [6..6] RD_BD_ADDR_UNDERFLOW                                               */
      __IM  uint32_t RD_BD_ADDR_OVERFLOW : 1;   /*!< [7..7] RD_BD_ADDR_OVERFLOW                                                */
      __IM  uint32_t OCPM_MOSI_BUFFER_UNDERFLOW : 1;/*!< [8..8] OCPM_MOSI_BUFFER_UNDERFLOW                                     */
      __IM  uint32_t OCPM_MOSI_BUFFER_OVERFLOW : 1;/*!< [9..9] OCPM_MOSI_BUFFER_OVERFLOW                                       */
      __IM  uint32_t OCPM_MISO_BUFFER_UNDERFLOW : 1;/*!< [10..10] OCPM_MISO_BUFFER_UNDERFLOW                                   */
      __IM  uint32_t OCPM_MISO_BUFFER_OVERFLOW : 1;/*!< [11..11] OCPM_MISO_BUFFER_OVERFLOW                                     */
            uint32_t            : 20;
    } OCPM_RD_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_RD_CLR_ERR_INT;         /*!< (@ 0x00000158) OCPM_RD_CLR_ERR_INT                                        */
    
    struct {
      __IM  uint32_t WR_BD_SIZE_UNDERFLOW : 1;  /*!< [0..0] WR_BD_SIZE_UNDERFLOW                                               */
      __IM  uint32_t WR_BD_SIZE_OVERFLOW : 1;   /*!< [1..1] WR_BD_SIZE_OVERFLOW                                                */
      __IM  uint32_t WR_BD_ADDR_UNDERFLOW : 1;  /*!< [2..2] WR_BD_ADDR_UNDERFLOW                                               */
      __IM  uint32_t WR_BD_ADDR_OVERFLOW : 1;   /*!< [3..3] WR_BD_ADDR_OVERFLOW                                                */
      __IM  uint32_t RD_BD_SIZE_UNDERFLOW : 1;  /*!< [4..4] RD_BD_SIZE_UNDERFLOW                                               */
      __IM  uint32_t RD_BD_SIZE_OVERFLOW : 1;   /*!< [5..5] RD_BD_SIZE_OVERFLOW                                                */
      __IM  uint32_t RD_BD_ADDR_UNDERFLOW : 1;  /*!< [6..6] RD_BD_ADDR_UNDERFLOW                                               */
      __IM  uint32_t RD_BD_ADDR_OVERFLOW : 1;   /*!< [7..7] RD_BD_ADDR_OVERFLOW                                                */
      __IM  uint32_t OCPM_MOSI_BUFFER_UNDERFLOW : 1;/*!< [8..8] OCPM_MOSI_BUFFER_UNDERFLOW                                     */
      __IM  uint32_t OCPM_MOSI_BUFFER_OVERFLOW : 1;/*!< [9..9] OCPM_MOSI_BUFFER_OVERFLOW                                       */
      __IM  uint32_t OCPM_MISO_BUFFER_UNDERFLOW : 1;/*!< [10..10] OCPM_MISO_BUFFER_UNDERFLOW                                   */
      __IM  uint32_t OCPM_MISO_BUFFER_OVERFLOW : 1;/*!< [11..11] OCPM_MISO_BUFFER_OVERFLOW                                     */
            uint32_t            : 20;
    } OCPM_RD_CLR_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_MASK_ERR_INT;           /*!< (@ 0x0000015C) OCPM_MASK_ERR_INT                                          */
    
    struct {
      __IOM uint32_t MASK_WR_BD_SIZE_UNDERFLOW : 1;/*!< [0..0] MASK_WR_BD_SIZE_UNDERFLOW                                       */
      __IOM uint32_t MASK_WR_BD_SIZE_OVERFLOW : 1;/*!< [1..1] MASK_WR_BD_SIZE_OVERFLOW                                         */
      __IOM uint32_t MASK_WR_BD_ADDR_UNDERFLOW : 1;/*!< [2..2] MASK_WR_BD_ADDR_UNDERFLOW                                       */
      __IOM uint32_t MASK_WR_BD_ADDR_OVERFLOW : 1;/*!< [3..3] MASK_WR_BD_ADDR_OVERFLOW                                         */
      __IOM uint32_t MASK_RD_BD_SIZE_UNDERFLOW : 1;/*!< [4..4] MASK_RD_BD_SIZE_UNDERFLOW                                       */
      __IOM uint32_t MASK_RD_BD_SIZE_OVERFLOW : 1;/*!< [5..5] MASK_RD_BD_SIZE_OVERFLOW                                         */
      __IOM uint32_t MASK_RD_BD_ADDR_UNDERFLOW : 1;/*!< [6..6] MASK_RD_BD_ADDR_UNDERFLOW                                       */
      __IOM uint32_t MASK_RD_BD_ADDR_OVERFLOW : 1;/*!< [7..7] MASK_RD_BD_ADDR_OVERFLOW                                         */
      __IOM uint32_t MASK_OCPM_MOSI_BUFFER_UNDERFLOW : 1;/*!< [8..8] MASK_OCPM_MOSI_BUFFER_UNDERFLOW                           */
      __IOM uint32_t MASK_OCPM_MOSI_BUFFER_OVERFLOW : 1;/*!< [9..9] MASK_OCPM_MOSI_BUFFER_OVERFLOW                             */
      __IOM uint32_t MASK_OCPM_MISO_BUFFER_UNDERFLOW : 1;/*!< [10..10] MASK_OCPM_MISO_BUFFER_UNDERFLOW                         */
      __IOM uint32_t MASK_OCPM_MISO_BUFFER_OVERFLOW : 1;/*!< [11..11] MASK_OCPM_MISO_BUFFER_OVERFLOW                           */
            uint32_t            : 20;
    } OCPM_MASK_ERR_INT_b;
  } ;
  
  union {
    __IOM uint32_t OCPM_ERR_INT_EN;             /*!< (@ 0x00000160) OCPM_ERR_INT_EN                                            */
    
    struct {
      __IOM uint32_t WR_BD_SIZE_UNDERFLOW_ERR_INT_EN : 1;/*!< [0..0] WR_BD_SIZE_UNDERFLOW_ERR_INT_EN                           */
      __IOM uint32_t WR_BD_SIZE_OVERFLOW_ERR_INT_EN : 1;/*!< [1..1] WR_BD_SIZE_OVERFLOW_ERR_INT_EN                             */
      __IOM uint32_t WR_BD_ADDR_UNDERFLOW_ERR_INT_EN : 1;/*!< [2..2] WR_BD_ADDR_UNDERFLOW_ERR_INT_EN                           */
      __IOM uint32_t WR_BD_ADDR_OVERFLOW_ERR_INT_EN : 1;/*!< [3..3] WR_BD_ADDR_OVERFLOW_ERR_INT_EN                             */
      __IOM uint32_t RD_BD_SIZE_UNDERFLOW_ERR_INT_EN : 1;/*!< [4..4] RD_BD_SIZE_UNDERFLOW_ERR_INT_EN                           */
      __IOM uint32_t RD_BD_SIZE_OVERFLOW_ERR_INT_EN : 1;/*!< [5..5] RD_BD_SIZE_OVERFLOW_ERR_INT_EN                             */
      __IOM uint32_t RD_BD_ADDR_UNDERFLOW_ERR_INT_EN : 1;/*!< [6..6] RD_BD_ADDR_UNDERFLOW_ERR_INT_EN                           */
      __IOM uint32_t RD_BD_ADDR_OVERFLOW_ERR_INT_EN : 1;/*!< [7..7] RD_BD_ADDR_OVERFLOW_ERR_INT_EN                             */
      __IOM uint32_t OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN : 1;/*!< [8..8] OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN               */
      __IOM uint32_t OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN : 1;/*!< [9..9] OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN                 */
      __IOM uint32_t OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN : 1;/*!< [10..10] OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN             */
      __IOM uint32_t OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN : 1;/*!< [11..11] OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN               */
            uint32_t            : 20;
    } OCPM_ERR_INT_EN_b;
  } ;
} SPI_SLAVE_Type;                               /*!< Size = 356 (0x164)                                                        */



/* =========================================================================================================================== */
/* ================                                         I2C0_CTRL                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C Master controller #0 (I2C0_CTRL)
  */

typedef struct {                                /*!< (@ 0x00200000) I2C0_CTRL Structure                                        */
  
  union {
    __IOM uint32_t CMD_FIFO;                    /*!< (@ 0x00000000) CMD_FIFO                                                   */
    
    struct {
      __OM  uint32_t COMMAND    : 6;            /*!< [5..0] COMMAND depends on Basic_I2c : Basic_I2c = 0 -> COMMAND[5:0]
                                                     = LEN[5:0]; Number of bytes to write or read (send or receive)
                                                     minus one( len=0->1 byte). when Basic_I2c = 1 -> COMMAND[5]
                                                     = RESTART - Activates a restart sequence to enable a start
                                                     that does not follow a stop ; COMMAND[4] = START - Activates
                                                     the start sequence in the Line Driver; COMMAND[3] = STOP
                                                     - Activates the stop sequence in the Line Driver ; COMMAND[2]
                                                     = TX - Activates the Transmission sequence in the Line
                                                     Driver; transmitting Cmd[                                                 */
      __OM  uint32_t EN_INT_DONE : 1;           /*!< [6..6] Enable interrupt when command is done -When set to &#8220;1&#8221;
                                                     an interrupt will occur at the end of the execution of
                                                     the command                                                               */
      __OM  uint32_t RW         : 1;            /*!< [7..7] Read/Write bit - 1= read ; 0= write                                */
      __OM  uint32_t ADDRESS    : 24;           /*!< [31..8] Address 3 bytes - The address of the memory in the chosen
                                                     slave unit on the bus; this is the internal address of
                                                     the device. In case of using EEPROM this is the internal
                                                     address in the EEPROM which will be written to in case
                                                     of wrote or read form in case of read                                     */
    } CMD_FIFO_b;
  } ;
  
  union {
    __IOM uint32_t WDATA_FIFO;                  /*!< (@ 0x00000004) WDATA_FIFO                                                 */
    
    struct {
      __OM  uint32_t WDATA      : 32;           /*!< [31..0] 4 bytes of data arranged in big endian order. The FIFO
                                                     is byte wide; therefore not all the word will be pushed
                                                     to it; only the bytes matching the byte enable[3:0] recived
                                                     from the system's interconnect fabric.                                    */
    } WDATA_FIFO_b;
  } ;
  
  union {
    __IOM uint32_t RDATA_FIFO;                  /*!< (@ 0x00000008) RDATA_FIFO                                                 */
    
    struct {
      __IM  uint32_t RDATA      : 32;           /*!< [31..0] 4 bytes of data arranged in big endian order. The FIFO
                                                     is byte wide therefore not all 4 bytes from Rdata FIFO
                                                     will be pulled from it ;only the bytes matching the byte
                                                     enable[3:0] recived from the system's interconnect fabric.                */
    } RDATA_FIFO_b;
  } ;
  
  union {
    __IOM uint32_t CMD_FIFO_STATUS;             /*!< (@ 0x0000000C) CMD_FIFO_STATUS                                            */
    
    struct {
      __IM  uint32_t CMD_WP     : 4;            /*!< [3..0] Points to the current address to write to.                         */
            uint32_t            : 4;
      __IM  uint32_t CMD_RP     : 4;            /*!< [11..8] Points to the current address to read from.                       */
            uint32_t            : 4;
      __IM  uint32_t CMD_STATUS : 5;            /*!< [20..16] Counter incremented with each write and decreased with
                                                     each read from the Cmd FIFO                                               */
            uint32_t            : 10;
      __IM  uint32_t CMD_FIFO_FULL : 1;         /*!< [31..31] indicates when asserted rthat the cmd_fifo is full               */
    } CMD_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t WDATA_FIFO_STATUS;           /*!< (@ 0x00000010) WDATA_FIFO_STATUS                                          */
    
    struct {
      __IM  uint32_t WDATA_WP   : 6;            /*!< [5..0] Points to the current address to write to.                         */
            uint32_t            : 2;
      __IM  uint32_t WDATA_RP   : 6;            /*!< [13..8] Points to the current address to read from.                       */
            uint32_t            : 2;
      __IM  uint32_t WDATA_STATUS : 7;          /*!< [22..16] Counter incremented with each write and decreased with
                                                     each read from the WDATA FIFO                                             */
            uint32_t            : 8;
      __IM  uint32_t WDATA_FIFO_EMPTY : 1;      /*!< [31..31] indicates when asserted rthat the wdata_fifo is empty            */
    } WDATA_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t RDATA_FIFO_STATUS;           /*!< (@ 0x00000014) RDATA_FIFO_STATUS                                          */
    
    struct {
      __IM  uint32_t RDATA_WP   : 6;            /*!< [5..0] Points to the current address to write to.                         */
            uint32_t            : 2;
      __IM  uint32_t RDATA_RP   : 6;            /*!< [13..8] Points to the current address to read from.                       */
            uint32_t            : 2;
      __IM  uint32_t RDATA_STATUS : 7;          /*!< [22..16] Counter incremented with each write and decreased with
                                                     each read from the RDATA FIFO                                             */
            uint32_t            : 8;
      __IM  uint32_t RDATA_FIFO_FULL : 1;       /*!< [31..31] indicates when asserted rthat the rdata_fifo is full             */
    } RDATA_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t LAST_EXE_CMD;                /*!< (@ 0x00000018) Displays the last executable command                       */
    
    struct {
      __IM  uint32_t COMMAND    : 6;            /*!< [5..0] COMMAND depends on Basic_I2c : Basic_I2c = 0 -> COMMAND[5:0]
                                                     = LEN[5:0]; Number of bytes to write or read (send or receive)
                                                     minus one( len=0->1 byte). when Basic_I2c = 1 -> COMMAND[5]
                                                     = RESTART - Activates a restart sequence to enable a start
                                                     that does not follow a stop ; COMMAND[4] = START - Activates
                                                     the start sequence in the Line Driver; COMMAND[3] = STOP
                                                     - Activates the stop sequence in the Line Driver ; COMMAND[2]
                                                     = TX - Activates the Transmission sequence in the Line
                                                     Driver; transmitting Cmd[                                                 */
      __IM  uint32_t EN_INT_DONE : 1;           /*!< [6..6] Enable interrupt when command is done -When set to &#8220;1&#8221;
                                                     an interrupt will occur at the end of the execution of
                                                     the command                                                               */
      __IM  uint32_t RW         : 1;            /*!< [7..7] Read/Write bit - 1= read ; 0= write                                */
      __IM  uint32_t ADDRESS    : 24;           /*!< [31..8] Address 3 bytes - The address of the memory in the chosen
                                                     slave unit on the bus                                                     */
    } LAST_EXE_CMD_b;
  } ;
  
  union {
    __IOM uint32_t MAIN_CTRL_CFG;               /*!< (@ 0x0000001C) MAIN_CTRL_CFG                                              */
    
    struct {
      __IOM uint32_t DEVICE_SEL : 10;           /*!< [9..0] Address of slave device on the I2C bus. This feture is
                                                     only relevant in automatic I2C and not in Basic mode .                    */
      __IOM uint32_t TEN_BIT_DEVICE_SEL : 1;    /*!< [10..10] selects a 10 bit device address oprion instead of a
                                                     default 7 bit device address                                              */
      __IOM uint32_t ADD_LEN    : 2;            /*!< [12..11] Number of address bytes. min 1 byte max 3 bytes .                */
      __IOM uint32_t I2C_IO_SEL : 1;            /*!< [13..13] Should be kept at default value 0x0                              */
      __IOM uint32_t ENDIAN_SWAP_EN : 1;        /*!< [14..14] endian swap                                                      */
            uint32_t            : 1;
      __IOM uint32_t ENABLE_MULTI_MASTER : 1;   /*!< [16..16] Must remain 1'b0 !!! This feature is not implementedenables
                                                     multi master - when used the sda cannot be driven high                    */
            uint32_t            : 7;
      __IOM uint32_t SCL_STRETCH_EN : 1;        /*!< [24..24] configurable feature that enables the clock stretch
                                                     by slave device                                                           */
            uint32_t            : 3;
      __IOM uint32_t DRIVE_SCL_HIGH_EN : 1;     /*!< [28..28] When not connected to i2c this configuration bit will
                                                     enable to drive high value on the SCL bus                                 */
      __IOM uint32_t DRIVE_SDA_HIGH_EN : 1;     /*!< [29..29] When not connected to i2c this configuration bit will
                                                     enable to drive high value on the SDA bus                                 */
      __IOM uint32_t WP         : 1;            /*!< [30..30] Can be connected through the IO muxing to the EEPROM
                                                     as a write protection; if set to '1' the EEPROM will not
                                                     received transmission of data.                                            */
      __IOM uint32_t BASIC_I2C  : 1;            /*!< [31..31] Disables the automatic ('EEPROM') higher I2c protocol
                                                     and enables a simple command base activation of the Line
                                                     Driver. Changes the command fields as shown in the Cmd
                                                     FIFO                                                                      */
    } MAIN_CTRL_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER1_CFG;                /*!< (@ 0x00000020) COUNTER1_CFG                                               */
    
    struct {
      __IOM uint32_t COUNT_DIVIDE : 16;         /*!< [15..0] When count reaches its value it changes phase of SCL.             */
      __IOM uint32_t COUNT_RECOVERY : 16;       /*!< [31..16] When count reaches its value it moves on from the recovery
                                                     state; At the end of a stop sequence.                                     */
    } COUNTER1_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER2_CFG;                /*!< (@ 0x00000024) COUNTER2_CFG                                               */
    
    struct {
      __IOM uint32_t COUNT_T2R  : 16;           /*!< [15..0] When count reaches its value it stops transmitting.
                                                     relevant on change from transmission to reception                         */
      __IOM uint32_t COUNT_R2T  : 16;           /*!< [31..16] When count reaches its value it starts transmitting;
                                                     relevant on change from reception to transmission                         */
    } COUNTER2_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER3_CFG;                /*!< (@ 0x00000028) COUNTER3_CFG                                               */
    
    struct {
      __IOM uint32_t COUNT_START_HOLD : 16;     /*!< [15..0] start hold time; period of time from SDA posedge to
                                                     SCL negedge ; counter limit before SCL pull down when SDA
                                                     is LOW in start sequence                                                  */
      __IOM uint32_t COUNT_START_SETUP : 16;    /*!< [31..16] start setup time; period of time from SCL posedge to
                                                     SDA negedge ; counter limit before SDA pull down when SCL
                                                     is HIGH in start sequence                                                 */
    } COUNTER3_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER4_CFG;                /*!< (@ 0x0000002C) COUNTER4_CFG                                               */
    
    struct {
      __IOM uint32_t COUNT_STOP_SETUP : 16;     /*!< [15..0] stop setup time; period of time from SCL posedge to
                                                     SDA posedge ; counter limit before SDA pull up when SCL
                                                     is HIGH in stop sequence                                                  */
      __IOM uint32_t DUTY_CYCLE : 16;           /*!< [31..16] The addition to the count_divide so the raising edge
                                                     of SCL could be delayed or preceded ( supports two&#8217;s
                                                     complement)                                                               */
    } COUNTER4_CFG_b;
  } ;
  
  union {
    __IOM uint32_t FLUSH_CFG;                   /*!< (@ 0x00000030) FLUSH_CFG                                                  */
    
    struct {
      __OM  uint32_t FLUSH_RDATA : 1;           /*!< [0..0] When set to '1' it will reset the FIFO ; by initializing
                                                     Rd Wr pointers and clear status.                                          */
            uint32_t            : 7;
      __OM  uint32_t FLUSH_WDATA : 1;           /*!< [8..8] When set to '1' it will reset the FIFO ; by initializing
                                                     Rd Wr pointers and clear status.                                          */
            uint32_t            : 7;
      __OM  uint32_t FLUSH_CMD  : 1;            /*!< [16..16] When set to '1' it will reset the FIFO ; by initializing
                                                     Rd Wr pointers and clear status.                                          */
            uint32_t            : 7;
      __OM  uint32_t SM_RESET   : 1;            /*!< [24..24] When set to '1' it will reset the main controller state
                                                     machine to IDLE state                                                     */
            uint32_t            : 7;
    } FLUSH_CFG_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_CFG;               /*!< (@ 0x00000034) INTERRUPT_CFG                                              */
    
    struct {
      __IOM uint32_t RDATA_S_INT : 7;           /*!< [6..0] ready Rdata FIFO status threshold; this value represents
                                                     the number of full words; when this value is reached the
                                                     dma can read form the data_fifo at least the value of the
                                                     threshold                                                                 */
      __IOM uint32_t M_LINE_ABORT : 1;          /*!< [7..7] Mask interrupt (1-masked; 0-not masked) i2c_line_abort             */
      __IOM uint32_t WDATA_S_INT : 7;           /*!< [14..8] ready Wdata FIFO status thresholds; this value represents
                                                     the number of free words; when this value is reached the
                                                     data_fifo can receive at least the value of the threshold                 */
      __IOM uint32_t CMD_S_INT  : 5;            /*!< [19..15] Cmd FIFO status thresholds; this value represents the
                                                     number of free commands; when this value is reached the
                                                     cmd_fifo can receive at least the value of the threshold                  */
      __IM  uint32_t M_CMD_OVER_NO_SPACE_RDATA : 1;/*!< [20..20] Mask interrupt (1-masked; 0-not masked) err cmd overflow
                                                     with no space to write rdata from controller                              */
      __IM  uint32_t M_CMD_OVER_NO_WDATA : 1;   /*!< [21..21] Mask interrupt (1-masked; 0-not masked) err cmd overflow
                                                     with no wdata                                                             */
      __IM  uint32_t M_DATA_UNDER_NO_CMD : 1;   /*!< [22..22] Mask interrupt (1-masked; 0-not masked) err data underflow
                                                     with no cmd                                                               */
      __IM  uint32_t M_DATA_OVER_NO_CMD : 1;    /*!< [23..23] Mask interrupt (1-masked; 0-not masked) err data overflow
                                                     with no cmd                                                               */
      __IOM uint32_t M_RDATA    : 1;            /*!< [24..24] Mask interrupt (1-masked; 0-not masked) Rdata status             */
      __IOM uint32_t M_WDATA    : 1;            /*!< [25..25] Mask interrupt (1-masked; 0-not masked) Wdata status             */
      __IOM uint32_t M_CMD      : 1;            /*!< [26..26] Mask interrupt (1-masked; 0-not masked) cmd status               */
      __IOM uint32_t M_DONE     : 1;            /*!< [27..27] Mask interrupt (1-masked; 0-not masked) done                     */
      __IOM uint32_t M_NACK_ERR : 1;            /*!< [28..28] Mask interrupt (1-masked; 0-not masked) error when
                                                     received Nack                                                             */
      __IOM uint32_t M_RDATA_UNDERFLOW : 1;     /*!< [29..29] Mask interrupt (1-masked; 0-not masked) when rdata
                                                     fifo is underflow                                                         */
      __IOM uint32_t M_WDATA_OVERFLOW : 1;      /*!< [30..30] Mask interrupt (1-masked; 0-not masked) when wdata
                                                     fifo is overflow                                                          */
      __IOM uint32_t M_CMD_OVERFLOW : 1;        /*!< [31..31] Mask interrupt (1-masked; 0-not masked) when cmd fifo
                                                     is overflow                                                               */
    } INTERRUPT_CFG_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_STATUS;            /*!< (@ 0x00000038) Read only status of interrupts                             */
    
    struct {
      __IM  uint32_t RDATA_STATUS_C_INT : 1;    /*!< [0..0] Interrupt cause Rdata status is bigger than RDATA_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t WDATA_STATUS_C_INT : 1;    /*!< [1..1] Interrupt cause when free space is bigger than WDATA_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t CMD_STATUS_C_INT : 1;      /*!< [2..2] Interrupt cause when free space is bigger than CMD_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t DONE_C_INT : 1;            /*!< [3..3] Interrupt cause Cmd done                                           */
      __IM  uint32_t NACK_ERR_C_INT : 1;        /*!< [4..4] Error-Interrupt cause- NACK error                                  */
      __IM  uint32_t RDATA_UNDER_C_INT : 1;     /*!< [5..5] Error-interrupt cause - trying to read underflow from
                                                     Rdata FIFO                                                                */
      __IM  uint32_t WDATA_OVER_C_INT : 1;      /*!< [6..6] Error-interrupt cause - trying to write overflow to Wdata
                                                     FIFO                                                                      */
      __IM  uint32_t CMD_OVER_C_INT : 1;        /*!< [7..7] Error-interrupt cause &#8211; trying to write overflow
                                                     to Cmd FIFO                                                               */
      __IM  uint32_t CMD_OVER_NO_SPACE_RDATA_C_INT : 1;/*!< [8..8] Error-interrupt cmd fifo overflow in read mode and read
                                                     condition is not valid ; in hw flow control this is a dead
                                                     lock                                                                      */
      __IM  uint32_t CMD_OVER_NO_WDATA_C_INT : 1;/*!< [9..9] Error-interrupt cmd fifo overflow in write mode and write
                                                     condition is not valid ; in hw flow control this is a dead
                                                     lock                                                                      */
      __IM  uint32_t DATA_UNDER_NO_CMD_C_INT : 1;/*!< [10..10] Error-interrupt rdata fifo is underflow and cmd fifo
                                                     is empty and main controller is in idle mode ; in hw flow
                                                     control this is a dead lock                                               */
      __IM  uint32_t DATA_OVER_NO_CMD_C_INT : 1;/*!< [11..11] Error-interrupt wdata fifo overflow and cmd fifo is
                                                     empty and main controller is in idle mode ; in hw flow
                                                     control this is a dead lock                                               */
      __IM  uint32_t LINE_ABORT_C_INT : 1;      /*!< [12..12] Error-interrupt wdata fifo overflow and cmd fifo is
                                                     empty and main controller is in idle mode ; in hw flow
                                                     control this is a dead lock                                               */
            uint32_t            : 19;
    } INTERRUPT_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_STATUS_RC;         /*!< (@ 0x0000003C) Read and clear status of interrupts                        */
    
    struct {
      __IOM uint32_t RDATA_STATUS_C_INT : 1;    /*!< [0..0] Interrupt cause Rdata status is bigger than RDATA_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t WDATA_STATUS_C_INT : 1;    /*!< [1..1] Interrupt cause when free space is bigger than WDATA_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t CMD_STATUS_C_INT : 1;      /*!< [2..2] Interrupt cause when free space is bigger than CMD_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t DONE_C_INT : 1;            /*!< [3..3] Interrupt cause Cmd done                                           */
      __IOM uint32_t NACK_ERR_C_INT : 1;        /*!< [4..4] Interrupt cause- NACK error                                        */
      __IOM uint32_t RDATA_UNDER_C_INT : 1;     /*!< [5..5] interrupt cause - trying to read underflow from Rdata
                                                     FIFO                                                                      */
      __IOM uint32_t WDATA_OVER_C_INT : 1;      /*!< [6..6] interrupt cause - trying to write overflow to Wdata FIFO           */
      __IOM uint32_t CMD_OVER_C_INT : 1;        /*!< [7..7] interrupt cause &#8211; trying to write overflow to Cmd
                                                     FIFO                                                                      */
      __IOM uint32_t CMD_OVER_NO_SPACE_RDATA_C_INT : 1;/*!< [8..8] cmd fifo overflow in read mode and read condition is
                                                     not valid ; in hw flow control this is a dead lock                        */
      __IOM uint32_t CMD_OVER_NO_WDATA_C_INT : 1;/*!< [9..9] cmd fifo overflow in write mode and write condition is
                                                     not valid ; in hw flow control this is a dead lock                        */
      __IOM uint32_t DATA_UNDER_NO_CMD_C_INT : 1;/*!< [10..10] rdata fifo is underflow and cmd fifo is empty and main
                                                     controller is in idle mode ; in hw flow control this is
                                                     a dead lock                                                               */
      __IOM uint32_t DATA_OVER_NO_CMD_C_INT : 1;/*!< [11..11] wdata fifo overflow and cmd fifo is empty and main
                                                     controller is in idle mode ; in hw flow control this is
                                                     a dead lock                                                               */
      __IOM uint32_t LINE_ABORT_C_INT : 1;      /*!< [12..12] Error-interrupt wdata fifo overflow and cmd fifo is
                                                     empty and main controller is in idle mode ; in hw flow
                                                     control this is a dead lock                                               */
            uint32_t            : 19;
    } INTERRUPT_STATUS_RC_b;
  } ;
  
  union {
    __IOM uint32_t CURRENT_STATE;               /*!< (@ 0x00000040) CURRENT_STATE                                              */
    
    struct {
      __IM  uint32_t LINE_DRIVER_STATE : 5;     /*!< [4..0] The current state in the Line driver state machine.                */
      __IM  uint32_t COUNT_EN   : 1;            /*!< [5..5] enables clock counter if not in idle state or a clock
                                                     stretching was implemented by slave device                                */
      __IM  uint32_t CURRENT_CMD_R_W : 1;       /*!< [6..6] current command read/write bit - 1= read ; 0= write                */
      __IM  uint32_t CURRENT_CMD_EN_INT_DONE : 1;/*!< [7..7] enable interrupt when done                                        */
      __IM  uint32_t T_COUNT    : 4;            /*!< [11..8] The current state of the T_count; Which is indication
                                                     of the SCL cycle                                                          */
      __IM  uint32_t RESTART    : 1;            /*!< [12..12] activates a restart sequence in the start sequence
                                                     ; set to 1 -> the SCL will be 0 at start ; set to 0 SCL
                                                     will be 1 at start sequence                                               */
      __IM  uint32_t READ_COND  : 1;            /*!< [13..13] current commanis read and there is at least the size
                                                     of length as free space in rdata fifo                                     */
      __IM  uint32_t WRITE_COND : 1;            /*!< [14..14] current command is write and there is at least the
                                                     size of length in the wdata_fifo                                          */
            uint32_t            : 1;
      __IM  uint32_t MAIN_CTL_STATE : 5;        /*!< [20..16] The current state in the main controller state machine.          */
            uint32_t            : 3;
      __IM  uint32_t CURRENT_CMD_LENGTH : 6;    /*!< [29..24] current command length                                           */
            uint32_t            : 1;
      __IM  uint32_t I2C_IDLE_STATE : 1;        /*!< [31..31] i2c idle state :0x0 - i2c is not in idle state ; 0x1
                                                     - i2c is in idle state ;                                                  */
    } CURRENT_STATE_b;
  } ;
  
  union {
    __IOM uint32_t READY_CFG;                   /*!< (@ 0x00000044) READY_CFG                                                  */
    
    struct {
      __IOM uint32_t RDATA_TRS_READY : 7;       /*!< [6..0] ready Rdata FIFO status threshold; this value represents
                                                     the number of full words; when this value is reached the
                                                     dma can read form the data_fifo at least the value of the
                                                     threshold                                                                 */
            uint32_t            : 1;
      __IOM uint32_t WDATA_TRS_READY : 7;       /*!< [14..8] ready Wdata FIFO status thresholds; this value represents
                                                     the number of free words; when this value is reached the
                                                     data_fifo can receive at least the value of the threshold                 */
            uint32_t            : 17;
    } READY_CFG_b;
  } ;
} I2C_CTRL_Type;                                /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                        SPI_MASTER0                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Master controller #0 (SPI_MASTER0)
  */

typedef struct {                                /*!< (@ 0x00220000) SPI_MASTER0 Structure                                      */
  
  union {
    __IOM uint32_t CMD_FIFO;                    /*!< (@ 0x00000000) CMD_FIFO                                                   */
    
    struct {
      __OM  uint32_t READ_EN    : 1;            /*!< [0..0] enable Read transaction from the slave. 0 = write transaction
                                                     When cs_keep_low is enabled - part of the address                         */
      __OM  uint32_t SLAVE_SELECT : 2;          /*!< [2..1] Slave select three options: &#8220;01&#8221; - cs1 ;
                                                     &#8220;10&#8221; &#8211; cs2 ; &#8220;11&#8221; &#8211;
                                                     cs3When cs_keep_low is enabled - part of the address                      */
      __OM  uint32_t EN_INT_DONE : 1;           /*!< [3..3] Enable interrupt when command is doneWhen cs_keep_low
                                                     is enabled - part of the address                                          */
      __OM  uint32_t CMD_LEN    : 4;            /*!< [7..4] Command length in word sizes if C/D mode is enabled for
                                                     the current slave selected                                                */
      __OM  uint32_t ADDRESS_SIZE : 6;          /*!< [13..8] Number of bits to transmit from the next line in the
                                                     cmd FIFO When cs_keep_low is enabled - part of the address                */
      __OM  uint32_t BASIC_CS_KEEP_LOW : 1;     /*!< [14..14] Keeps cs low when finishing executing a command                  */
      __OM  uint32_t FULL_DUPLEX : 1;           /*!< [15..15] Enables read and write at the same time                          */
      __OM  uint32_t LEN        : 16;           /*!< [31..16] Number of word size to write or read; When cs_keep_low
                                                     is enabled - part of the address                                          */
    } CMD_FIFO_b;
  } ;
  
  union {
    __IOM uint32_t WDATA_FIFO;                  /*!< (@ 0x00000004) WDATA_FIFO                                                 */
    
    struct {
      __OM  uint32_t WDATA      : 32;           /*!< [31..0] WData FIFO - write to fifoThe FIFO is a 32 bit wide
                                                     FIFO with a depth of 128 words; when in infinite mode the
                                                     word size is byte the 32 bit will contain up to 4 bytes.
                                                     When not in infinite mode each word size regardless of
                                                     the size will be held in one word row.The data FIFO is
                                                     both for reading and writing data                                         */
    } WDATA_FIFO_b;
  } ;
  
  union {
    __IOM uint32_t CMD_FIFO_STATUS;             /*!< (@ 0x00000008) CMD_FIFO_STATUS                                            */
    
    struct {
      __IM  uint32_t CMD_WP     : 3;            /*!< [2..0] Points to the current address to write to.                         */
            uint32_t            : 5;
      __IM  uint32_t CMD_RP     : 3;            /*!< [10..8] Points to the current address to read from.                       */
            uint32_t            : 5;
      __IM  uint32_t CMD_STATUS : 4;            /*!< [19..16] Counter incremented with each write and decreased with
                                                     each read from the Cmd FIFO                                               */
            uint32_t            : 12;
    } CMD_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t WDATA_FIFO_STATUS;           /*!< (@ 0x0000000C) WDATA_FIFO_STATUS                                          */
    
    struct {
      __IM  uint32_t WDATA_WP   : 8;            /*!< [7..0] Points to the current address to write to.                         */
      __IM  uint32_t WDATA_RP   : 8;            /*!< [15..8] Points to the current address to read from.                       */
      __IM  uint32_t WDATA_STATUS : 8;          /*!< [23..16] Counter incremented with each write and decreased with
                                                     each read from the WDATA FIFO                                             */
      __IM  uint32_t READ_EN    : 1;            /*!< [24..24] State of the Data FIFO : 1 = read ; 0 = write                    */
            uint32_t            : 6;
      __IM  uint32_t FULL_DUPLEX : 1;           /*!< [31..31] Value is relevant only if READ_EN =1 - then READ and
                                                     write both active                                                         */
    } WDATA_FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t LAST_EXE_CMD;                /*!< (@ 0x00000010) Displays the last executable command                       */
    
    struct {
      __IM  uint32_t READ_EN    : 1;            /*!< [0..0] enable Read transaction from the slave. 0 = write transaction
                                                     When cs_keep_low is enabled - part of the address                         */
      __IM  uint32_t SLAVE_SELECT : 2;          /*!< [2..1] Slave select three options: &#8220;01&#8221; - cs1 ;
                                                     &#8220;10&#8221; &#8211; cs2 ; &#8220;11&#8221; &#8211;
                                                     cs3When cs_keep_low is enabled - part of the address                      */
      __IM  uint32_t EN_INT_DONE : 1;           /*!< [3..3] Enable interrupt when command is doneWhen cs_keep_low
                                                     is enabled - part of the address                                          */
      __IM  uint32_t CMD_LEN    : 4;            /*!< [7..4] Command length in word sizes if C/D mode is enabled for
                                                     the current slave selected                                                */
      __IM  uint32_t ADDRESS_SIZE : 6;          /*!< [13..8] Number of bits to transmit from the next line in the
                                                     cmd FIFO When cs_keep_low is enabled - part of the address                */
      __IM  uint32_t BASIC_CS_KEEP_LOW : 1;     /*!< [14..14] Keeps cs low when finishing executing a command                  */
      __IM  uint32_t FULL_DUPLEX : 1;           /*!< [15..15] Enables read and write at the same time                          */
      __IM  uint32_t LEN        : 16;           /*!< [31..16] Number of word size to write or read; When cs_keep_low
                                                     is enabled - part of the address                                          */
    } LAST_EXE_CMD_b;
  } ;
  
  union {
    __IOM uint32_t CS1_CFG;                     /*!< (@ 0x00000014) CS1_CFG                                                    */
    
    struct {
      __IOM uint32_t CPOL_CS1   : 1;            /*!< [0..0] Clock polarity; 0 - idle at low; 1 - idle athigh                   */
      __IOM uint32_t CPHA_CS1   : 1;            /*!< [1..1] Clock phase; 0 &#8211; even phase exchange ; 1- odd phase
                                                     exchange                                                                  */
      __IOM uint32_t WS_CS1     : 6;            /*!< [7..2] Word size; number of bit to be exchanged at each exchange.         */
      __IOM uint32_t INFINITE_CS1 : 1;          /*!< [8..8] High value represents Infinite mode; enabling word size
                                                     of byte to be send without raising cs between word size
                                                     transmissions; or reception.                                              */
      __IOM uint32_t REVERSAL_CS1 : 1;          /*!< [9..9] 0= regular. 1= reversal ;Regular- Msb to Lsb; Reversal
                                                     - Lsb to Msb                                                              */
      __IOM uint32_t ENDIAN_CS1 : 1;            /*!< [10..10] 0 = big endian. 1 = little endian ; Big endian - MsB
                                                     to LsB ; Little endian - LsB to MsB                                       */
      __IOM uint32_t CS_KEEP_LOW_CS1 : 1;       /*!< [11..11] Keep the cs low between the address transmission and
                                                     the following read or write ; if cs_keep_low is 'high'
                                                     then the cmd line is followed by an control/address line
                                                     ; and the cs will keep low after the transmission of the
                                                     address untill the end of the reception/transmission of
                                                     the first following word (sized WS)                                       */
      __IOM uint32_t CD_EN_CS1  : 1;            /*!< [12..12] Command / Data enable ; relevant in LCD                          */
      __IOM uint32_t NOP_CS1    : 1;            /*!< [13..13] Nop_command is relevant                                          */
      __IOM uint32_t ENABLE_PERIODS_CS1 : 1;    /*!< [14..14] If cs_keep_low is on then the hold period recovery
                                                     period and setup period could be unnecessary; since they
                                                     all refer to cs rise and fall; value &#8220;1&#8221; then
                                                     the time periods will occur normally ; value &#8220;0&#8221;
                                                     time periods will be skipped                                              */
      __IOM uint32_t THREE_WIRE_EN_CS1 : 1;     /*!< [15..15] enable 3 wire mode - cannot be on if full duplex is
                                                     set                                                                       */
      __IOM uint32_t COUNT_DIVIDE_CS1 : 16;     /*!< [31..16] counter limit for sck cycle; equals to the divide value
                                                     of the freq                                                               */
    } CS1_CFG_b;
  } ;
  
  union {
    __IOM uint32_t CS2_CFG;                     /*!< (@ 0x00000018) CS2_CFG                                                    */
    
    struct {
      __IOM uint32_t CPOL_CS2   : 1;            /*!< [0..0] Clock polarity; 0 - idle at low; 1 - idle athigh                   */
      __IOM uint32_t CPHA_CS2   : 1;            /*!< [1..1] Clock phase; 0 &#8211; even phase exchange ; 1- odd phase
                                                     exchange                                                                  */
      __IOM uint32_t WS_CS2     : 6;            /*!< [7..2] Word size; number of bit to be exchanged at each exchange.         */
      __IOM uint32_t INFINITE_CS2 : 1;          /*!< [8..8] High value represents Infinite mode; enabling word size
                                                     of byte to be send without raising cs between word size
                                                     transmissions; or reception.                                              */
      __IOM uint32_t REVERSAL_CS2 : 1;          /*!< [9..9] 0= regular. 1= reversal ;Regular- Msb to Lsb; Reversal
                                                     - Lsb to Msb                                                              */
      __IOM uint32_t ENDIAN_CS2 : 1;            /*!< [10..10] 0 = big endian. 1 = little endian ; Big endian - MsB
                                                     to LsB ; Little endian - LsB to MsB                                       */
      __IOM uint32_t CS_KEEP_LOW_CS2 : 1;       /*!< [11..11] Keep the cs low between the address transmission and
                                                     the following read or write ; if cs_keep_low is 'high'
                                                     then the cmd line is followed by an control/address line
                                                     ; and the cs will keep low after the transmission of the
                                                     address untill the end of the reception/transmission of
                                                     the first following word (sized WS)                                       */
      __IOM uint32_t CD_EN_CS2  : 1;            /*!< [12..12] Command / Data enable ; relevant in LCD                          */
      __IOM uint32_t NOP_CS2    : 1;            /*!< [13..13] Nop_command is relevant                                          */
      __IOM uint32_t ENABLE_PERIODS_CS2 : 1;    /*!< [14..14] If cs_keep_low is on then the hold period recovery
                                                     period and setup period could be unnecessary; since they
                                                     all refer to cs rise and fall; value &#8220;1&#8221; then
                                                     the time periods will occur normally ; value &#8220;0&#8221;
                                                     time periods will be skipped                                              */
      __IOM uint32_t THREE_WIRE_EN_CS2 : 1;     /*!< [15..15] enable 3 wire mode - cannot be on if full duplex is
                                                     set                                                                       */
      __IOM uint32_t COUNT_DIVIDE_CS2 : 16;     /*!< [31..16] counter limit for sck cycle; equals to the divide value
                                                     of the freq                                                               */
    } CS2_CFG_b;
  } ;
  
  union {
    __IOM uint32_t CS3_CFG;                     /*!< (@ 0x0000001C) CS3_CFG                                                    */
    
    struct {
      __IOM uint32_t CPOL_CS3   : 1;            /*!< [0..0] Clock polarity; 0 - idle at low; 1 - idle athigh                   */
      __IOM uint32_t CPHA_CS3   : 1;            /*!< [1..1] Clock phase; 0 &#8211; even phase exchange ; 1- odd phase
                                                     exchange                                                                  */
      __IOM uint32_t WS_CS3     : 6;            /*!< [7..2] Word size; number of bit to be exchanged at each exchange.         */
      __IOM uint32_t INFINITE_CS3 : 1;          /*!< [8..8] High value represents Infinite mode; enabling word size
                                                     of byte to be send without raising cs between word size
                                                     transmissions; or reception.                                              */
      __IOM uint32_t REVERSAL_CS3 : 1;          /*!< [9..9] 0= regular. 1= reversal ;Regular- Msb to Lsb; Reversal
                                                     - Lsb to Msb                                                              */
      __IOM uint32_t ENDIAN_CS3 : 1;            /*!< [10..10] 0 = big endian. 1 = little endian ; Big endian - MsB
                                                     to LsB ; Little endian - LsB to MsB                                       */
      __IOM uint32_t CS_KEEP_LOW_CS3 : 1;       /*!< [11..11] Keep the cs low between the address transmission and
                                                     the following read or write ; if cs_keep_low is 'high'
                                                     then the cmd line is followed by an control/address line
                                                     ; and the cs will keep low after the transmission of the
                                                     address untill the end of the reception/transmission of
                                                     the first following word (sized WS)                                       */
      __IOM uint32_t CD_EN_CS3  : 1;            /*!< [12..12] Command / Data enable ; relevant in LCD                          */
      __IOM uint32_t NOP_CS3    : 1;            /*!< [13..13] Nop_command is relevant                                          */
      __IOM uint32_t ENABLE_PERIODS_CS3 : 1;    /*!< [14..14] If cs_keep_low is on then the hold period recovery
                                                     period and setup period could be unnecessary; since they
                                                     all refer to cs rise and fall; value &#8220;1&#8221; then
                                                     the time periods will occur normally ; value &#8220;0&#8221;
                                                     time periods will be skipped                                              */
      __IOM uint32_t THREE_WIRE_EN_CS3 : 1;     /*!< [15..15] enable 3 wire mode - cannot be on if full duplex is
                                                     set                                                                       */
      __IOM uint32_t COUNT_DIVIDE_CS3 : 16;     /*!< [31..16] counter limit for sck cycle; equals to the divide value
                                                     of the freq                                                               */
    } CS3_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER1_CS1_CFG;            /*!< (@ 0x00000020) COUNTER1_CS1_CFG                                           */
    
    struct {
      __IOM uint32_t HOLD_PERIIOD_CS1 : 16;     /*!< [15..0] counter limit from sck end to cs up transition                    */
      __IOM uint32_t RECOVERY_PERIOD_CS1 : 16;  /*!< [31..16] counter limit from cs up transition to next cs down
                                                     transition                                                                */
    } COUNTER1_CS1_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER1_CS2_CFG;            /*!< (@ 0x00000024) COUNTER1_CS2_CFG                                           */
    
    struct {
      __IOM uint32_t HOLD_PERIIOD_CS2 : 16;     /*!< [15..0] counter limit from sck end to cs up transition                    */
      __IOM uint32_t RECOVERY_PERIOD_CS2 : 16;  /*!< [31..16] counter limit from cs up transition to next cs down
                                                     transition                                                                */
    } COUNTER1_CS2_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER1_CS3_CFG;            /*!< (@ 0x00000028) COUNTER1_CS3_CFG                                           */
    
    struct {
      __IOM uint32_t HOLD_PERIIOD_CS3 : 16;     /*!< [15..0] counter limit from sck end to cs up transition                    */
      __IOM uint32_t RECOVERY_PERIOD_CS3 : 16;  /*!< [31..16] counter limit from cs up transition to next cs down
                                                     transition                                                                */
    } COUNTER1_CS3_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER2_CS1_CFG;            /*!< (@ 0x0000002C) COUNTER2_CS1_CFG                                           */
    
    struct {
      __IOM uint32_t SETUP_PERIOD_CS1 : 16;     /*!< [15..0] counter limit from cs down transition to sck start                */
      __IOM uint32_t CD_SETUP_CS1 : 7;          /*!< [22..16] comand data signal setup period from driving edge.
                                                     The complementary value to half spi_sck_out cycle will
                                                     be representing the hold period from sampling clock                       */
            uint32_t            : 9;
    } COUNTER2_CS1_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER2_CS2_CFG;            /*!< (@ 0x00000030) COUNTER2_CS2_CFG                                           */
    
    struct {
      __IOM uint32_t SETUP_PERIOD_CS2 : 16;     /*!< [15..0] counter limit from cs down transition to sck start                */
      __IOM uint32_t CD_SETUP_CS2 : 7;          /*!< [22..16] comand data signal setup period from driving edge.
                                                     The complementary value to half spi_sck_out cycle will
                                                     be representing the hold period from sampling clock                       */
            uint32_t            : 9;
    } COUNTER2_CS2_CFG_b;
  } ;
  
  union {
    __IOM uint32_t COUNTER2_CS3_CFG;            /*!< (@ 0x00000034) COUNTER2_CS3_CFG                                           */
    
    struct {
      __IOM uint32_t SETUP_PERIOD_CS3 : 16;     /*!< [15..0] counter limit from cs down transition to sck start                */
      __IOM uint32_t CD_SETUP_CS3 : 7;          /*!< [22..16] comand data signal setup period from driving edge.
                                                     The complementary value to half spi_sck_out cycle will
                                                     be representing the hold period from sampling clock                       */
            uint32_t            : 9;
    } COUNTER2_CS3_CFG_b;
  } ;
  
  union {
    __IOM uint32_t FLUSH_CFG;                   /*!< (@ 0x00000038) FLUSH_CFG                                                  */
    
    struct {
      __OM  uint32_t FLUSH_RDATA : 1;           /*!< [0..0] When set to '1' it will reset the RData FIFO ; by initializing
                                                     Rd Wr pointers and clear status.                                          */
      __OM  uint32_t FLUSH_WDATA : 1;           /*!< [1..1] When set to '1' it will reset the WData FIFO ; by initializing
                                                     Rd Wr pointers and clear status.                                          */
            uint32_t            : 14;
      __OM  uint32_t FLUSH_CMD  : 1;            /*!< [16..16] When set to '1' it will reset the command FIFO ; by
                                                     initializing Rd Wr pointers and clear status.                             */
            uint32_t            : 15;
    } FLUSH_CFG_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_CFG1;              /*!< (@ 0x0000003C) INTERRUPT_CFG1                                             */
    
    struct {
      __IOM uint32_t RDATA_S_INT : 8;           /*!< [7..0] ready Rdata FIFO status threshold; when the FIFO has
                                                     at least this number of full words in it can trigger an
                                                     interrupt to SW                                                           */
      __IOM uint32_t WDATA_S_INT : 8;           /*!< [15..8] ready Wdata FIFO status thresholds; when the FIFO has
                                                     at least this number of free words it can trigger an interrupt
                                                     to SW                                                                     */
      __IOM uint32_t CMD_S_INT  : 4;            /*!< [19..16] Cmd FIFO status threshold; when the FIFO has at least
                                                     this number of free commands it can trigger an interrupt
                                                     to SW                                                                     */
            uint32_t            : 1;
      __IOM uint32_t HW_FLOW_CTL : 1;           /*!< [21..21] 1 - Prevents underflow and overflow err by stopping
                                                     the clock when necessary 0 - continue in these cases without
                                                     stopping the clock                                                        */
            uint32_t            : 10;
    } INTERRUPT_CFG1_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_CFG2;              /*!< (@ 0x00000040) INTERRUPT_CFG2                                             */
    
    struct {
      __IOM uint32_t M_DONE     : 1;            /*!< [0..0] Mask interrupt (1-masked; 0-not masked) : done                     */
      __IOM uint32_t M_RDATA    : 1;            /*!< [1..1] Mask interrupt (1-masked; 0-not masked) : Rdata status             */
      __IOM uint32_t M_WDATA    : 1;            /*!< [2..2] Mask interrupt (1-masked; 0-not masked) : Wdata status             */
      __IOM uint32_t M_CMD      : 1;            /*!< [3..3] Mask interrupt (1-masked; 0-not masked) : cmd status               */
            uint32_t            : 12;
      __IOM uint32_t M_DIR_ERR  : 1;            /*!< [16..16] Mask direction err interrupt (1-masked; 0-not masked)            */
      __IOM uint32_t M_OVERFLOW_CTL : 1;        /*!< [17..17] Mask Error interrupt (1-masked; 0-not masked) : which
                                                     occur when trying to write overflow. From the bus fabric
                                                     side                                                                      */
      __IOM uint32_t M_OVERFLOW_WDATA : 1;      /*!< [18..18] Mask Error interrupt (1-masked; 0-not masked) : which
                                                     occur when trying to write overflow. From the bus fabric
                                                     side                                                                      */
      __IOM uint32_t M_UNDERFLOW_RDATA : 1;     /*!< [19..19] Mask Error interrupt (1-masked; 0-not masked) : which
                                                     occur when trying to read underflow. From the bus fabric
                                                     side                                                                      */
      __IOM uint32_t M_OVERFLOW_RDATA : 1;      /*!< [20..20] Mask Error interrupt (1-masked; 0-not masked) : which
                                                     occur when trying to write overflow. From the main controller
                                                     side                                                                      */
      __IOM uint32_t M_UNDERFLOW_WDATA : 1;     /*!< [21..21] Mask Error interrupt (1-masked; 0-not masked) : which
                                                     occur when trying to read underflow. From the main controller
                                                     side                                                                      */
      __IOM uint32_t M_ERR_SW_READ_WDATA : 1;   /*!< [22..22] Mask Error interrupt (1-masked; 0-not masked) : sw
                                                     read access from a wdata fifo ; in Hw flow ctrl this is
                                                     a dead lock                                                               */
      __IOM uint32_t M_ERR_SW_WRITE_RDATA : 1;  /*!< [23..23] Mask Error interrupt (1-masked; 0-not masked) : sw
                                                     write access to a read data fifo; in Hw flow ctrl this
                                                     is a dead lock                                                            */
      __IOM uint32_t M_ERR_CMD_OVER_RDATA_FULL : 1;/*!< [24..24] Mask Error interrupt (1-masked; 0-not masked) : cmd
                                                     loaded to overflow and rdata fifo is full; in Hw flow ctrl
                                                     this is a dead lock                                                       */
      __IOM uint32_t M_ERR_CMD_OVER_WDATA_EMPTY : 1;/*!< [25..25] Mask Error interrupt (1-masked; 0-not masked) : cmd
                                                     loaded to overflow and wdata fifo is empty; in Hw flow
                                                     ctrl this is a dead lock                                                  */
      __IOM uint32_t M_ERR_RDATA_UNDR_CMD_EMPTY : 1;/*!< [26..26] Mask Error interrupt (1-masked; 0-not masked) : when
                                                     reading to underflow data from rdata FIFO with no cmd to
                                                     fill the FIFO; in Hw flow ctrl this is a dead lock                        */
      __IOM uint32_t M_ERR_WDATA_OVER_CMD_EMPTY : 1;/*!< [27..27] Mask Error interrupt (1-masked; 0-not masked) : wdata
                                                     FIFO loaded to overflow with no cmd to release the FIFO
                                                     ; in Hw flow ctrl this is a dead lock                                     */
            uint32_t            : 4;
    } INTERRUPT_CFG2_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_STATUS;            /*!< (@ 0x00000044) Read only status of interrupts                             */
    
    struct {
      __IM  uint32_t DONE_C_INT : 1;            /*!< [0..0] Interrupt cause Cmd done                                           */
      __IM  uint32_t RDATA_STATUS_C_INT : 1;    /*!< [1..1] Interrupt cause when free space is bigger than WDATA_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t WDATA_STATUS_C_INT : 1;    /*!< [2..2] Interrupt cause when free space is bigger than CMD_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t CMD_STATUS_C_INT : 1;      /*!< [3..3] Interrupt cause Cmd status is less than CMD_S_INT threshold        */
            uint32_t            : 12;
      __IM  uint32_t DIR_ERR_C_INT : 1;         /*!< [16..16] Interrupt cause Rdata status is bigger than RDATA_S_INT
                                                     threshold                                                                 */
      __IM  uint32_t CMD_OVER_C_INT : 1;        /*!< [17..17] Error interrupt which occur when trying to write overflow.
                                                     From the bus fabric side                                                  */
      __IM  uint32_t WDATA_OVER_C_INT : 1;      /*!< [18..18] Error interrupt which occur when trying to write overflow.
                                                     From the bus fabric side                                                  */
      __IM  uint32_t RDATA_UNDER_C_INT : 1;     /*!< [19..19] Error interrupt which occur when trying to read underflow.
                                                     From the bus fabric side                                                  */
      __IM  uint32_t WDATA_UNDER_C_INT : 1;     /*!< [20..20] Error interrupt which occur when trying to read underflow.
                                                     From the main controller side                                             */
      __IM  uint32_t RDATA_OVER_C_INT : 1;      /*!< [21..21] Error interrupt which occur when trying to write overflow.
                                                     From the main controller side                                             */
      __IM  uint32_t ERR_SW_READ_WDATA : 1;     /*!< [22..22] Error interrupt sw read access from a wdata fifo ;
                                                     in Hw flow ctrl this is a dead lock                                       */
      __IM  uint32_t ERR_SW_WRITE_RDATA : 1;    /*!< [23..23] Error interrupt sw write access to a read data fifo;
                                                     in Hw flow ctrl this is a dead lock                                       */
      __IM  uint32_t ERR_CMD_OVER_RDATA_FULL : 1;/*!< [24..24] Error interrupt cmd loaded to overflow and rdata fifo
                                                     is full; in Hw flow ctrl this is a dead lock                              */
      __IM  uint32_t ERR_CMD_OVER_WDATA_EMPTY : 1;/*!< [25..25] Error interrupt cmd loaded to overflow and wdata fifo
                                                     is empty; in Hw flow ctrl this is a dead lock                             */
      __IM  uint32_t ERR_RDATA_UNDR_CMD_EMPTY : 1;/*!< [26..26] Error interrupt when reading to underflow data from
                                                     rdata FIFO with no cmd to fill the FIFO; in Hw flow ctrl
                                                     this is a dead lock                                                       */
      __IM  uint32_t ERR_WDATA_OVER_CMD_EMPTY : 1;/*!< [27..27] Error interrupt wdata FIFO loaded to overflow with
                                                     no cmd to release the FIFO ; in Hw flow ctrl this is a
                                                     dead lock                                                                 */
            uint32_t            : 4;
    } INTERRUPT_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_STATUS_RC;         /*!< (@ 0x00000048) Read and clear the interrupts                              */
    
    struct {
      __IOM uint32_t DONE_C_INT : 1;            /*!< [0..0] Interrupt cause Cmd done                                           */
      __IOM uint32_t RDATA_STATUS_C_INT : 1;    /*!< [1..1] Interrupt cause when free space is bigger than WDATA_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t WDATA_STATUS_C_INT : 1;    /*!< [2..2] Interrupt cause when free space is bigger than CMD_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t CMD_STATUS_C_INT : 1;      /*!< [3..3] Interrupt cause Cmd status is less than CMD_S_INT threshold        */
            uint32_t            : 12;
      __IOM uint32_t DIR_ERR_C_INT : 1;         /*!< [16..16] Interrupt cause Rdata status is bigger than RDATA_S_INT
                                                     threshold                                                                 */
      __IOM uint32_t CMD_OVER_C_INT : 1;        /*!< [17..17] Error interrupt which occur when trying to write overflow.
                                                     From the bus fabric side                                                  */
      __IOM uint32_t WDATA_OVER_C_INT : 1;      /*!< [18..18] Error interrupt which occur when trying to write overflow.
                                                     From the bus fabric side                                                  */
      __IOM uint32_t RDATA_UNDER_C_INT : 1;     /*!< [19..19] Error interrupt which occur when trying to read underflow.
                                                     From the bus fabric side                                                  */
      __IOM uint32_t WDATA_UNDER_C_INT : 1;     /*!< [20..20] Error interrupt which occur when trying to read underflow.
                                                     From the main controller side                                             */
      __IOM uint32_t RDATA_OVER_C_INT : 1;      /*!< [21..21] Error interrupt which occur when trying to write overflow.
                                                     From the main controller side                                             */
      __IOM uint32_t ERR_SW_READ_WDATA : 1;     /*!< [22..22] Error interrupt sw read access from a wdata fifo ;
                                                     in Hw flow ctrl this is a dead lock                                       */
      __IOM uint32_t ERR_SW_WRITE_RDATA : 1;    /*!< [23..23] Error interrupt sw write access to a read data fifo;
                                                     in Hw flow ctrl this is a dead lock                                       */
      __IOM uint32_t ERR_CMD_OVER_RDATA_FULL : 1;/*!< [24..24] Error interrupt cmd loaded to overflow and rdata fifo
                                                     is full; in Hw flow ctrl this is a dead lock                              */
      __IOM uint32_t ERR_CMD_OVER_WDATA_EMPTY : 1;/*!< [25..25] Error interrupt cmd loaded to overflow and wdata fifo
                                                     is empty; in Hw flow ctrl this is a dead lock                             */
      __IOM uint32_t ERR_RDATA_UNDR_CMD_EMPTY : 1;/*!< [26..26] Error interrupt when reading to underflow data from
                                                     rdata FIFO with no cmd to fill the FIFO; in Hw flow ctrl
                                                     this is a dead lock                                                       */
      __IOM uint32_t ERR_WDATA_OVER_CMD_EMPTY : 1;/*!< [27..27] Error interrupt wdata FIFO loaded to overflow with
                                                     no cmd to release the FIFO ; in Hw flow ctrl this is a
                                                     dead lock                                                                 */
            uint32_t            : 4;
    } INTERRUPT_STATUS_RC_b;
  } ;
  
  union {
    __IOM uint32_t CURRENT_STATE;               /*!< (@ 0x0000004C) CURRENT_STATE                                              */
    
    struct {
      __IM  uint32_t WRITE_STATE : 3;           /*!< [2..0] Write and SCK state machine current state:0x0: IDLE0x1:
                                                     SETUP_DELAY0x2: SHIFT_REG_DELAY_AND_SCK0x3: PUSH_BIT0x4:
                                                     HOLD_WAIT0x5: RECOVERY_WAIT                                               */
            uint32_t            : 2;
      __IM  uint32_t MAIN_CTL_STATE : 3;        /*!< [7..5] Main controller state machine current state :0x0: IDLE0x1:
                                                     PARSER0x2: ERROR0x3: RW_MODE_SET0x4: ADDRESS0x5: ACTIVE_LINE_DRIVER       */
      __IM  uint32_t PHASE_COUNT : 7;           /*!< [14..8] Number of bits sent or received                                   */
            uint32_t            : 1;
      __IM  uint32_t LEN        : 16;           /*!< [31..16] Number of words left in the current transaction; each
                                                     word is of word size                                                      */
    } CURRENT_STATE_b;
  } ;
  
  union {
    __IOM uint32_t READY_CFG;                   /*!< (@ 0x00000050) READY_CFG                                                  */
    
    struct {
      __IOM uint32_t RDATA_TRS_READY : 8;       /*!< [7..0] ready Rdata FIFO status threshold; when the FIFO has
                                                     at least this number of full words in it can trigger the
                                                     DMA                                                                       */
      __IOM uint32_t WDATA_TRS_READY : 8;       /*!< [15..8] ready Wdata FIFO status thresholds; when the FIFO has
                                                     at least this number of free words it can trigger the DMA                 */
            uint32_t            : 16;
    } READY_CFG_b;
  } ;
  
  union {
    __IOM uint32_t SPI_ENABLE;                  /*!< (@ 0x00000054) SPI_ENABLE                                                 */
    
    struct {
      __IOM uint32_t SPI_EN     : 1;            /*!< [0..0] 1: Enable SPI returning clock (the SCK is created by
                                                     the controller and also loops back into it through the
                                                     IO to sample the returning rdata)0: set a constant value
                                                     0 on the SPI returning clock                                              */
            uint32_t            : 31;
    } SPI_ENABLE_b;
  } ;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t RDATA_FIFO;                  /*!< (@ 0x00000064) RDATA_FIFO                                                 */
    
    struct {
      __IM  uint32_t RDATA      : 32;           /*!< [31..0] RData FIFO - read from fifoThe FIFO is a 32 bit wide
                                                     FIFO with a depth of 128 words; when in infinite mode the
                                                     word size is byte the 32 bit will contain up to 4 bytes.
                                                     When not in infinite mode each word size regardless of
                                                     the size will be held in one word row.The data FIFO is
                                                     both for reading and writing data                                         */
    } RDATA_FIFO_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t RDATA_FIFO_STATUS;           /*!< (@ 0x0000006C) RDATA_FIFO_STATUS                                          */
    
    struct {
      __IM  uint32_t RDATA_WP   : 8;            /*!< [7..0] Points to the current address to write to.                         */
      __IM  uint32_t RDATA_RP   : 8;            /*!< [15..8] Points to the current address to read from.                       */
      __IM  uint32_t RDATA_STATUS : 8;          /*!< [23..16] Counter incremented with each write and decreased with
                                                     each read from the WDATA FIFO                                             */
      __IM  uint32_t READ_EN    : 1;            /*!< [24..24] State of the Data FIFO : 1 = read ; 0 = write                    */
            uint32_t            : 6;
      __IM  uint32_t FULL_DUPLEX : 1;           /*!< [31..31] Value is relevant only if READ_EN =1 - then READ and
                                                     write both active                                                         */
    } RDATA_FIFO_STATUS_b;
  } ;
} SPI_MASTER_Type;                              /*!< Size = 112 (0x70)                                                         */



/* =========================================================================================================================== */
/* ================                                          GPIO_0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO controller #0 (GPIO_0)
  */

typedef struct {                                /*!< (@ 0x01600000) GPIO_0 Structure                                           */
  __IM  uint32_t  RESERVED[255];
  
  union {
    __IOM uint32_t DATA;                        /*!< (@ 0x000003FC) DATA                                                       */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Each bit in this register may be used to set value of
                                                     corresponding bit in GPIO octec when IO mode is output;
                                                     and read IO value when IO mode is inputWriting this field
                                                     is possible using corresponding high mask bits on addr[9:2].
                                                     Other bits remain unchanged.For example - to set bit #2
                                                     in the octec user should write required value to address
                                                     offset such as addr[4] asserted high and bit #2 in the
                                                     data register holds IO output value. Note that any numbet
                                                     of bits can be modified in the same register acces                        */
            uint32_t            : 24;
    } DATA_b;
  } ;
  
  union {
    __IOM uint32_t DIR_SET;                     /*!< (@ 0x00000400) DIR_SET                                                    */
    
    struct {
      __OM  uint32_t DIR_SET    : 8;            /*!< [7..0] ALIAS for GPIO_DIR. Write value uses as bit mask set
                                                     to GPIO direction register.                                               */
            uint32_t            : 24;
    } DIR_SET_b;
  } ;
  
  union {
    __IOM uint32_t DIR_CLR;                     /*!< (@ 0x00000404) DIR_CLR                                                    */
    
    struct {
      __OM  uint32_t DIR_CLR    : 8;            /*!< [7..0] ALIAS for GPIO_DIR. Write value uses as bit mask clear
                                                     to GPIO direction register.                                               */
            uint32_t            : 24;
    } DIR_CLR_b;
  } ;
  
  union {
    __IOM uint32_t DIR;                         /*!< (@ 0x00000408) DIR                                                        */
    
    struct {
      __IOM uint32_t DIR        : 8;            /*!< [7..0] GPIO direction. For each pin in GPIO octec the corresponding
                                                     bit in this register defines the I/O direction:0 - input.
                                                     1 - output.                                                               */
            uint32_t            : 24;
    } DIR_b;
  } ;
  
  union {
    __IOM uint32_t INT_SENSE_SET;               /*!< (@ 0x0000040C) INT_SENSE_SET                                              */
    
    struct {
      __OM  uint32_t INT_SENSE_SET : 8;         /*!< [7..0] ALIAS for GPIO_INT_SENSE. Write value uses as bit mask
                                                     set to GPIO interrupt sense register.                                     */
            uint32_t            : 24;
    } INT_SENSE_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_SENSE_CLR;               /*!< (@ 0x00000410) INT_SENSE_CLR                                              */
    
    struct {
      __OM  uint32_t INT_SENSE_CLR : 8;         /*!< [7..0] ALIAS for GPIO_INT_SENSE. Write value uses as bit mask
                                                     clear to GPIO interrupt sense register.                                   */
            uint32_t            : 24;
    } INT_SENSE_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_SENSE;                   /*!< (@ 0x00000414) INT_SENSE                                                  */
    
    struct {
      __IOM uint32_t INT_SENSE  : 8;            /*!< [7..0] GPIO interrupt sense register. 0 - detect edge. 1 - detect
                                                     level.                                                                    */
            uint32_t            : 24;
    } INT_SENSE_b;
  } ;
  
  union {
    __IOM uint32_t INT_BOTH_EDGES_SET;          /*!< (@ 0x00000418) INT_BOTH_EDGES_SET                                         */
    
    struct {
      __OM  uint32_t INT_BOTH_EDGES_SET : 8;    /*!< [7..0] ALIAS for GPIO_INT_BOTH_EDGES. Write value uses as bit
                                                     mask set to GPIO interrupt both-edges register.                           */
            uint32_t            : 24;
    } INT_BOTH_EDGES_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_BOTH_EDGES_CLR;          /*!< (@ 0x0000041C) INT_BOTH_EDGES_CLR                                         */
    
    struct {
      __OM  uint32_t INT_BOTH_EDGES_CLR : 8;    /*!< [7..0] ALIAS for GPIO_INT_BOTH_EDGES. Write value uses as bit
                                                     mask clear to GPIO interrupt both-edges register.                         */
            uint32_t            : 24;
    } INT_BOTH_EDGES_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_BOTH_EDGES;              /*!< (@ 0x00000420) INT_BOTH_EDGES                                             */
    
    struct {
      __IOM uint32_t INT_BOTH_EDGES : 8;        /*!< [7..0] GPIO interrupt both-edges. Relevant if in 'detect edge'
                                                     mode. 0 - detect single edge. 1 - detect both edges.                      */
            uint32_t            : 24;
    } INT_BOTH_EDGES_b;
  } ;
  
  union {
    __IOM uint32_t INT_EVENT_SET;               /*!< (@ 0x00000424) INT_EVENT_SET                                              */
    
    struct {
      __OM  uint32_t INT_EVENT_SET : 8;         /*!< [7..0] ALIAS for GPIO_INT_EVENT. Write value uses as bit mask
                                                     set to GPIO interrupt event register.                                     */
            uint32_t            : 24;
    } INT_EVENT_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_EVENT_CLR;               /*!< (@ 0x00000428) INT_EVENT_CLR                                              */
    
    struct {
      __OM  uint32_t INT_EVENT_CLR : 8;         /*!< [7..0] ALIAS for GPIO_INT_EVENT. Write value uses as bit mask
                                                     clear to GPIO interrupt event register.                                   */
            uint32_t            : 24;
    } INT_EVENT_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_EVENT;                   /*!< (@ 0x0000042C) INT_EVENT                                                  */
    
    struct {
      __IOM uint32_t INT_EVENT  : 8;            /*!< [7..0] GPIO interrupt event. 0 - detect low level/negedge. 1
                                                     - detect high level/posedge.                                              */
            uint32_t            : 24;
    } INT_EVENT_b;
  } ;
  
  union {
    __IOM uint32_t INT_MASK_SET;                /*!< (@ 0x00000430) INT_MASK_SET                                               */
    
    struct {
      __OM  uint32_t INT_MASK_SET : 8;          /*!< [7..0] ALIAS for GPIO_INT_MASK. Write value uses as bit mask
                                                     set to GPIO interrupt mask register.                                      */
            uint32_t            : 24;
    } INT_MASK_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_MASK_CLR;                /*!< (@ 0x00000434) INT_MASK_CLR                                               */
    
    struct {
      __OM  uint32_t INT_MASK_CLR : 8;          /*!< [7..0] ALIAS for GPIO_INT_MASK. Write value uses as bit mask
                                                     clear to GPIO interrupt mask register.                                    */
            uint32_t            : 24;
    } INT_MASK_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_MASK;                    /*!< (@ 0x00000438) INT_MASK                                                   */
    
    struct {
      __IOM uint32_t INT_MASK   : 8;            /*!< [7..0] GPIO interrupt mask. 0 - disable interrupt. 1 - enable
                                                     interrupt.                                                                */
            uint32_t            : 24;
    } INT_MASK_b;
  } ;
  
  union {
    __IOM uint32_t INT_STATUS;                  /*!< (@ 0x0000043C) INT_STATUS                                                 */
    
    struct {
      __IM  uint32_t INT_STATUS : 8;            /*!< [7..0] GPIO raw interrupt status register.                                */
            uint32_t            : 24;
    } INT_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t INT_MASKED_STATUS;           /*!< (@ 0x00000440) INT_MASKED_STATUS                                          */
    
    struct {
      __IM  uint32_t INT_MASKED_STATUS : 8;     /*!< [7..0] GPIO masked interrupt status register.                             */
            uint32_t            : 24;
    } INT_MASKED_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t INT_CLR;                     /*!< (@ 0x00000444) INT_CLR                                                    */
    
    struct {
      __OM  uint32_t INT_CLR    : 8;            /*!< [7..0] GPIO clear interrupt register. 0 - no effect. 1 - clear
                                                     corresponding interrupt.                                                  */
            uint32_t            : 24;
    } INT_CLR_b;
  } ;
  
  union {
    __IOM uint32_t DISABLE;                     /*!< (@ 0x00000448) DISABLE                                                    */
    
    struct {
      __IOM uint32_t DISABLE    : 1;            /*!< [0..0] GPIO octet disable register. 1 - gpio octet disabled.
                                                     0 &#8211; gpio octet enabled.                                             */
            uint32_t            : 31;
    } DISABLE_b;
  } ;
  
  union {
    __IOM uint32_t DATA_FOR_OUTPUT;             /*!< (@ 0x0000044C) DATA_FOR_OUTPUT                                            */
    
    struct {
      __IM  uint32_t DATA_FOR_OUTPUT : 8;       /*!< [7..0] GPIO data for output. Reflects the data driven by the
                                                     GPIO controller towards the IOs. debug register - read
                                                     only                                                                      */
            uint32_t            : 24;
    } DATA_FOR_OUTPUT_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE0_SET;          /*!< (@ 0x00000450) INT_TICK_TYPE0_SET                                         */
    
    struct {
      __OM  uint32_t INT_TICK_TYPE0_SET : 8;    /*!< [7..0] ALIAS for GPIO_INT_TICK_TYPE0. Write value uses as bit
                                                     mask set to GPIO interrupt tick0 register.                                */
            uint32_t            : 24;
    } INT_TICK_TYPE0_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE0_CLR;          /*!< (@ 0x00000454) INT_TICK_TYPE0_CLR                                         */
    
    struct {
      __OM  uint32_t INT_TICK_TYPE0_CLR : 8;    /*!< [7..0] ALIAS for GPIO_INT_TICK_TYPE0. Write value uses as bit
                                                     mask clear to GPIO interrupt tick0 register.                              */
            uint32_t            : 24;
    } INT_TICK_TYPE0_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE0;              /*!< (@ 0x00000458) INT_TICK_TYPE0                                             */
    
    struct {
      __IOM uint32_t INT_TICK_TYPE0 : 8;        /*!< [7..0] GPIO sampling event for each gpio input:2'b00: sample
                                                     on MCU's system clock2'b01: not used2'b10: not used 2'b11:
                                                     sample on roll over of the MCU NCO. Can be used for debouncingbits
                                                     [1:0] - gpio 0 inputbits [3:2] - gpio 1 inputbits [5:4]
                                                     - gpio 2 inputbits [7:6] - gpio 3 input                                   */
            uint32_t            : 24;
    } INT_TICK_TYPE0_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE1_SET;          /*!< (@ 0x0000045C) INT_TICK_TYPE1_SET                                         */
    
    struct {
      __OM  uint32_t INT_TICK_TYPE1_SET : 8;    /*!< [7..0] ALIAS for GPIO_INT_TICK_TYPE1. Write value uses as bit
                                                     mask set to GPIO interrupt tick1 register.                                */
            uint32_t            : 24;
    } INT_TICK_TYPE1_SET_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE1_CLR;          /*!< (@ 0x00000460) INT_TICK_TYPE1_CLR                                         */
    
    struct {
      __OM  uint32_t INT_TICK_TYPE1_CLR : 8;    /*!< [7..0] ALIAS for GPIO_INT_TICK_TYPE1. Write value uses as bit
                                                     mask clear to GPIO interrupt tick1 register.                              */
            uint32_t            : 24;
    } INT_TICK_TYPE1_CLR_b;
  } ;
  
  union {
    __IOM uint32_t INT_TICK_TYPE1;              /*!< (@ 0x00000464) INT_TICK_TYPE1                                             */
    
    struct {
      __IOM uint32_t INT_TICK_TYPE1 : 8;        /*!< [7..0] GPIO sampling event for each gpio input:2'b00: sample
                                                     on MCU's system clock2'b01: not used2'b10: not used 2'b11:
                                                     sample on roll over of the MCU NCO. Can be used for debouncingbits
                                                     [1:0] - gpio 4 inputbits [3:2] - gpio 5 inputbits [5:4]
                                                     - gpio 6 inputbits [7:6] - gpio 7 input                                   */
            uint32_t            : 24;
    } INT_TICK_TYPE1_b;
  } ;
} GPIO_Type;                                    /*!< Size = 1128 (0x468)                                                       */



/* =========================================================================================================================== */
/* ================                                      GP_TIMER_INTR_0                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timer interrupt #0 (GP_TIMER_INTR_0)
  */

typedef struct {                                /*!< (@ 0x01590000) GP_TIMER_INTR_0 Structure                                  */
  
  union {
    __IOM uint32_t EN;                          /*!< (@ 0x00000000) EN                                                         */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] 0: disable timer interrupt ; 1: enable timer interrupt             */
            uint32_t            : 31;
    } EN_b;
  } ;
  
  union {
    __IOM uint32_t SET_VALUE;                   /*!< (@ 0x00000004) SET_VALUE                                                  */
    
    struct {
      __IOM uint32_t SET_VALUE  : 32;           /*!< [31..0] Absolute target value for timer interrupt                         */
    } SET_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t SET_OFFSET;                  /*!< (@ 0x00000008) SET_OFFSET                                                 */
    
    struct {
      __IOM uint32_t SET_OFFSET : 16;           /*!< [15..0] Write to this register sets target timer value to current
                                                     value + offset; for interrupt                                             */
            uint32_t            : 16;
    } SET_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t TARGET;                      /*!< (@ 0x0000000C) TARGET                                                     */
    
    struct {
      __IM  uint32_t TARGET     : 32;           /*!< [31..0] read the actual calculated target setting                         */
    } TARGET_b;
  } ;
  
  union {
    __IOM uint32_t VALUE;                       /*!< (@ 0x00000010) VALUE                                                      */
    
    struct {
      __IM  uint32_t VALUE      : 32;           /*!< [31..0] read the current timer value                                      */
    } VALUE_b;
  } ;
} GP_TIMER_INTR_Type;                           /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                   SHADOW_32K_TIMER_INTR                                   ================ */
/* =========================================================================================================================== */


/**
  * @brief 32KHz timer interrupt (SHADOW_32K_TIMER_INTR)
  */

typedef struct {                                /*!< (@ 0x015E0000) SHADOW_32K_TIMER_INTR Structure                            */
  
  union {
    __IOM uint32_t EN;                          /*!< (@ 0x00000000) EN                                                         */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] 0: disable timer interrupt ; 1: enable timer interrupt             */
            uint32_t            : 31;
    } EN_b;
  } ;
  
  union {
    __IOM uint32_t SET_VALUE;                   /*!< (@ 0x00000004) SET_VALUE                                                  */
    
    struct {
      __IOM uint32_t SET_VALUE  : 32;           /*!< [31..0] Absolute target value for timer interrupt                         */
    } SET_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t SET_OFFSET;                  /*!< (@ 0x00000008) SET_OFFSET                                                 */
    
    struct {
      __IOM uint32_t SET_OFFSET : 16;           /*!< [15..0] Write to this register sets target timer value to current
                                                     value + offset; for interrupt                                             */
            uint32_t            : 16;
    } SET_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t TARGET;                      /*!< (@ 0x0000000C) TARGET                                                     */
    
    struct {
      __IM  uint32_t TARGET     : 32;           /*!< [31..0] read the actual calculated target setting                         */
    } TARGET_b;
  } ;
  
  union {
    __IOM uint32_t VALUE;                       /*!< (@ 0x00000010) VALUE                                                      */
    
    struct {
      __IM  uint32_t VALUE      : 32;           /*!< [31..0] read the current timer value                                      */
    } VALUE_b;
  } ;
} SHADOW_32K_TIMER_INTR_Type;                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                   SHADOW_32K_TIMER_CTRL                                   ================ */
/* =========================================================================================================================== */


/**
  * @brief 32KHz timer (SHADOW_32K_TIMER_CTRL)
  */

typedef struct {                                /*!< (@ 0x015D0000) SHADOW_32K_TIMER_CTRL Structure                            */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CTRL                                                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] 0: timer disabled; 1: timer enabled                                */
            uint32_t            : 31;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t PRESET_VALUE;                /*!< (@ 0x00000004) PRESET_VALUE                                               */
    
    struct {
      __IOM uint32_t PRESET_VALUE : 32;         /*!< [31..0] Value to load to the shadow 32khz timer                           */
    } PRESET_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t UPDT_OFFSET;                 /*!< (@ 0x00000008) UPDT_OFFSET                                                */
    
    struct {
      __IOM uint32_t OFFSET_VALUE : 32;         /*!< [31..0] This value is added to the shadow 32khz timer                     */
    } UPDT_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t VALUE;                       /*!< (@ 0x0000000C) VALUE                                                      */
    
    struct {
      __IM  uint32_t VALUE      : 32;           /*!< [31..0] shadow 32khz timer current value for reading                      */
    } VALUE_b;
  } ;
  
  union {
    __IOM uint32_t INT;                         /*!< (@ 0x00000010) INT                                                        */
    
    struct {
      __IM  uint32_t INT        : 1;            /*!< [0..0] Holds interrupt status until the SW disable the interrupt
                                                     or write a new target value that doesn&#8217;t match 0:
                                                     interrupt inactive 1: Interrupt active                                    */
            uint32_t            : 31;
    } INT_b;
  } ;
} SHADOW_32K_TIMER_CTRL_Type;                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            WD                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief WatchDog (WD)
  */

typedef struct {                                /*!< (@ 0x01570000) WD Structure                                               */
  
  union {
    __IOM uint32_t CONFIG;                      /*!< (@ 0x00000000) CONFIG                                                     */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Watchdog enable/disable1 &#8211; enable0 &#8211; disableWhen
                                                     disabled neither interrupt nor reset are generated and
                                                     counter is stable.                                                        */
            uint32_t            : 3;
      __IOM uint32_t INT_MASK   : 1;            /*!< [4..4] Interrupt mask bit1 &#8211; interrupt is enabled0 &#8211;
                                                     interrupt and reset are disabledWhen interrupt enabled
                                                     after was disabled (masked) counter is immediately loaded
                                                     with load_val value                                                       */
            uint32_t            : 3;
      __IOM uint32_t RST_EN     : 2;            /*!< [9..8] reset enable mask bitbit1 &#8211; level reset enablebit0
                                                     &#8211; pulse reset enableNote that when WD issues reset
                                                     to the chip reset control; reset cause register (RST_CAUSE)
                                                     latches this event and the system can read the reset source
                                                     after FW recovery                                                         */
            uint32_t            : 2;
      __IOM uint32_t LTE_MIPS_EJ_DEBUGM_0_EN : 1;/*!< [12..12] Enable the WD even though the processor is in EJTAG
                                                     mode; mask per processor1 - debug indication from this
                                                     processor is in use by the WD (WD will be disabled when
                                                     this processor is in debug mode)0 - debug indication from
                                                     this proceesor is ignored by the WD                                       */
            uint32_t            : 1;
      __IOM uint32_t NET_MIPS_EJ_DEBUGM_0_EN : 1;/*!< [14..14] Enable the WD even though the processor is in EJTAG
                                                     mode; mask per processor1 - debug indication from this
                                                     processor is in use by the WD (WD will be disabled when
                                                     this processor is in debug mode)0 - debug indication from
                                                     this proceesor is ignored by the WD                                       */
            uint32_t            : 3;
      __IOM uint32_t PHY_MIPS_EJ_DEBUGM_0_EN : 1;/*!< [18..18] Enable the WD even though the processor is in EJTAG
                                                     mode; mask per processor1 - debug indication from this
                                                     processor is in use by the WD (WD will be disabled when
                                                     this processor is in debug mode)0 - debug indication from
                                                     this proceesor is ignored by the WD                                       */
      __IOM uint32_t PMP_MIPS_EJ_DEBUGM_0_EN : 1;/*!< [19..19] Enable the WD even though the processor is in EJTAG
                                                     mode; mask per processor1 - debug indication from this
                                                     processor is in use by the WD (WD will be disabled when
                                                     this processor is in debug mode)0 - debug indication from
                                                     this proceesor is ignored by the WD                                       */
      __IOM uint32_t MCU_ARM_EJ_DEBUGM_0_EN : 1;/*!< [20..20] Enable the WD even though the processor is in EJTAG
                                                     mode; mask per processor1 - debug indication from this
                                                     processor is in use by the WD (WD will be disabled when
                                                     this processor is in debug mode)0 - debug indication from
                                                     this proceesor is ignored by the WD                                       */
            uint32_t            : 11;
    } CONFIG_b;
  } ;
  
  union {
    __IOM uint32_t CNT_LOAD;                    /*!< (@ 0x00000004) CNT_LOAD                                                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t LOAD_VAL   : 24;           /*!< [31..8] Counter's load value. Extra lower 8 bits will be set
                                                     to 0xff on every load. When this field changes; the counter
                                                     is immediately loaded to its value.This value defines numbe
                                                     of hclk cycles that the WD counter counts before it issues
                                                     interrupt to the system. After interrupt is asserted; the
                                                     counter is re-loaded to the field value. The WD module
                                                     expects that the interrupt will be cleared by the system
                                                     processor before the counter reaches zero againNote that
                                                     when WD issues reset to the chip reset control                            */
    } CNT_LOAD_b;
  } ;
  
  union {
    __IOM uint32_t CLEAR_INT;                   /*!< (@ 0x00000008) Reading this register creates a pulse that clears
                                                                    the interrupt. Note that after interrupt
                                                                    is asserted the WD counter starts counting
                                                                    again from the value that configured to
                                                                    WD_CNT_LOAD register. The interrupt must
                                                                    be cleared before the counter reaches zero
                                                                    again; otherwise reset is assereted to the
                                                                    chip reset control                                         */
    
    struct {
      __IOM uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status                                                   */
            uint32_t            : 3;
      __IM  uint32_t RST_LEVEL  : 1;            /*!< [4..4] Reset out level                                                    */
            uint32_t            : 27;
    } CLEAR_INT_b;
  } ;
  
  union {
    __IOM uint32_t STATUS;                      /*!< (@ 0x0000000C) STATUS                                                     */
    
    struct {
      __IM  uint32_t INT_STAT   : 1;            /*!< [0..0] Raw interrupt status                                               */
            uint32_t            : 3;
      __IM  uint32_t RST_LEVEL  : 1;            /*!< [4..4] Reset out level                                                    */
            uint32_t            : 27;
    } STATUS_b;
  } ;
  
  union {
    __IOM uint32_t CNT_VAL;                     /*!< (@ 0x00000010) CNT_VAL                                                    */
    
    struct {
      __IM  uint32_t COUNTER_VAL : 32;          /*!< [31..0] Counter's value (status)                                          */
    } CNT_VAL_b;
  } ;
  
  union {
    __IOM uint32_t PROTECT;                     /*!< (@ 0x00000014) PROTECT                                                    */
    
    struct {
      __IOM uint32_t PROTECT_WORD : 16;         /*!< [15..0] Register write protection word. Before writing the watchdog
                                                     registers; SW needs to perform two specific word writing
                                                     to this address. HW expects the first word to be 0xa5c6
                                                     and the second is 0xda7e. After this sequence one watchdog
                                                     register could be written.                                                */
            uint32_t            : 16;
    } PROTECT_b;
  } ;
} WD_Type;                                      /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                       IO_WKUP_CTRL                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Configuration of th 10 WAKEUP sources + 2 UART WAKEUP sources + KEYPAD WAKEUP source + indication of the IO latch state (IO_WKUP_CTRL)
  */

typedef struct {                                /*!< (@ 0x0C111E00) IO_WKUP_CTRL Structure                                     */
  
  union {
    __IOM uint32_t WAKEUP_0_CTRL0;              /*!< (@ 0x00000000) WAKEUP_0_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
      __IOM uint32_t DEBOUNCE_EN : 1;           /*!< [5..5] debounce enable for current wakeup                                 */
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_0_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_0_CTRL1;              /*!< (@ 0x00000004) WAKEUP_0_CTRL1                                             */
    
    struct {
      __IOM uint32_t DEBOUNCE_MAX_VAL : 10;     /*!< [9..0] number of 32k ckocks that signal should stay stey before
                                                     change                                                                    */
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_0_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_0_EN;                 /*!< (@ 0x00000008) WAKEUP_0_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_0_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_0_INT_EN;             /*!< (@ 0x0000000C) WAKEUP_0_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_0_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_0_INT;                /*!< (@ 0x00000010) WAKEUP_0_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_0_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_0_INT_RCLR;           /*!< (@ 0x00000014) WAKEUP_0_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_0_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t WAKEUP_1_CTRL0;              /*!< (@ 0x00000020) WAKEUP_1_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
      __IOM uint32_t DEBOUNCE_EN : 1;           /*!< [5..5] debounce enable for current wakeup                                 */
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_1_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_1_CTRL1;              /*!< (@ 0x00000024) WAKEUP_1_CTRL1                                             */
    
    struct {
      __IOM uint32_t DEBOUNCE_MAX_VAL : 10;     /*!< [9..0] number of 32k ckocks that signal should stay stey before
                                                     change                                                                    */
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_1_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_1_EN;                 /*!< (@ 0x00000028) WAKEUP_1_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_1_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_1_INT_EN;             /*!< (@ 0x0000002C) WAKEUP_1_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_1_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_1_INT;                /*!< (@ 0x00000030) WAKEUP_1_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_1_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_1_INT_RCLR;           /*!< (@ 0x00000034) WAKEUP_1_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_1_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t WAKEUP_2_CTRL0;              /*!< (@ 0x00000040) WAKEUP_2_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
      __IOM uint32_t DEBOUNCE_EN : 1;           /*!< [5..5] debounce enable for current wakeup                                 */
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_2_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_2_CTRL1;              /*!< (@ 0x00000044) WAKEUP_2_CTRL1                                             */
    
    struct {
      __IOM uint32_t DEBOUNCE_MAX_VAL : 10;     /*!< [9..0] number of 32k ckocks that signal should stay stey before
                                                     change                                                                    */
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_2_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_2_EN;                 /*!< (@ 0x00000048) WAKEUP_2_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_2_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_2_INT_EN;             /*!< (@ 0x0000004C) WAKEUP_2_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_2_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_2_INT;                /*!< (@ 0x00000050) WAKEUP_2_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_2_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_2_INT_RCLR;           /*!< (@ 0x00000054) WAKEUP_2_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_2_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t WAKEUP_3_CTRL0;              /*!< (@ 0x00000060) WAKEUP_3_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
      __IOM uint32_t DEBOUNCE_EN : 1;           /*!< [5..5] debounce enable for current wakeup                                 */
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_3_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_3_CTRL1;              /*!< (@ 0x00000064) WAKEUP_3_CTRL1                                             */
    
    struct {
      __IOM uint32_t DEBOUNCE_MAX_VAL : 10;     /*!< [9..0] number of 32k ckocks that signal should stay stey before
                                                     change                                                                    */
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_3_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_3_EN;                 /*!< (@ 0x00000068) WAKEUP_3_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_3_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_3_INT_EN;             /*!< (@ 0x0000006C) WAKEUP_3_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_3_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_3_INT;                /*!< (@ 0x00000070) WAKEUP_3_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_3_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_3_INT_RCLR;           /*!< (@ 0x00000074) WAKEUP_3_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_3_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED3[2];
  
  union {
    __IOM uint32_t WAKEUP_4_CTRL0;              /*!< (@ 0x00000080) WAKEUP_4_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
      __IOM uint32_t DEBOUNCE_EN : 1;           /*!< [5..5] debounce enable for current wakeup                                 */
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_4_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_4_CTRL1;              /*!< (@ 0x00000084) WAKEUP_4_CTRL1                                             */
    
    struct {
      __IOM uint32_t DEBOUNCE_MAX_VAL : 10;     /*!< [9..0] number of 32k ckocks that signal should stay stey before
                                                     change                                                                    */
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_4_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_4_EN;                 /*!< (@ 0x00000088) WAKEUP_4_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_4_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_4_INT_EN;             /*!< (@ 0x0000008C) WAKEUP_4_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_4_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_4_INT;                /*!< (@ 0x00000090) WAKEUP_4_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_4_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_4_INT_RCLR;           /*!< (@ 0x00000094) WAKEUP_4_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_4_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t WAKEUP_5_CTRL0;              /*!< (@ 0x000000A0) WAKEUP_5_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
            uint32_t            : 1;
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_5_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_5_CTRL1;              /*!< (@ 0x000000A4) WAKEUP_5_CTRL1                                             */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_5_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_5_EN;                 /*!< (@ 0x000000A8) WAKEUP_5_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_5_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_5_INT_EN;             /*!< (@ 0x000000AC) WAKEUP_5_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_5_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_5_INT;                /*!< (@ 0x000000B0) WAKEUP_5_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_5_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_5_INT_RCLR;           /*!< (@ 0x000000B4) WAKEUP_5_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_5_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t WAKEUP_6_CTRL0;              /*!< (@ 0x000000C0) WAKEUP_6_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
            uint32_t            : 1;
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_6_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_6_CTRL1;              /*!< (@ 0x000000C4) WAKEUP_6_CTRL1                                             */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_6_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_6_EN;                 /*!< (@ 0x000000C8) WAKEUP_6_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_6_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_6_INT_EN;             /*!< (@ 0x000000CC) WAKEUP_6_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_6_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_6_INT;                /*!< (@ 0x000000D0) WAKEUP_6_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_6_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_6_INT_RCLR;           /*!< (@ 0x000000D4) WAKEUP_6_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_6_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED6[2];
  
  union {
    __IOM uint32_t WAKEUP_7_CTRL0;              /*!< (@ 0x000000E0) WAKEUP_7_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
            uint32_t            : 1;
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_7_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_7_CTRL1;              /*!< (@ 0x000000E4) WAKEUP_7_CTRL1                                             */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_7_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_7_EN;                 /*!< (@ 0x000000E8) WAKEUP_7_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_7_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_7_INT_EN;             /*!< (@ 0x000000EC) WAKEUP_7_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_7_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_7_INT;                /*!< (@ 0x000000F0) WAKEUP_7_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_7_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_7_INT_RCLR;           /*!< (@ 0x000000F4) WAKEUP_7_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_7_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED7[2];
  
  union {
    __IOM uint32_t WAKEUP_8_CTRL0;              /*!< (@ 0x00000100) WAKEUP_8_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
            uint32_t            : 1;
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_8_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_8_CTRL1;              /*!< (@ 0x00000104) WAKEUP_8_CTRL1                                             */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_8_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_8_EN;                 /*!< (@ 0x00000108) WAKEUP_8_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_8_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_8_INT_EN;             /*!< (@ 0x0000010C) WAKEUP_8_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_8_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_8_INT;                /*!< (@ 0x00000110) WAKEUP_8_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_8_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_8_INT_RCLR;           /*!< (@ 0x00000114) WAKEUP_8_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_8_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IOM uint32_t WAKEUP_9_CTRL0;              /*!< (@ 0x00000120) WAKEUP_9_CTRL0                                             */
    
    struct {
      __IOM uint32_t EDGE_EN    : 1;            /*!< [0..0] enables edge functionality for current io wakeup machine           */
      __IOM uint32_t EDGE_KIND  : 2;            /*!< [2..1] 0= rise. 1= fall. 2= tgl.                                          */
      __IOM uint32_t ASYNC_WAKEUP : 1;          /*!< [3..3] 1= async wakeup. No need for 32k. 0 = sync wakeup. Need
                                                     clk.                                                                      */
      __IOM uint32_t POL_CHANGE : 1;            /*!< [4..4] polarity for level wakeup. 0= high. 1 = low.                       */
            uint32_t            : 1;
      __IOM uint32_t CLK_SELECT : 1;            /*!< [6..6] wakeup clock select: 0 - clk32 1 - urclk_div                       */
            uint32_t            : 25;
    } WAKEUP_9_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_9_CTRL1;              /*!< (@ 0x00000124) WAKEUP_9_CTRL1                                             */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t WAKEUP_IO_SEL : 6;         /*!< [15..10] select io for this wakeup logic                                  */
            uint32_t            : 16;
    } WAKEUP_9_CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_9_EN;                 /*!< (@ 0x00000128) WAKEUP_9_EN                                                */
    
    struct {
      __IOM uint32_t WAKEUP_EN  : 1;            /*!< [0..0] enable wakeup ability for current io wakeup machine                */
            uint32_t            : 31;
    } WAKEUP_9_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_9_INT_EN;             /*!< (@ 0x0000012C) WAKEUP_9_INT_EN                                            */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] enable interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_9_INT_EN_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_9_INT;                /*!< (@ 0x00000130) WAKEUP_9_INT                                               */
    
    struct {
      __IM  uint32_t INT_GPMCLK : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
      __IM  uint32_t IO_RAW_DATA : 1;           /*!< [1..1] represent the current value of the IO coosen by WAKEUP_IO_SEL
                                                     for this wakeup. This is regardless of the wakeup status.
                                                     Note that this async status and represents only stable
                                                     data correctly                                                            */
            uint32_t            : 30;
    } WAKEUP_9_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_9_INT_RCLR;           /*!< (@ 0x00000134) WAKEUP_9_INT_RCLR                                          */
    
    struct {
      __IOM uint32_t INT_GPMCLK_RCLK : 1;       /*!< [0..0] write clr interrupt for current io wakeup machine                  */
            uint32_t            : 31;
    } WAKEUP_9_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED9[2];
  
  union {
    __IOM uint32_t WAKEUP_UART0_CTRL;           /*!< (@ 0x00000140) WAKEUP_UART0_CTRL                                          */
    
    struct {
      __IOM uint32_t WKUP_INT_EN : 1;           /*!< [0..0] interrupt enable. While this bit is 0. int is tied to
                                                     0 and not get new int.                                                    */
            uint32_t            : 1;
      __IOM uint32_t WKUP_RX_POL : 1;           /*!< [2..2] polarity for RX signal for wakeup. 0= high. 1 = low.               */
      __IOM uint32_t RTS_POL    : 1;            /*!< [3..3] polarity for RTS signal. 0= high. 1 = low.                         */
            uint32_t            : 28;
    } WAKEUP_UART0_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART0_IN_SEL;         /*!< (@ 0x00000144) WAKEUP_UART0_IN_SEL                                        */
    
    struct {
      __IOM uint32_t IN_SEL     : 3;            /*!< [2..0] Select input to the UART wakeup machine:0: UART0_RX1:
                                                     UART2_RX2: SPIM0_MISO3: I2C1_SCL4: PCM_IN5: FLASH1_IO0Options
                                                     2-5 are not valid for PMP                                                 */
            uint32_t            : 29;
    } WAKEUP_UART0_IN_SEL_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART0_INT;            /*!< (@ 0x00000148) WAKEUP_UART0_INT                                           */
    
    struct {
      __IM  uint32_t WAKEUP_INT : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_UART0_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART0_INT_RCLR;       /*!< (@ 0x0000014C) WAKEUP_UART0_INT_RCLR                                      */
    
    struct {
      __IOM uint32_t WAKEUP_INT_RCLR : 1;       /*!< [0..0] status interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_UART0_INT_RCLR_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART1_CTRL;           /*!< (@ 0x00000150) WAKEUP_UART1_CTRL                                          */
    
    struct {
      __IOM uint32_t WKUP_INT_EN : 1;           /*!< [0..0] interrupt enable. While this bit is 0. int is tied to
                                                     0 and not get new int.                                                    */
            uint32_t            : 1;
      __IOM uint32_t WKUP_RX_POL : 1;           /*!< [2..2] polarity for RX signal for wakeup. 0= high. 1 = low.               */
      __IOM uint32_t RTS_POL    : 1;            /*!< [3..3] polarity for RTS signal. 0= high. 1 = low.                         */
            uint32_t            : 28;
    } WAKEUP_UART1_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART1_IN_SEL;         /*!< (@ 0x00000154) WAKEUP_UART1_IN_SEL                                        */
    
    struct {
      __IOM uint32_t IN_SEL     : 3;            /*!< [2..0] Select input to the UART wakeup machine:0: UART0_RX1:
                                                     UART2_RX2: SPIM0_MISO3: I2C1_SCL4: PCM_IN5: FLASH1_IO0Options
                                                     2-5 are not valid for PMP                                                 */
            uint32_t            : 29;
    } WAKEUP_UART1_IN_SEL_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART1_INT;            /*!< (@ 0x00000158) WAKEUP_UART1_INT                                           */
    
    struct {
      __IM  uint32_t WAKEUP_INT : 1;            /*!< [0..0] status interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_UART1_INT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_UART1_INT_RCLR;       /*!< (@ 0x0000015C) WAKEUP_UART1_INT_RCLR                                      */
    
    struct {
      __IOM uint32_t WAKEUP_INT_RCLR : 1;       /*!< [0..0] status interrupt for current io wakeup machine                     */
            uint32_t            : 31;
    } WAKEUP_UART1_INT_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED10[4];
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_CTRL0;         /*!< (@ 0x00000170) WAKEUP_KEYPAD_CTRL0                                        */
    
    struct {
      __IOM uint32_t KEYPAD_WAKEUP_EN : 1;      /*!< [0..0] wakeup enable. While this bit is 0.wakeup does not send
                                                     anything to the interrupt.                                                */
      __IOM uint32_t KAYPAD_WAKEUP_START_VAL_CAPTURE : 1;/*!< [1..1] capturing to wakeup controller the start val for keypad
                                                     register.Wakeup will be indicated upon a diff between the
                                                     kaypad register ans the value of keypad IOs.Notice!! This
                                                     register is sampled in 32Kclk. Please reset this register
                                                     after 32K time.This bit resets by HW when the request arrived
                                                     to the 32K clk (gpmclk can not be turned off untill it
                                                     does)                                                                     */
      __IOM uint32_t DEBOUNCE_MAX_VAL : 12;     /*!< [13..2] number of 32K cycles for the debounce.                            */
      __IOM uint32_t KEYPAD_WAKEUP_INT_EN : 1;  /*!< [14..14] wakeup interrupt enable. Enables the interrupt.                  */
            uint32_t            : 1;
      __IOM uint32_t KEYPAD_WAKEUP_CLK_SEL : 1; /*!< [16..16] wakeup clock select: 0 - clk32 1 - uart_clk                      */
            uint32_t            : 15;
    } WAKEUP_KEYPAD_CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_START_DATA_VAL;/*!< (@ 0x00000174) WAKEUP_KEYPAD_START_DATA_VAL                               */
    
    struct {
      __IOM uint32_t KEYPAD_START_DATA_VAL : 10;/*!< [9..0] data to be captured to wakeup controller the start val
                                                     for keypad register.Wakeup will be indicated upon a diff
                                                     between the kaypad register ans the value of keypad IOs.                  */
            uint32_t            : 22;
    } WAKEUP_KEYPAD_START_DATA_VAL_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_INT_STAT;      /*!< (@ 0x00000178) WAKEUP_KEYPAD_INT_STAT                                     */
    
    struct {
      __IM  uint32_t KEYPAD_WAKEUP_INT_GPMCLK : 1;/*!< [0..0] int value synked to gpmclk                                       */
      __IM  uint32_t KEYPAD_WAKEUP_INT_ASYNC : 1;/*!< [1..1] int befor sync. Use only if the gpmclk one does not work          */
      __IM  uint32_t KEYPAD_WAKEUP_INT_DIFF_ARRAY : 10;/*!< [11..2] when int asserted. This register indicater the diff
                                                     between the start IO values and the current IO values.This
                                                     can be used to see which button was pressed in keypad.                    */
            uint32_t            : 19;
      __IM  uint32_t KEYPAD_WAKEUP_EN_STAT : 1; /*!< [31..31] indication of that the start command arrived to the
                                                     32k domain and wakeup is actually active                                  */
    } WAKEUP_KEYPAD_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_INT_STAT_RCLR; /*!< (@ 0x0000017C) WAKEUP_KEYPAD_INT_STAT_RCLR                                */
    
    struct {
      __IOM uint32_t KEYPAD_WAKEUP_INT_GPMCLK_RCLR : 1;/*!< [0..0] int value synked to gpmclk                                  */
      __IOM uint32_t KEYPAD_WAKEUP_INT_ASYNC_RCLR : 1;/*!< [1..1] int befor sync. Use only if the gpmclk one does not work     */
      __IOM uint32_t KEYPAD_WAKEUP_INT_DIFF_ARRAY_RCLR : 10;/*!< [11..2] when int asserted. This register indicater the diff
                                                     between the start IO values and the current IO values.This
                                                     can be used to see which button was pressed in keypad.                    */
            uint32_t            : 19;
      __IOM uint32_t KEYPAD_WAKEUP_EN_STAT_RCLR : 1;/*!< [31..31] indication of that the start command arrived to the
                                                     32k domain and wakeup is actually active                                  */
    } WAKEUP_KEYPAD_INT_STAT_RCLR_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_IO_SEL0;       /*!< (@ 0x00000180) WAKEUP_KEYPAD_IO_SEL0                                      */
    
    struct {
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL0 : 2; /*!< [1..0] 0 - 1'b0.1 - MCU_PCM_CLK2 - MCU_FLASH1_IO0.                        */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL1 : 2; /*!< [3..2] 0 - 1'b0.1 - MCU_PCM_FS2 - MCU_FLASH1_IO1                          */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL2 : 2; /*!< [5..4] 0 - 1'b0.1 - MCU_PCM_IN2 - MCU_FLASH1_IO2                          */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL3 : 2; /*!< [7..6] 0 - 1'b0.1 - MCU_PCM_OUT2 - MCU_FLASH1_IO3                         */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL4 : 2; /*!< [9..8] 0 - 1'b0.1 - MCU_SPIM0_EN12 - MCU_GPIO3                            */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL5 : 2; /*!< [11..10] 0 - 1'b0.1 - MCU_PWM12 - MCU_FLASH1_CS_N                         */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL6 : 2; /*!< [13..12] 0 - 1'b0.1 - MCU_SPIM1_MISO2 - MCU_GPIO1                         */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL7 : 2; /*!< [15..14] 0 - 1'b0.1 - MCU_I2C0_SDA2 - MCU_GPIO2                           */
            uint32_t            : 16;
    } WAKEUP_KEYPAD_IO_SEL0_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP_KEYPAD_IO_SEL1;       /*!< (@ 0x00000184) WAKEUP_KEYPAD_IO_SEL1                                      */
    
    struct {
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL8 : 2; /*!< [1..0] 0 - 1'b0.1 - MCU_SPIM1_EN2 - MCU_FLASH1_SCK                        */
      __IOM uint32_t KEYPAD_WAKEUP_IO_SEL9 : 2; /*!< [3..2] 0 - 1'b0.1 - MCU_I2C0_SCL2 - MCU_GPIO0                             */
            uint32_t            : 28;
    } WAKEUP_KEYPAD_IO_SEL1_b;
  } ;
  __IM  uint32_t  RESERVED11[2];
  
  union {
    __IOM uint32_t EXTRET_STAT;                 /*!< (@ 0x00000190) EXTRET_STAT                                                */
    
    struct {
      __IM  uint32_t EXTRET_0   : 1;            /*!< [0..0] status of rtc external register. For latch on                      */
            uint32_t            : 31;
    } EXTRET_STAT_b;
  } ;
} IO_WKUP_CTRL_Type;                            /*!< Size = 404 (0x194)                                                        */



/* =========================================================================================================================== */
/* ================                                  ATOMIC_COUNTER_MAILBOX4                                  ================ */
/* =========================================================================================================================== */


/**
  * @brief ATOMIC_COUNTER_MAILBOX4 (ATOMIC_COUNTER_MAILBOX4)
  */

typedef struct {                                /*!< (@ 0x0D008400) ATOMIC_COUNTER_MAILBOX4 Structure                          */
  
  union {
    __IOM uint32_t INC;                         /*!< (@ 0x00000000) INC                                                        */
    
    struct {
      __OM  uint32_t INC        : 8;            /*!< [7..0] counter software increment.                                        */
            uint32_t            : 24;
    } INC_b;
  } ;
  
  union {
    __IOM uint32_t DEC;                         /*!< (@ 0x00000004) DEC                                                        */
    
    struct {
      __OM  uint32_t DEC        : 8;            /*!< [7..0] counter software decrement.                                        */
            uint32_t            : 24;
    } DEC_b;
  } ;
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000008) CTRL                                                       */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] counter interrupt enable.                                          */
      __IOM uint32_t INT_MODE   : 2;            /*!< [2..1] counter interrupt mode: 0 - not zero; 1- increment; 2
                                                     - decrement; 3 - increment or decrement.                                  */
      __IOM uint32_t HW_EN      : 1;            /*!< [3..3] counter hardware increment/decrement enable.                       */
            uint32_t            : 28;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t INT_STAT;                    /*!< (@ 0x0000000C) INT_STAT                                                   */
    
    struct {
      __IOM uint32_t INT_STAT   : 1;            /*!< [0..0] counter interrupt status - clears only when not in 'no
                                                     zero' interrupt mode                                                      */
            uint32_t            : 31;
    } INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t VAL;                         /*!< (@ 0x00000010) VAL                                                        */
    
    struct {
      __IOM uint32_t VAL        : 8;            /*!< [7..0] read/write (override) counter value                                */
            uint32_t            : 24;
    } VAL_b;
  } ;
} ATOMIC_COUNTER_MAILBOX_Type;                  /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                         LED_CTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief LED controller (LED_CTRL)
  */

typedef struct {                                /*!< (@ 0x01500000) LED_CTRL Structure                                         */
  
  union {
    __IOM uint32_t RESTART;                     /*!< (@ 0x00000000) RESTART                                                    */
    
    struct {
      __IOM uint32_t RESTART    : 11;           /*!< [10..0] RESTART                                                           */
            uint32_t            : 21;
    } RESTART_b;
  } ;
  
  union {
    __IOM uint32_t CNTR_CFG;                    /*!< (@ 0x00000004) CNTR_CFG                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CNTR_CLK_EN : 1;/*!< [0..0] clock enable for counter 1 - enable for led functionality0
                                                     - led controller disabled                                                 */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_CNTR_TARGET : 16;/*!< [19..4] led controller target for counter to create one KHz
                                                     pulsee.g.:if clk is 32KHz configure to 0x0020if clk is
                                                     19.2MHz configure to 0x4B00if clk is 26MHz configure to
                                                     0x6590                                                                    */
            uint32_t            : 12;
    } CNTR_CFG_b;
  } ;
  
  union {
    __IOM uint32_t CFG_0;                       /*!< (@ 0x00000008) CFG_0                                                      */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_0_b;
  } ;
  
  union {
    __IOM uint32_t CFG_1;                       /*!< (@ 0x0000000C) CFG_1                                                      */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_1_b;
  } ;
  
  union {
    __IOM uint32_t CFG_2;                       /*!< (@ 0x00000010) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_2_b;
  } ;
  
  union {
    __IOM uint32_t CFG_3;                       /*!< (@ 0x00000014) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_3_b;
  } ;
  
  union {
    __IOM uint32_t CFG_4;                       /*!< (@ 0x00000018) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_4_b;
  } ;
  
  union {
    __IOM uint32_t CFG_5;                       /*!< (@ 0x0000001C) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_CLK_EN : 1;   /*!< [0..0] disable the clock for this led controller0 - clock controller
                                                     disabled or in dim mode1 - clock controller enabled                       */
            uint32_t            : 3;
      __IOM uint32_t GRF_LED_CTRL_POLARITY : 1; /*!< [4..4] configure according to physical polarity of the LED0
                                                     - led is lit when 01 - led is lit when 1                                  */
      __IOM uint32_t GRF_LED_CTRL_DIM_SEL : 2;  /*!< [6..5] enable dim mode for led controller:2'b00 - disabled2'b01
                                                     - disabled2'b10 - dim controller 0 enabled2'b11 - dim controller
                                                     1 enabled                                                                 */
            uint32_t            : 1;
      __IOM uint32_t GRF_LED_CTRL_OFFSET : 12;  /*!< [19..8] defines the led controllers blink offset in ms (assuming
                                                     clock is divided to 1KHz) from the free running counter;
                                                     used to sync two or more led controllers                                  */
            uint32_t            : 12;
    } CFG_5_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t DURATION_0;                  /*!< (@ 0x00000028) DURATION_0                                                 */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_0_b;
  } ;
  
  union {
    __IOM uint32_t DURATION_1;                  /*!< (@ 0x0000002C) DURATION_1                                                 */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_1_b;
  } ;
  
  union {
    __IOM uint32_t DURATION_2;                  /*!< (@ 0x00000030) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_2_b;
  } ;
  
  union {
    __IOM uint32_t DURATION_3;                  /*!< (@ 0x00000034) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_3_b;
  } ;
  
  union {
    __IOM uint32_t DURATION_4;                  /*!< (@ 0x00000038) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_4_b;
  } ;
  
  union {
    __IOM uint32_t DURATION_5;                  /*!< (@ 0x0000003C) Not used                                                   */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_ON_DURATION : 12;/*!< [11..0] defines the on duration of the LED in ms (assuming 1KHz
                                                     divided clock is used); used to model the led blink wave
                                                     form                                                                      */
      __IOM uint32_t GRF_LED_CTRL_OFF_DURATION : 12;/*!< [23..12] defines the off duration of the LED in ms (assuming
                                                     1KHz divided clock is used); used to model the led blink
                                                     wave form                                                                 */
            uint32_t            : 8;
    } DURATION_5_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t DIM_CFG_0;                   /*!< (@ 0x00000048) DIM_CFG_0                                                  */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_DIM_LOW_DELAY : 8;/*!< [7..0] defines the duration the LED pauses when fully lit in
                                                     dim mode; 256 levels in 4ms resolution                                    */
      __IOM uint32_t GRF_LED_CTRL_DIM_HIGH_DELAY : 8;/*!< [15..8] defines the duration the LED pauses when fully lit in
                                                     dim mode; 256 levels in 4ms resolution                                    */
      __IOM uint32_t GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS : 10;/*!< [25..16] defines how many times each brightness level is repeated
                                                     before transitioning to the next one                                      */
      __IOM uint32_t GRF_LED_CTRL_DIM_BRIGHT_LEVELS : 6;/*!< [31..26] defines how many brightness levels (steps) the LED
                                                     transitions through during half of a dim cycle                            */
    } DIM_CFG_0_b;
  } ;
  
  union {
    __IOM uint32_t DIM_CFG_1;                   /*!< (@ 0x0000004C) DIM_CFG_1                                                  */
    
    struct {
      __IOM uint32_t GRF_LED_CTRL_DIM_LOW_DELAY : 8;/*!< [7..0] defines the duration the LED pauses when fully lit in
                                                     dim mode; 256 levels in 4ms resolution                                    */
      __IOM uint32_t GRF_LED_CTRL_DIM_HIGH_DELAY : 8;/*!< [15..8] defines the duration the LED pauses when fully lit in
                                                     dim mode; 256 levels in 4ms resolution                                    */
      __IOM uint32_t GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS : 10;/*!< [25..16] defines how many times each brightness level is repeated
                                                     before transitioning to the next one                                      */
      __IOM uint32_t GRF_LED_CTRL_DIM_BRIGHT_LEVELS : 6;/*!< [31..26] defines how many brightness levels (steps) the LED
                                                     transitions through during half of a dim cycle                            */
    } DIM_CFG_1_b;
  } ;
  
  union {
    __IOM uint32_t DIM_STATUS_0;                /*!< (@ 0x00000050) DIM_STATUS_0                                               */
    
    struct {
      __IM  uint32_t LED_CTRL_DIM_S : 1;        /*!< [0..0] output from dim controller; this is the input to the
                                                     led controller                                                            */
      __IM  uint32_t LED_CTRL_DIM_STATE : 3;    /*!< [3..1] dim controller current state;0 - IDLE1- INCREMENT2- INCREMENT
                                                     HOLD3- DECREMENT4- DECREMENT HOLD                                         */
      __IM  uint32_t LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR : 8;/*!< [11..4] current value of brightness levels counter           */
      __IM  uint32_t LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR : 10;/*!< [21..12] current value of base unit repeats counter          */
      __IM  uint32_t LED_CTRL_DIM_ONEKHZ_CNTR : 10;/*!< [31..22] current value of dim one KHz counter                          */
    } DIM_STATUS_0_b;
  } ;
  
  union {
    __IOM uint32_t DIM_STATUS_1;                /*!< (@ 0x00000054) DIM_STATUS_1                                               */
    
    struct {
      __IM  uint32_t LED_CTRL_DIM_S : 1;        /*!< [0..0] output from dim controller; this is the input to the
                                                     led controller                                                            */
      __IM  uint32_t LED_CTRL_DIM_STATE : 3;    /*!< [3..1] dim controller current state;0 - IDLE1- INCREMENT2- INCREMENT
                                                     HOLD3- DECREMENT4- DECREMENT HOLD                                         */
      __IM  uint32_t LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR : 8;/*!< [11..4] current value of brightness levels counter           */
      __IM  uint32_t LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR : 10;/*!< [21..12] current value of base unit repeats counter          */
      __IM  uint32_t LED_CTRL_DIM_ONEKHZ_CNTR : 10;/*!< [31..22] current value of dim one KHz counter                          */
    } DIM_STATUS_1_b;
  } ;
  
  union {
    __IOM uint32_t CNTR_STATUS;                 /*!< (@ 0x00000058) CNTR_STATUS                                                */
    
    struct {
      __IM  uint32_t LED_CTRL_ONEKHZ_CNTR : 13; /*!< [12..0] free running counter for all led controller; increments
                                                     on 1 ms pulse                                                             */
      __IM  uint32_t LED_CTRL_CLK_CNTR : 15;    /*!< [27..13] free running counter to create a 1ms pulse; increments
                                                     every sleep_clk; resets according to grf_led_ctrl_cntr_target             */
            uint32_t            : 4;
    } CNTR_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t STATUS;                      /*!< (@ 0x0000005C) STATUS                                                     */
    
    struct {
      __IM  uint32_t LED_CTRL_LED_0 : 1;        /*!< [0..0] output of led 0 from led controller                                */
      __IM  uint32_t LED_CTRL_LED_1 : 1;        /*!< [1..1] output of led 1 from led controller                                */
            uint32_t            : 30;
    } STATUS_b;
  } ;
} LED_CTRL_Type;                                /*!< Size = 96 (0x60)                                                          */



/* =========================================================================================================================== */
/* ================                                        IO_FUNC_SEL                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief IO functional muxing (IO_FUNC_SEL)
  */

typedef struct {                                /*!< (@ 0x01510000) IO_FUNC_SEL Structure                                      */
  
  union {
    __IOM uint32_t FLASH0_CS_N0;                /*!< (@ 0x00000000) FLASH0_CS_N0                                               */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_CS_N0 : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[0]                           */
            uint32_t            : 29;
    } FLASH0_CS_N0_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_CS_N1;                /*!< (@ 0x00000004) FLASH0_CS_N1                                               */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_CS_N1 : 3;/*!< [2..0] 0: 1: 2: mcu_ext_dma_rdy0 3: 4: mcu_gpio_8_out[1]          */
            uint32_t            : 29;
    } FLASH0_CS_N1_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_SCK;                  /*!< (@ 0x00000008) FLASH0_SCK                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_SCK : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[2]                             */
            uint32_t            : 29;
    } FLASH0_SCK_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_RESETN;               /*!< (@ 0x0000000C) FLASH0_RESETN                                              */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_RESETN : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[3]                          */
            uint32_t            : 29;
    } FLASH0_RESETN_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_DQS;                  /*!< (@ 0x00000010) FLASH0_DQS                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_DQS : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[4]                             */
            uint32_t            : 29;
    } FLASH0_DQS_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO0;                  /*!< (@ 0x00000014) FLASH0_IO0                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO0 : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[5]                             */
            uint32_t            : 29;
    } FLASH0_IO0_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO1;                  /*!< (@ 0x00000018) FLASH0_IO1                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO1 : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[6]                             */
            uint32_t            : 29;
    } FLASH0_IO1_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO2;                  /*!< (@ 0x0000001C) FLASH0_IO2                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO2 : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_8_out[7]                             */
            uint32_t            : 29;
    } FLASH0_IO2_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO3;                  /*!< (@ 0x00000020) FLASH0_IO3                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO3 : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_9_out[0]                             */
            uint32_t            : 29;
    } FLASH0_IO3_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO4;                  /*!< (@ 0x00000024) FLASH0_IO4                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO4 : 3;/*!< [2..0] 0: mcu_uart1_cts_n 1: 2: mcu_pwm0 3: 4: mcu_gpio_9_out[1]    */
            uint32_t            : 29;
    } FLASH0_IO4_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO5;                  /*!< (@ 0x00000028) FLASH0_IO5                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO5 : 3;/*!< [2..0] 0: mcu_uart1_txd 1: 2: mcu_pwm1 3: 4: mcu_gpio_9_out[2]      */
            uint32_t            : 29;
    } FLASH0_IO5_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO6;                  /*!< (@ 0x0000002C) FLASH0_IO6                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO6 : 3;/*!< [2..0] 0: mcu_uart1_rts_n 1: 2: mcu_pwm2 3: 4: mcu_gpio_9_out[3]    */
            uint32_t            : 29;
    } FLASH0_IO6_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_IO7;                  /*!< (@ 0x00000030) FLASH0_IO7                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_IO7 : 3;/*!< [2..0] 0: mcu_uart1_rxd 1: 2: mcu_pwm3 3: 4: mcu_gpio_9_out[4]      */
            uint32_t            : 29;
    } FLASH0_IO7_b;
  } ;
  
  union {
    __IOM uint32_t FLASH0_CS_N2;                /*!< (@ 0x00000034) FLASH0_CS_N2                                               */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH0_CS_N2 : 3;/*!< [2..0] 0: 1: mcu_led_ctrl_led_5 2: mcu_ext_dma_rdy1 3: 4: mcu_gpio_9_out[5] */
            uint32_t            : 29;
    } FLASH0_CS_N2_b;
  } ;
  
  union {
    __IOM uint32_t GPIO0;                       /*!< (@ 0x00000038) GPIO0                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO0 : 3;/*!< [2..0] 0: mcu_pwm2 1: mcu_led_ctrl_led_4 2: mcu_cc_in0 3: mcu_ext_dma_rdy3
                                                     4: mcu_gpio_0_out[0]                                                      */
            uint32_t            : 29;
    } GPIO0_b;
  } ;
  
  union {
    __IOM uint32_t GPIO1;                       /*!< (@ 0x0000003C) GPIO1                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO1 : 3;/*!< [2..0] 0: mcu_clkout 1: mcu_led_ctrl_led_1 2: mcu_cc_in1 3:
                                                     4: mcu_gpio_0_out[1]                                                      */
            uint32_t            : 29;
    } GPIO1_b;
  } ;
  
  union {
    __IOM uint32_t GPIO2;                       /*!< (@ 0x00000040) GPIO2                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO2 : 3;/*!< [2..0] 0: mcu_swclk 1: mcu_i2c1_sda_out 2: mcu_cc_in2 3: mcu_spi1_cs0_out
                                                     4: mcu_gpio_0_out[2]                                                      */
            uint32_t            : 29;
    } GPIO2_b;
  } ;
  
  union {
    __IOM uint32_t GPIO3;                       /*!< (@ 0x00000044) GPIO3                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO3 : 3;/*!< [2..0] 0: mcu_swdat_out 1: mcu_i2c1_scl_out 2: mcu_cc_in3 3:
                                                     mcu_spi1_sck_out 4: mcu_gpio_0_out[3]                                     */
            uint32_t            : 29;
    } GPIO3_b;
  } ;
  
  union {
    __IOM uint32_t GPIO4;                       /*!< (@ 0x00000048) GPIO4                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO4 : 3;/*!< [2..0] 0: 1: mcu_cc_out1 2: mcu_led_ctrl_led_0 3: 4: mcu_gpio_0_out[4]   */
            uint32_t            : 29;
    } GPIO4_b;
  } ;
  
  union {
    __IOM uint32_t GPIO5;                       /*!< (@ 0x0000004C) GPIO5                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_GPIO5 : 3;/*!< [2..0] 0: 1: mcu_cc_out2 2: mcu_led_ctrl_led_2 3: 4: mcu_gpio_0_out[5]   */
            uint32_t            : 29;
    } GPIO5_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_VDDIO_OUT;              /*!< (@ 0x00000050) RFFE_VDDIO_OUT                                             */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_RFFE_VDDIO_OUT : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[1]                         */
            uint32_t            : 29;
    } RFFE_VDDIO_OUT_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SCLK;                   /*!< (@ 0x00000054) RFFE_SCLK                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_RFFE_SCLK : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[2]                              */
            uint32_t            : 29;
    } RFFE_SCLK_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SDATA;                  /*!< (@ 0x00000058) RFFE_SDATA                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_RFFE_SDATA : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[3]                             */
            uint32_t            : 29;
    } RFFE_SDATA_b;
  } ;
  
  union {
    __IOM uint32_t SC_RST;                      /*!< (@ 0x0000005C) SC_RST                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SC_RST : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[4]                                 */
            uint32_t            : 29;
    } SC_RST_b;
  } ;
  
  union {
    __IOM uint32_t SC_IO;                       /*!< (@ 0x00000060) SC_IO                                                      */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SC_IO : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[5]                                  */
            uint32_t            : 29;
    } SC_IO_b;
  } ;
  
  union {
    __IOM uint32_t SC_CLK;                      /*!< (@ 0x00000064) SC_CLK                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SC_CLK : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_1_out[6]                                 */
            uint32_t            : 29;
    } SC_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SC_DET;                      /*!< (@ 0x00000068) SC_DET                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SC_DET : 3;/*!< [2..0] 0: 1: mcu_pwm0 2: 3: 4: mcu_gpio_1_out[7]                        */
            uint32_t            : 29;
    } SC_DET_b;
  } ;
  
  union {
    __IOM uint32_t SC_SWP;                      /*!< (@ 0x0000006C) SC_SWP                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SC_SWP : 3;/*!< [2..0] 0: mcu_clkout 1: mcu_cc_out3 2: mcu_pwm3 3: 4: mcu_gpio_2_out[0] */
            uint32_t            : 29;
    } SC_SWP_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TCK;                      /*!< (@ 0x00000070) EJ_TCK                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_EJ_TCK : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_2_out[1]                                 */
            uint32_t            : 29;
    } EJ_TCK_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TMS;                      /*!< (@ 0x00000074) EJ_TMS                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_EJ_TMS : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_2_out[2]                                 */
            uint32_t            : 29;
    } EJ_TMS_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TRST;                     /*!< (@ 0x00000078) EJ_TRST                                                    */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_EJ_TRST : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_2_out[3]                                */
            uint32_t            : 29;
    } EJ_TRST_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDI;                      /*!< (@ 0x0000007C) EJ_TDI                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_EJ_TDI : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_2_out[4]                                 */
            uint32_t            : 29;
    } EJ_TDI_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDO;                      /*!< (@ 0x00000080) EJ_TDO                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_EJ_TDO : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_2_out[5]                                 */
            uint32_t            : 29;
    } EJ_TDO_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RX;                    /*!< (@ 0x00000084) UART0_RX                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART0_RX : 3;/*!< [2..0] 0: mcu_uart0_rxd 1: 2: 3: 4: mcu_gpio_2_out[6]                 */
            uint32_t            : 29;
    } UART0_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_TX;                    /*!< (@ 0x00000088) UART0_TX                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART0_TX : 3;/*!< [2..0] 0: mcu_uart0_txd 1: 2: 3: 4: mcu_gpio_2_out[7]                 */
            uint32_t            : 29;
    } UART0_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_CTS;                   /*!< (@ 0x0000008C) UART0_CTS                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART0_CTS : 3;/*!< [2..0] 0: mcu_uart0_cts_n 1: mcu_i2c0_scl_out 2: 3: mcu_spi0_sck_out
                                                     4: mcu_gpio_3_out[0]                                                      */
            uint32_t            : 29;
    } UART0_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RTS;                   /*!< (@ 0x00000090) UART0_RTS                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART0_RTS : 3;/*!< [2..0] 0: mcu_uart0_rts_n 1: mcu_i2c0_sda_out 2: 3: mcu_spi0_cs0_out
                                                     4: mcu_gpio_3_out[1]                                                      */
            uint32_t            : 29;
    } UART0_RTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RX;                    /*!< (@ 0x00000094) UART2_RX                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART2_RX : 3;/*!< [2..0] 0: mcu_spi0_cd_out 1: mcu_spi1_cd_out 2: mcu_uart1_rxd
                                                     3: mcu_pwm2 4: mcu_gpio_3_out[2]                                          */
            uint32_t            : 29;
    } UART2_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_TX;                    /*!< (@ 0x00000098) UART2_TX                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART2_TX : 3;/*!< [2..0] 0: mcu_spi0_mosi_out 1: mcu_spi1_mosi_out 2: mcu_uart1_txd
                                                     3: 4: mcu_gpio_3_out[3]                                                   */
            uint32_t            : 29;
    } UART2_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_CTS;                   /*!< (@ 0x0000009C) UART2_CTS                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART2_CTS : 3;/*!< [2..0] 0: mcu_spi0_sck_out 1: mcu_spi1_sck_out 2: mcu_uart1_cts_n
                                                     3: mcu_ext_dma_rdy2 4: mcu_gpio_3_out[4]                                  */
            uint32_t            : 29;
    } UART2_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RTS;                   /*!< (@ 0x000000A0) UART2_RTS                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_UART2_RTS : 3;/*!< [2..0] 0: mcu_spi0_cs0_out 1: mcu_spi1_cs0_out 2: mcu_uart1_rts_n
                                                     3: 4: mcu_gpio_3_out[5]                                                   */
            uint32_t            : 29;
    } UART2_RTS_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_SEL;                   /*!< (@ 0x000000A4) DEBUG_SEL                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_DEBUG_SEL : 3;/*!< [2..0] 0: 1: 2: 3: 4: mcu_gpio_3_out[6]                              */
            uint32_t            : 29;
    } DEBUG_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_RSTN;                  /*!< (@ 0x000000A8) DEBUG_RSTN                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_DEBUG_RSTN : 3;/*!< [2..0] 0: 1: 2: 3: 4:                                               */
            uint32_t            : 29;
    } DEBUG_RSTN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MOSI;                  /*!< (@ 0x000000AC) SPIM0_MOSI                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM0_MOSI : 3;/*!< [2..0] 0: mcu_spi_slave_miso 1: mcu_swclk 2: mcu_pcm_in 3: mcu_spi0_mosi_out
                                                     4: mcu_gpio_4_out[0]                                                      */
            uint32_t            : 29;
    } SPIM0_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MISO;                  /*!< (@ 0x000000B0) SPIM0_MISO                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM0_MISO : 3;/*!< [2..0] 0: mcu_spi_slave_mosi 1: mcu_uart1_rxd 2: mcu_pcm_fs
                                                     3: mcu_spi0_cd_out 4: mcu_gpio_4_out[1]                                   */
            uint32_t            : 29;
    } SPIM0_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN0;                   /*!< (@ 0x000000B4) SPIM0_EN0                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM0_EN0 : 3;/*!< [2..0] 0: mcu_spi_slave_clk 1: mcu_swdat_out 2: mcu_pcm_out
                                                     3: mcu_spi0_cs0_out 4: mcu_gpio_4_out[2]                                  */
            uint32_t            : 29;
    } SPIM0_EN0_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN1;                   /*!< (@ 0x000000B8) SPIM0_EN1                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM0_EN1 : 3;/*!< [2..0] 0: mcu_sf_cs_n1 1: mcu_spi_slave_srdy 2: mcu_cc_in2 3:
                                                     mcu_cc_out2 4: mcu_gpio_4_out[3]                                          */
            uint32_t            : 29;
    } SPIM0_EN1_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_CLK;                   /*!< (@ 0x000000BC) SPIM0_CLK                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM0_CLK : 3;/*!< [2..0] 0: mcu_spi_slave_mrdy 1: mcu_uart1_txd 2: mcu_pcm_clk
                                                     3: mcu_spi0_sck_out 4: mcu_gpio_4_out[4]                                  */
            uint32_t            : 29;
    } SPIM0_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MOSI;                  /*!< (@ 0x000000C0) SPIM1_MOSI                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM1_MOSI : 3;/*!< [2..0] 0: mcu_spi1_mosi_out 1: mcu_spi_slave_miso 2: mcu_pcm_out
                                                     3: mcu_pwm2 4: mcu_gpio_4_out[5]                                          */
            uint32_t            : 29;
    } SPIM1_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MISO;                  /*!< (@ 0x000000C4) SPIM1_MISO                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM1_MISO : 3;/*!< [2..0] 0: mcu_spi1_cd_out 1: mcu_spi_slave_mosi 2: mcu_pcm_fs
                                                     3: mcu_pwm1 4: mcu_gpio_4_out[6]                                          */
            uint32_t            : 29;
    } SPIM1_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_EN;                    /*!< (@ 0x000000C8) SPIM1_EN                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM1_EN : 3;/*!< [2..0] 0: mcu_spi1_cs0_out 1: mcu_spi_slave_clk 2: mcu_pcm_in
                                                     3: mcu_pwm3 4: mcu_gpio_4_out[7]                                          */
            uint32_t            : 29;
    } SPIM1_EN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_CLK;                   /*!< (@ 0x000000CC) SPIM1_CLK                                                  */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_SPIM1_CLK : 3;/*!< [2..0] 0: mcu_spi1_sck_out 1: mcu_spi_slave_mrdy 2: mcu_pcm_clk
                                                     3: mcu_cc_out0 4: mcu_gpio_5_out[0]                                       */
            uint32_t            : 29;
    } SPIM1_CLK_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SDA;                    /*!< (@ 0x000000D0) I2C0_SDA                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_I2C0_SDA : 3;/*!< [2..0] 0: mcu_i2c0_sda_out 1: 2: mcu_clkout 3: 4: mcu_gpio_5_out[1]   */
            uint32_t            : 29;
    } I2C0_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SCL;                    /*!< (@ 0x000000D4) I2C0_SCL                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_I2C0_SCL : 3;/*!< [2..0] 0: mcu_i2c0_scl_out 1: 2: 3: mcu_ext_dma_rdy4 4: mcu_gpio_5_out[2] */
            uint32_t            : 29;
    } I2C0_SCL_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SDA;                    /*!< (@ 0x000000D8) I2C1_SDA                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_I2C1_SDA : 3;/*!< [2..0] 0: mcu_i2c1_sda_out 1: mcu_sf_sck 2: mcu_pwm3 3: mcu_spi1_sck_out
                                                     4: mcu_gpio_5_out[3]                                                      */
            uint32_t            : 29;
    } I2C1_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SCL;                    /*!< (@ 0x000000DC) I2C1_SCL                                                   */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_I2C1_SCL : 3;/*!< [2..0] 0: mcu_i2c1_scl_out 1: mcu_sf_cs_n0 2: mcu_led_ctrl_led_3
                                                     3: mcu_spi1_cs0_out 4: mcu_gpio_5_out[4]                                  */
            uint32_t            : 29;
    } I2C1_SCL_b;
  } ;
  
  union {
    __IOM uint32_t PCM_CLK;                     /*!< (@ 0x000000E0) PCM_CLK                                                    */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PCM_CLK : 3;/*!< [2..0] 0: mcu_uart1_cts_n 1: mcu_sf_io0_out 2: mcu_led_ctrl_led_2
                                                     3: mcu_pcm_clk 4: mcu_gpio_5_out[5]                                       */
            uint32_t            : 29;
    } PCM_CLK_b;
  } ;
  
  union {
    __IOM uint32_t PCM_FS;                      /*!< (@ 0x000000E4) PCM_FS                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PCM_FS : 3;/*!< [2..0] 0: mcu_uart1_rts_n 1: mcu_sf_io1_out 2: mcu_led_ctrl_led_5
                                                     3: mcu_pcm_fs 4: mcu_gpio_5_out[6]                                        */
            uint32_t            : 29;
    } PCM_FS_b;
  } ;
  
  union {
    __IOM uint32_t PCM_IN;                      /*!< (@ 0x000000E8) PCM_IN                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PCM_IN : 3;/*!< [2..0] 0: mcu_uart1_rxd 1: mcu_sf_io2_out 2: mcu_led_ctrl_led_4
                                                     3: mcu_pcm_in 4: mcu_gpio_5_out[7]                                        */
            uint32_t            : 29;
    } PCM_IN_b;
  } ;
  
  union {
    __IOM uint32_t PCM_OUT;                     /*!< (@ 0x000000EC) PCM_OUT                                                    */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PCM_OUT : 3;/*!< [2..0] 0: mcu_uart1_txd 1: mcu_sf_io3_out 2: mcu_pwm2 3: mcu_pcm_out
                                                     4: mcu_gpio_6_out[0]                                                      */
            uint32_t            : 29;
    } PCM_OUT_b;
  } ;
  
  union {
    __IOM uint32_t PWM0;                        /*!< (@ 0x000000F0) PWM0                                                       */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PWM0 : 3;/*!< [2..0] 0: mcu_pwm0 1: mcu_cc_out0 2: mcu_cc_in0 3: mcu_clkout
                                                     4: mcu_gpio_6_out[1]                                                      */
            uint32_t            : 29;
    } PWM0_b;
  } ;
  
  union {
    __IOM uint32_t PWM1;                        /*!< (@ 0x000000F4) PWM1                                                       */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PWM1 : 3;/*!< [2..0] 0: mcu_pwm1 1: mcu_cc_out1 2: mcu_cc_in1 3: mcu_spi1_cd_out
                                                     4: mcu_gpio_6_out[2]                                                      */
            uint32_t            : 29;
    } PWM1_b;
  } ;
  
  union {
    __IOM uint32_t PWM2;                        /*!< (@ 0x000000F8) PWM2                                                       */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PWM2 : 3;/*!< [2..0] 0: mcu_pwm2 1: mcu_cc_out2 2: mcu_cc_in2 3: mcu_spi1_mosi_out
                                                     4: mcu_gpio_6_out[3]                                                      */
            uint32_t            : 29;
    } PWM2_b;
  } ;
  
  union {
    __IOM uint32_t PWM3;                        /*!< (@ 0x000000FC) PWM3                                                       */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PWM3 : 3;/*!< [2..0] 0: mcu_pwm3 1: mcu_cc_out3 2: mcu_cc_in3 3: mcu_led_ctrl_led_3
                                                     4: mcu_gpio_6_out[4]                                                      */
            uint32_t            : 29;
    } PWM3_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_CS_N;                 /*!< (@ 0x00000100) FLASH1_CS_N                                                */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_CS_N : 3;/*!< [2..0] 0: mcu_sf_cs_n0 1: mcu_sf_cs_n1 2: mcu_led_ctrl_led_0
                                                     3: mcu_pwm0 4: mcu_gpio_6_out[5]                                          */
            uint32_t            : 29;
    } FLASH1_CS_N_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_SCK;                  /*!< (@ 0x00000104) FLASH1_SCK                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_SCK : 3;/*!< [2..0] 0: mcu_sf_sck 1: 2: mcu_led_ctrl_led_1 3: mcu_pwm1 4:
                                                     mcu_gpio_6_out[6]                                                         */
            uint32_t            : 29;
    } FLASH1_SCK_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO0;                  /*!< (@ 0x00000108) FLASH1_IO0                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_IO0 : 3;/*!< [2..0] 0: mcu_sf_io0_out 1: mcu_i2c0_sda_out 2: mcu_uart1_rxd
                                                     3: mcu_cc_out0 4: mcu_gpio_6_out[7]                                       */
            uint32_t            : 29;
    } FLASH1_IO0_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO1;                  /*!< (@ 0x0000010C) FLASH1_IO1                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_IO1 : 3;/*!< [2..0] 0: mcu_sf_io1_out 1: mcu_i2c0_scl_out 2: mcu_uart1_txd
                                                     3: mcu_cc_out1 4: mcu_gpio_7_out[0]                                       */
            uint32_t            : 29;
    } FLASH1_IO1_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO2;                  /*!< (@ 0x00000110) FLASH1_IO2                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_IO2 : 3;/*!< [2..0] 0: mcu_sf_io2_out 1: mcu_i2c1_sda_out 2: mcu_uart1_cts_n
                                                     3: mcu_cc_out2 4: mcu_gpio_7_out[1]                                       */
            uint32_t            : 29;
    } FLASH1_IO2_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO3;                  /*!< (@ 0x00000114) FLASH1_IO3                                                 */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_FLASH1_IO3 : 3;/*!< [2..0] 0: mcu_sf_io3_out 1: mcu_i2c1_scl_out 2: mcu_uart1_rts_n
                                                     3: mcu_cc_out3 4: mcu_gpio_7_out[2]                                       */
            uint32_t            : 29;
    } FLASH1_IO3_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT;                      /*!< (@ 0x00000118) CLKOUT                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_CLKOUT : 3;/*!< [2..0] 0: mcu_sf_cs_n1 1: mcu_clkout 2: mcu_cc_out1 3: mcu_pwm0
                                                     4: mcu_gpio_7_out[3]                                                      */
            uint32_t            : 29;
    } CLKOUT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP;                      /*!< (@ 0x0000011C) WAKEUP                                                     */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_WAKEUP : 3;/*!< [2..0] 0: 1: 2: mcu_cc_in0 3: 4: mcu_gpio_7_in[4]                       */
            uint32_t            : 29;
    } WAKEUP_b;
  } ;
  
  union {
    __IOM uint32_t PB;                          /*!< (@ 0x00000120) PB                                                         */
    
    struct {
      __IOM uint32_t regmcu_io_cfg_sel_PB : 3;  /*!< [2..0] 0: 1: 2: mcu_cc_in1 3: 4: mcu_gpio_7_in[5]                         */
            uint32_t            : 29;
    } PB_b;
  } ;
} IO_FUNC_SEL_Type;                             /*!< Size = 292 (0x124)                                                        */



/* =========================================================================================================================== */
/* ================                                        CLK_CONTROL                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock control (CLK_CONTROL)
  */

typedef struct {                                /*!< (@ 0x01520000) CLK_CONTROL Structure                                      */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Main Clock settings                                        */
    
    struct {
      __IOM uint32_t GF_SEL     : 1;            /*!< [0..0] mcu clock generation - select of the GF mux between bootclk
                                                     and functional clock set by SEL0/SEL10: boot_clk1: rcclk
                                                     divided / pll_clk / URCLK (set by SEL0 and SEL1)                          */
      __IOM uint32_t GF_RST     : 1;            /*!< [1..1] mcu clock generation - reset of the GF mux between bootclk
                                                     and functional clock set by SEL0/SEL1                                     */
      __IOM uint32_t SEL0       : 1;            /*!< [2..2] Select input to GF mux that generates the mcu clock (togethter
                                                     with SEL1)0: pll_clk1: URCLK                                              */
      __IOM uint32_t SEL1       : 1;            /*!< [3..3] Select input to GF mux that generates the mcu clock0:
                                                     rc_clk1: pll or URCLK (set by SEL0)                                       */
      __IOM uint32_t DIV        : 3;            /*!< [6..4] divide value to rcclk before feeding the mcuclk muxes:0
                                                     - div by 11 - div by 23 - div by 47 - div by 8other values
                                                     are not allowed                                                           */
      __IOM uint32_t SEL_PLL_MCU_REFCLK : 1;    /*!< [7..7] DPLL reference input clock select0 - refclk1 - rcclk               */
      __IOM uint32_t MUX_UART1_EXT_CLK_SEL : 1; /*!< [8..8] external uart clk select0 - mcuclk1 - external uart clk
                                                     (selected by MUX_XO_URCLK_SEL)                                            */
      __IOM uint32_t MUX_UART0_EXT_CLK_SEL : 1; /*!< [9..9] external uart clk select0 - mcuclk1 - external uart clk
                                                     (selected by MUX_XO_URCLK_SEL)                                            */
      __IOM uint32_t MUX_XO_URCLK_SEL : 1;      /*!< [10..10] external uart clk select0 - refclk1 - urclk                      */
            uint32_t            : 5;
      __IOM uint32_t MCU_UART1_EXT_CLK_DIS : 1; /*!< [16..16] Gate the external UART1 clock                                    */
      __IOM uint32_t MCU_UART0_EXT_CLK_DIS : 1; /*!< [17..17] Gate the external UART0 clock                                    */
            uint32_t            : 14;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t DPLL_CFG;                    /*!< (@ 0x00000004) DPLL configuration                                         */
    
    struct {
      __IOM uint32_t BWADJ      : 6;            /*!< [5..0] Bandwidth divider value - A 6-bit register that selects
                                                     the values 1-64 for the bandwidth divider (NB)The divider
                                                     value is BWADJ[5:0] + 1 (e.g. for division by 4 use a value
                                                     of b000011)                                                               */
      __IOM uint32_t NF         : 6;            /*!< [11..6] Multiplication value - A 6-bit register that selects
                                                     the values 1-64 for the multiplication factor (NF)The multiplication
                                                     value is NF[5:0] + 1 (e.g. for multiplication by 4 use
                                                     a value of b000011)                                                       */
      __IOM uint32_t NR         : 4;            /*!< [15..12] Reference divider value - A 4-bit regisetr that selects
                                                     the values 1-16 for the reference divider (NR)The division
                                                     value is NR[3:0] + 1 (e.g. for division by 4 use a value
                                                     of b0011)                                                                 */
      __IOM uint32_t OD         : 4;            /*!< [19..16] Output divider value - A 4-bit register that selects
                                                     the values 1-16 for the post VCO divider (OD).The division
                                                     value is OD[3:0] + 1 (e.g. for division by 4 use a value
                                                     of b0011)                                                                 */
      __IOM uint32_t BYPSS      : 1;            /*!< [20..20] PLL bypass mode. When 0x1 the PLL is bypassed and its
                                                     output is the reference clock                                             */
      __IOM uint32_t INTFB      : 1;            /*!< [21..21] INTFB = 0 for deskewing; 1 for internal feedback (normal
                                                     usage)                                                                    */
      __IOM uint32_t TEST       : 1;            /*!< [22..22] PLL test mode.When TEST=1 The reference input drives
                                                     all dividers cascaded one after the other for production
                                                     testing.The PLL has a divider test mode (TEST=1) to allow
                                                     for rapid production testing of the dividers in the PLLs
                                                     without using the internal analog circuitry. This mode
                                                     (TEST=1) overrides the bypass mode (BYPASS=1).The output
                                                     frequency Fout at CLKOUT is related to the reference frequency
                                                     Fref by: Fout = Fref / NR / NF / OD                                       */
      __IOM uint32_t SLIP_EN    : 1;            /*!< [23..23] Enable DPLL's slip detection.Slip events are logged
                                                     in DPLL_STT register                                                      */
            uint32_t            : 8;
    } DPLL_CFG_b;
  } ;
  
  union {
    __IOM uint32_t DPLL_EN;                     /*!< (@ 0x00000008) DPLL Enable                                                */
    
    struct {
      __IOM uint32_t PWRDN      : 1;            /*!< [0..0] power down for DPLL1 - powered down0 - PLL enabled                 */
            uint32_t            : 31;
    } DPLL_EN_b;
  } ;
  
  union {
    __IOM uint32_t DPLL_RST;                    /*!< (@ 0x0000000C) DPLL Reset                                                 */
    
    struct {
      __IOM uint32_t DPLL_RST   : 1;            /*!< [0..0] reset of DPLL                                                      */
            uint32_t            : 31;
    } DPLL_RST_b;
  } ;
  
  union {
    __IOM uint32_t DPLL_STT;                    /*!< (@ 0x00000010) DPLLs slip status                                          */
    
    struct {
      __IOM uint32_t DPLL_RFSLIP_SAVE : 1;      /*!< [0..0] slip status. does not clear during reset. has to be cleared
                                                     at the beginning of life                                                  */
      __IOM uint32_t DPLL_FBSLIP_SAVE : 1;      /*!< [1..1] slip status. does not clear during reset. has to be cleared
                                                     at the beginning of life                                                  */
            uint32_t            : 30;
    } DPLL_STT_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK_REQ_BYP;             /*!< (@ 0x00000014) Control over clock gating - HW or SW                       */
    
    struct {
      __IOM uint32_t MCU_LED    : 1;            /*!< [0..0] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_GPIO_RF : 1;           /*!< [1..1] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_GPIO_IF : 1;           /*!< [2..2] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SSX    : 1;            /*!< [3..3] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_I2C1   : 1;            /*!< [4..4] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_I2C0   : 1;            /*!< [5..5] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_GDMA   : 1;            /*!< [6..6] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SF     : 1;            /*!< [7..7] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTF1 : 1;            /*!< [8..8] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTF0 : 1;            /*!< [9..9] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTI2 : 1;            /*!< [10..10] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTI1 : 1;            /*!< [11..11] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTI0 : 1;            /*!< [12..12] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SPI_SLAVE : 1;         /*!< [13..13] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SPI_MASTER1 : 1;       /*!< [14..14] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SPI_MASTER0 : 1;       /*!< [15..15] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_DEBUG  : 1;            /*!< [16..16] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_M4     : 1;            /*!< [17..17] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTF1_OCP : 1;        /*!< [18..18] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_UARTF0_OCP : 1;        /*!< [19..19] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_CLK32K_LED : 1;        /*!< [20..20] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_BIST   : 1;            /*!< [21..21] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SIC    : 1;            /*!< [22..22] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_IOSEL  : 1;            /*!< [23..23] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_TIMERS : 1;            /*!< [24..24] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SHADOW_32KHZ : 1;      /*!< [25..25] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SSX_PMP : 1;           /*!< [26..26] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_SSX_GPM : 1;           /*!< [27..27] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_REGMCU : 1;            /*!< [28..28] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_PWM    : 1;            /*!< [29..29] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_PCM    : 1;            /*!< [30..30] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MSE_BRIDGE : 1;            /*!< [31..31] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
    } MCU_CLK_REQ_BYP_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK_REQ_EN;              /*!< (@ 0x00000018) SW clock request enable                                    */
    
    struct {
      __IOM uint32_t MCU_LED    : 1;            /*!< [0..0] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_GPIO_RF : 1;           /*!< [1..1] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_GPIO_IF : 1;           /*!< [2..2] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_SSX    : 1;            /*!< [3..3] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_I2C1   : 1;            /*!< [4..4] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_I2C0   : 1;            /*!< [5..5] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_GDMA   : 1;            /*!< [6..6] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_SF     : 1;            /*!< [7..7] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_UARTF1 : 1;            /*!< [8..8] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_UARTF0 : 1;            /*!< [9..9] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_UARTI2 : 1;            /*!< [10..10] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_UARTI1 : 1;            /*!< [11..11] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_UARTI0 : 1;            /*!< [12..12] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SPI_SLAVE : 1;         /*!< [13..13] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SPI_MASTER1 : 1;       /*!< [14..14] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SPI_MASTER0 : 1;       /*!< [15..15] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_DEBUG  : 1;            /*!< [16..16] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_M4     : 1;            /*!< [17..17] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_UARTF1_OCP : 1;        /*!< [18..18] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_UARTF0_OCP : 1;        /*!< [19..19] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_CLK32K_LED : 1;        /*!< [20..20] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_BIST   : 1;            /*!< [21..21] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SIC    : 1;            /*!< [22..22] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_IOSEL  : 1;            /*!< [23..23] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_TIMERS : 1;            /*!< [24..24] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SHADOW_32KHZ : 1;      /*!< [25..25] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SSX_PMP : 1;           /*!< [26..26] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_SSX_GPM : 1;           /*!< [27..27] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_REGMCU : 1;            /*!< [28..28] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_PWM    : 1;            /*!< [29..29] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MCU_PCM    : 1;            /*!< [30..30] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
      __IOM uint32_t MSE_BRIDGE : 1;            /*!< [31..31] Clock gating when in SW contol clock0 - SW Control
                                                     Clock Disable1 - SW Control Clock Enable                                  */
    } MCU_CLK_REQ_EN_b;
  } ;
  
  union {
    __IOM uint32_t STAT_GATED_CLK;              /*!< (@ 0x0000001C) Clock gating status                                        */
    
    struct {
      __IM  uint32_t MCU_LED    : 1;            /*!< [0..0] Clock gating status0 - Clock is gated (disabled)1 - Clock
                                                     is not gated (Enabled)                                                    */
      __IM  uint32_t MCU_GPIO_RF : 1;           /*!< [1..1] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_GPIO_IF : 1;           /*!< [2..2] Clock gating status0 - Clock is gated (disabled)1 - Clock
                                                     is not gated (Enabled)                                                    */
      __IM  uint32_t MCU_SSX    : 1;            /*!< [3..3] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_I2C1   : 1;            /*!< [4..4] Clock gating status0 - Clock is gated (disabled)1 - Clock
                                                     is not gated (Enabled)                                                    */
      __IM  uint32_t MCU_I2C0   : 1;            /*!< [5..5] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_GDMA   : 1;            /*!< [6..6] Clock gating status0 - Clock is gated (disabled)1 - Clock
                                                     is not gated (Enabled)                                                    */
      __IM  uint32_t MCU_SF     : 1;            /*!< [7..7] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_UARTF1 : 1;            /*!< [8..8] Clock gating status0 - Clock is gated (disabled)1 - Clock
                                                     is not gated (Enabled)                                                    */
      __IM  uint32_t MCU_UARTF0 : 1;            /*!< [9..9] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_UARTI2 : 1;            /*!< [10..10] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_UARTI1 : 1;            /*!< [11..11] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_UARTI0 : 1;            /*!< [12..12] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_SPI_SLAVE : 1;         /*!< [13..13] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_SPI_MASTER1 : 1;       /*!< [14..14] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_SPI_MASTER0 : 1;       /*!< [15..15] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_DEBUG  : 1;            /*!< [16..16] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_M4     : 1;            /*!< [17..17] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_UARTF1_OCP : 1;        /*!< [18..18] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_UARTF0_OCP : 1;        /*!< [19..19] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_CLK32K_LED : 1;        /*!< [20..20] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_BIST   : 1;            /*!< [21..21] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_SIC    : 1;            /*!< [22..22] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_IOSEL  : 1;            /*!< [23..23] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_TIMERS : 1;            /*!< [24..24] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_SHADOW_32KHZ : 1;      /*!< [25..25] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_SSX_PMP : 1;           /*!< [26..26] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_SSX_GPM : 1;           /*!< [27..27] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_REGMCU : 1;            /*!< [28..28] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IM  uint32_t MCU_PWM    : 1;            /*!< [29..29] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IOM uint32_t MCU_PCM    : 1;            /*!< [30..30] Clock gating status0 - Clock is gated (disabled)1 -
                                                     Clock is not gated (Enabled)                                              */
      __IOM uint32_t MSE_BRIDGE : 1;            /*!< [31..31] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
    } STAT_GATED_CLK_b;
  } ;
  
  union {
    __IOM uint32_t MCU_ROOT_REQ_BYP;            /*!< (@ 0x00000020) Control over root clock gating - HW or SW                  */
    
    struct {
      __IOM uint32_t ROOT_SW_MCU : 1;           /*!< [0..0] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t ROOT_HW_MCU : 1;           /*!< [1..1] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t ROOT_AO_MCU : 1;           /*!< [2..2] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
            uint32_t            : 29;
    } MCU_ROOT_REQ_BYP_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK_REQ_BYP2;            /*!< (@ 0x00000024) Control over clock gating - HW or SW                       */
    
    struct {
      __IOM uint32_t MCU_SLOW_IF_CLKOUT : 1;    /*!< [0..0] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t MCU_CLKREG : 1;            /*!< [1..1] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
            uint32_t            : 30;
    } MCU_CLK_REQ_BYP2_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK_REQ_EN2;             /*!< (@ 0x00000028) SW clock request enable                                    */
    
    struct {
      __IOM uint32_t MCU_SLOW_IF_CLKOUT : 1;    /*!< [0..0] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t MCU_CLKREG : 1;            /*!< [1..1] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
            uint32_t            : 30;
    } MCU_CLK_REQ_EN2_b;
  } ;
  
  union {
    __IOM uint32_t STAT_GATED_CLK2;             /*!< (@ 0x0000002C) Clock gating status                                        */
    
    struct {
      __IM  uint32_t MCU_SLOW_IF_CLKOUT : 1;    /*!< [0..0] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t MCU_CLKREG : 1;            /*!< [1..1] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
            uint32_t            : 30;
    } STAT_GATED_CLK2_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t MCU_ROOT_REQ_EN;             /*!< (@ 0x00000034) SW root clock request enable                               */
    
    struct {
      __IOM uint32_t ROOT_SW_MCU : 1;           /*!< [0..0] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t ROOT_HW_MCU : 1;           /*!< [1..1] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t ROOT_AO_MCU : 1;           /*!< [2..2] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
            uint32_t            : 29;
    } MCU_ROOT_REQ_EN_b;
  } ;
  
  union {
    __IOM uint32_t STAT_GATED_ROOT;             /*!< (@ 0x00000038) Root clocks gating status                                  */
    
    struct {
      __IM  uint32_t SW         : 1;            /*!< [0..0] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t HW         : 1;            /*!< [1..1] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t AO         : 1;            /*!< [2..2] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
            uint32_t            : 29;
    } STAT_GATED_ROOT_b;
  } ;
  
  union {
    __IOM uint32_t PMG_SSX_MCU_CFG;             /*!< (@ 0x0000003C) PMG_SSX_MCU_CFG                                            */
    
    struct {
      __IOM uint32_t MCUREG_SONICS_CLK_CTRL_CNT_TARGET : 10;/*!< [9..0] Internal bus fabric clock control counter target - number
                                                     of cycles from no activity to request to start clock gating
                                                     flow                                                                      */
            uint32_t            : 22;
    } PMG_SSX_MCU_CFG_b;
  } ;
  
  union {
    __IOM uint32_t USER_TIMER_CLK_CFG;          /*!< (@ 0x00000040) USER_TIMER_CLK_CFG                                         */
    
    struct {
      __IOM uint32_t TIMERS_CLK_SELECT : 4;     /*!< [3..0] User timer module - clock source select per timer group:0
                                                     - clk 32K1 - mcuclk (can be also 32K sync with mcuclk and
                                                     phased aligned to the clk 32K)                                            */
            uint32_t            : 28;
    } USER_TIMER_CLK_CFG_b;
  } ;
  
  union {
    __IOM uint32_t USER_TIMER_CLK_REQ_BYP;      /*!< (@ 0x00000044) Control over clock gating - HW or SW                       */
    
    struct {
      __IOM uint32_t USER_TIMER0 : 1;           /*!< [0..0] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER1 : 1;           /*!< [1..1] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER2 : 1;           /*!< [2..2] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER3 : 1;           /*!< [3..3] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER0_CLK32K : 1;    /*!< [4..4] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER1_CLK32K : 1;    /*!< [5..5] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER2_CLK32K : 1;    /*!< [6..6] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER3_CLK32K : 1;    /*!< [7..7] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER_FREE_PCLK : 1;  /*!< [8..8] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
      __IOM uint32_t USER_TIMER_PCLK : 1;       /*!< [9..9] Clock gating source select 0 - HW control (by HW Clock
                                                     request element)1 - SW control (by register)                              */
            uint32_t            : 22;
    } USER_TIMER_CLK_REQ_BYP_b;
  } ;
  
  union {
    __IOM uint32_t USER_TIMER_CLK_REQ_EN;       /*!< (@ 0x00000048) SW clock request enable                                    */
    
    struct {
      __IOM uint32_t USER_TIMER0 : 1;           /*!< [0..0] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER1 : 1;           /*!< [1..1] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER2 : 1;           /*!< [2..2] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER3 : 1;           /*!< [3..3] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER0_CLK32K : 1;    /*!< [4..4] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER1_CLK32K : 1;    /*!< [5..5] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER2_CLK32K : 1;    /*!< [6..6] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER3_CLK32K : 1;    /*!< [7..7] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER_FREE_PCLK : 1;  /*!< [8..8] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
      __IOM uint32_t USER_TIMER_PCLK : 1;       /*!< [9..9] Clock gating when in SW contol clock0 - SW Control Clock
                                                     Disable1 - SW Control Clock Enable                                        */
            uint32_t            : 22;
    } USER_TIMER_CLK_REQ_EN_b;
  } ;
  
  union {
    __IOM uint32_t USER_TIMER_STAT_GATED_CLK;   /*!< (@ 0x0000004C) Clock gating status                                        */
    
    struct {
      __IM  uint32_t USER_TIMER0 : 1;           /*!< [0..0] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER1 : 1;           /*!< [1..1] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER2 : 1;           /*!< [2..2] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER3 : 1;           /*!< [3..3] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER0_CLK32K : 1;    /*!< [4..4] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER1_CLK32K : 1;    /*!< [5..5] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER2_CLK32K : 1;    /*!< [6..6] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER3_CLK32K : 1;    /*!< [7..7] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER_FREE_PCLK : 1;  /*!< [8..8] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
      __IM  uint32_t USER_TIMER_PCLK : 1;       /*!< [9..9] Clock gating status0 - Clock is gated (clock is disabled)1
                                                     - Clock is not gated (clock is enabled)                                   */
            uint32_t            : 22;
    } USER_TIMER_STAT_GATED_CLK_b;
  } ;
} CLK_CONTROL_Type;                             /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                        RST_CONTROL                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief MCU's modules reset control (RST_CONTROL)
  */

typedef struct {                                /*!< (@ 0x01530000) RST_CONTROL Structure                                      */
  
  union {
    __IOM uint32_t REG_SET;                     /*!< (@ 0x00000000) Writing to this register asserts reset signal
                                                                    of appropriate device/engine                               */
    
    struct {
      __OM  uint32_t RESET_LED  : 1;            /*!< [0..0] RESET LED                                                          */
      __OM  uint32_t RESET_PCM  : 1;            /*!< [1..1] RESET PCM                                                          */
      __OM  uint32_t RESET_TIMERS : 1;          /*!< [2..2] RESET TIMERS                                                       */
      __OM  uint32_t RESET_DEBUG : 1;           /*!< [3..3] RESET DEBUG                                                        */
      __OM  uint32_t RESET_SPI_MASTER0 : 1;     /*!< [4..4] RESET SPI MASTER0                                                  */
      __OM  uint32_t RESET_SPI_MASTER1 : 1;     /*!< [5..5] RESET SPI MASTER1                                                  */
      __OM  uint32_t RESET_SPI_SLAVE : 1;       /*!< [6..6] RESET SPI SLAVE                                                    */
      __OM  uint32_t RESET_UARTI0 : 1;          /*!< [7..7] RESET_UARTI0                                                       */
      __OM  uint32_t RESET_UARTI1 : 1;          /*!< [8..8] RESET_UARTI1                                                       */
      __OM  uint32_t RESET_UARTI2 : 1;          /*!< [9..9] RESET_UARTI2                                                       */
      __OM  uint32_t RESET_UARF0 : 1;           /*!< [10..10] RESET UARF0                                                      */
      __OM  uint32_t RESET_UARF1 : 1;           /*!< [11..11] RESET UARF1                                                      */
      __OM  uint32_t RESET_SF   : 1;            /*!< [12..12] RESET SF                                                         */
      __OM  uint32_t RESET_GDMA : 1;            /*!< [13..13] RESET GDMA                                                       */
      __OM  uint32_t RESET_I2C0 : 1;            /*!< [14..14] RESET I2C0                                                       */
      __OM  uint32_t RESET_I2C1 : 1;            /*!< [15..15] RESET I2C1                                                       */
      __OM  uint32_t RESET_GPIO : 1;            /*!< [16..16] RESET GPIO                                                       */
      __OM  uint32_t RESET_SIC  : 1;            /*!< [17..17] RESET SIC                                                        */
      __OM  uint32_t RESET_IOSEL : 1;           /*!< [18..18] RESET IOSEL                                                      */
      __OM  uint32_t RESET_USER_TIMER_N : 1;    /*!< [19..19] RESET_USER_TIMER_N                                               */
      __OM  uint32_t RESET_USER_TIMER_SOFT_N : 1;/*!< [20..20] RESET_USER_TIMER_SOFT_N                                         */
      __OM  uint32_t RESET_PWM  : 1;            /*!< [21..21] RESET PWM                                                        */
      __OM  uint32_t RESET_CLKOUT : 1;          /*!< [22..22] RESET_CLKOUT                                                     */
            uint32_t            : 9;
    } REG_SET_b;
  } ;
  
  union {
    __IOM uint32_t REG_CLR;                     /*!< (@ 0x00000004) Writing to this register de-asserts reset signal
                                                                    of appropriate device/engine                               */
    
    struct {
      __OM  uint32_t RESET_LED  : 1;            /*!< [0..0] RESET LED                                                          */
      __OM  uint32_t RESET_PCM  : 1;            /*!< [1..1] RESET PCM                                                          */
      __OM  uint32_t RESET_TIMERS : 1;          /*!< [2..2] RESET TIMERS                                                       */
      __OM  uint32_t RESET_DEBUG : 1;           /*!< [3..3] RESET DEBUG                                                        */
      __OM  uint32_t RESET_SPI_MASTER0 : 1;     /*!< [4..4] RESET SPI MASTER0                                                  */
      __OM  uint32_t RESET_SPI_MASTER1 : 1;     /*!< [5..5] RESET SPI MASTER1                                                  */
      __OM  uint32_t RESET_SPI_SLAVE : 1;       /*!< [6..6] RESET SPI SLAVE                                                    */
      __OM  uint32_t RESET_UARTI0 : 1;          /*!< [7..7] RESET_UARTI0                                                       */
      __OM  uint32_t RESET_UARTI1 : 1;          /*!< [8..8] RESET_UARTI1                                                       */
      __OM  uint32_t RESET_UARTI2 : 1;          /*!< [9..9] RESET_UARTI2                                                       */
      __OM  uint32_t RESET_UARF0 : 1;           /*!< [10..10] RESET UARF0                                                      */
      __OM  uint32_t RESET_UARF1 : 1;           /*!< [11..11] RESET UARF1                                                      */
      __OM  uint32_t RESET_SF   : 1;            /*!< [12..12] RESET SF                                                         */
      __OM  uint32_t RESET_GDMA : 1;            /*!< [13..13] RESET GDMA                                                       */
      __OM  uint32_t RESET_I2C0 : 1;            /*!< [14..14] RESET I2C0                                                       */
      __OM  uint32_t RESET_I2C1 : 1;            /*!< [15..15] RESET I2C1                                                       */
      __OM  uint32_t RESET_GPIO : 1;            /*!< [16..16] RESET GPIO                                                       */
      __OM  uint32_t RESET_SIC  : 1;            /*!< [17..17] RESET SIC                                                        */
      __OM  uint32_t RESET_IOSEL : 1;           /*!< [18..18] RESET IOSEL                                                      */
      __OM  uint32_t RESET_USER_TIMER_N : 1;    /*!< [19..19] RESET_USER_TIMER_N                                               */
      __OM  uint32_t RESET_USER_TIMER_SOFT_N : 1;/*!< [20..20] RESET_USER_TIMER_SOFT_N                                         */
      __OM  uint32_t RESET_PWM  : 1;            /*!< [21..21] RESET PWM                                                        */
      __OM  uint32_t RESET_CLKOUT : 1;          /*!< [22..22] RESET_CLKOUT                                                     */
            uint32_t            : 9;
    } REG_CLR_b;
  } ;
  
  union {
    __IOM uint32_t REG;                         /*!< (@ 0x00000008) MCU Reset Register 0: reset set to 0 (reset deasserted)
                                                                    1: reset set to 1 (reset asserted)                         */
    
    struct {
      __IOM uint32_t RESET_LED  : 1;            /*!< [0..0] RESET LED                                                          */
      __IOM uint32_t RESET_PCM  : 1;            /*!< [1..1] RESET PCM                                                          */
      __IOM uint32_t RESET_TIMERS : 1;          /*!< [2..2] RESET TIMERS                                                       */
      __IOM uint32_t RESET_DEBUG : 1;           /*!< [3..3] RESET DEBUG                                                        */
      __IOM uint32_t RESET_SPI_MASTER0 : 1;     /*!< [4..4] RESET SPI MASTER0                                                  */
      __IOM uint32_t RESET_SPI_MASTER1 : 1;     /*!< [5..5] RESET SPI MASTER1                                                  */
      __IOM uint32_t RESET_SPI_SLAVE : 1;       /*!< [6..6] RESET SPI SLAVE                                                    */
      __IOM uint32_t RESET_UARTI0 : 1;          /*!< [7..7] RESET_UARTI0                                                       */
      __IOM uint32_t RESET_UARTI1 : 1;          /*!< [8..8] RESET_UARTI1                                                       */
      __IOM uint32_t RESET_UARTI2 : 1;          /*!< [9..9] RESET_UARTI2                                                       */
      __IOM uint32_t RESET_UARF0 : 1;           /*!< [10..10] RESET UARF0                                                      */
      __IOM uint32_t RESET_UARF1 : 1;           /*!< [11..11] RESET UARF1                                                      */
      __IOM uint32_t RESET_SF   : 1;            /*!< [12..12] RESET SF                                                         */
      __IOM uint32_t RESET_GDMA : 1;            /*!< [13..13] RESET GDMA                                                       */
      __IOM uint32_t RESET_I2C0 : 1;            /*!< [14..14] RESET I2C0                                                       */
      __IOM uint32_t RESET_I2C1 : 1;            /*!< [15..15] RESET I2C1                                                       */
      __IOM uint32_t RESET_GPIO : 1;            /*!< [16..16] RESET GPIO                                                       */
      __IOM uint32_t RESET_SIC  : 1;            /*!< [17..17] RESET SIC                                                        */
      __IOM uint32_t RESET_IOSEL : 1;           /*!< [18..18] RESET IOSEL                                                      */
      __IOM uint32_t RESET_USER_TIMER_N : 1;    /*!< [19..19] RESET_USER_TIMER_N                                               */
      __IOM uint32_t RESET_USER_TIMER_SOFT_N : 1;/*!< [20..20] RESET_USER_TIMER_SOFT_N                                         */
      __IOM uint32_t RESET_PWM  : 1;            /*!< [21..21] RESET PWM                                                        */
      __IOM uint32_t RESET_CLKOUT : 1;          /*!< [22..22] RESET_CLKOUT                                                     */
            uint32_t            : 9;
    } REG_b;
  } ;
} RST_CONTROL_Type;                             /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                         PERF_CNTR                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Processor sleep and I-Cache performance counters (PERF_CNTR)
  */

typedef struct {                                /*!< (@ 0x01550000) PERF_CNTR Structure                                        */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CTRL                                                       */
    
    struct {
      __IOM uint32_t CNT1_SEL   : 4;            /*!< [3..0] Select event to count:0: I-Cache hit event 1: I-Cache
                                                     miss event (counted once per miss)2: I-Cache miss status
                                                     event (counted for each cycle the cache is in miss state)3:
                                                     M4 Current interrupt priority equals 04: M4 Current interrupt
                                                     priority equals 15: M4 Current interrupt priority equals
                                                     26: M4 Current interrupt priority equals 37: M4 sleeping                  */
      __IOM uint32_t CNT0_SEL   : 4;            /*!< [7..4] Select event to count:0: I-Cache hit event 1: I-Cache
                                                     miss event (counted once per miss)2: I-Cache miss status
                                                     event (counted for each cycle the cache is in miss state)3:
                                                     M4 Current interrupt priority equals 04: M4 Current interrupt
                                                     priority equals 15: M4 Current interrupt priority equals
                                                     26: M4 Current interrupt priority equals 37: M4 sleeping                  */
      __OM  uint32_t CLEAR      : 1;            /*!< [8..8] Set this bit to a value of 1 to clear the counters. The
                                                     bit itself will be cleared by the HW.                                     */
      __IOM uint32_t ENABLE     : 1;            /*!< [9..9] Enable the counters                                                */
            uint32_t            : 22;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CNT0;                        /*!< (@ 0x00000004) Counter 0 value                                            */
    
    struct {
      __IM  uint32_t CNT0       : 32;           /*!< [31..0] CNT0                                                              */
    } CNT0_b;
  } ;
  
  union {
    __IOM uint32_t CNT1;                        /*!< (@ 0x00000008) Counter 1 value                                            */
    
    struct {
      __IM  uint32_t CNT1       : 32;           /*!< [31..0] CNT1                                                              */
    } CNT1_b;
  } ;
  
  union {
    __IOM uint32_t M4_PC;                       /*!< (@ 0x0000000C) M4 program counter current value                           */
    
    struct {
      __IM  uint32_t M4_PC      : 32;           /*!< [31..0] M4_PC                                                             */
    } M4_PC_b;
  } ;
  
  union {
    __IOM uint32_t M4_CUR_PRIO;                 /*!< (@ 0x00000010) M4 current interrupt priority                              */
    
    struct {
      __IM  uint32_t M4_CUR_PRIO : 8;           /*!< [7..0] M4_CUR_PRIO                                                        */
            uint32_t            : 24;
    } M4_CUR_PRIO_b;
  } ;
} PERF_CNTR_Type;                               /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                          REGFILE                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Other MCU configuration registers (REGFILE)
  */

typedef struct {                                /*!< (@ 0x01560000) REGFILE Structure                                          */
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ICACHE_CTRL;                 /*!< (@ 0x00000004) ICACHE_CTRL                                                */
    
    struct {
      __OM  uint32_t ICACHE_INVALIDATE : 1;     /*!< [0..0] write-only register bit to invalidate icache tag memory            */
            uint32_t            : 31;
    } ICACHE_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t PWR_ON_ACK_SETTING;          /*!< (@ 0x00000008) PWR_ON_ACK_SETTING                                         */
    
    struct {
      __IOM uint32_t DIRECT_SETTING : 1;        /*!< [0..0] control over the power-on-ack signal coming to the Cortex
                                                     M4 - direct setting (see SELECT register)0: ack = 01: ack
                                                     = 1 (default as in the RTL before the change)                             */
      __IOM uint32_t SELECT     : 1;            /*!< [1..1] control over the power-on-ack signal coming to Cortex
                                                     M4 - select0 - loopback the power-on-req signal1 - use
                                                     the value from 'direct_setting' bit                                       */
            uint32_t            : 30;
    } PWR_ON_ACK_SETTING_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t HPROT_CFG;                   /*!< (@ 0x00000010) HPROT_CFG                                                  */
    
    struct {
      __IOM uint32_t AHB_PROG_PROT2_VAL : 1;    /*!< [0..0] hprot[2] of AHB PROG port to SSX value if SEL is '1'               */
      __IOM uint32_t AHB_PROG_PROT2_SEL : 1;    /*!< [1..1] set the hprot[2] bit of the AHB port of PROG master on
                                                     the bus fabric to the value VAL                                           */
      __IOM uint32_t AHB_SYS2SSX_PROT2_VAL : 1; /*!< [2..2] hprot[2] of AHB SYS port to SSX value if SEL is '1'                */
      __IOM uint32_t AHB_SYS2SSX_PROT2_SEL : 1; /*!< [3..3] set the hprot[2] bit of the AHB port of SYS master on
                                                     the bus fabric to the value VAL                                           */
      __IOM uint32_t AHB_MSE_DPORT_PROT2_VAL : 1;/*!< [4..4] hprot[2] of AHB MSE D port to SSX value if SEL is '1'             */
      __IOM uint32_t AHB_MSE_DPORT_PROT2_SEL : 1;/*!< [5..5] set the hprot[2] bit of the AHB port of MSE-D master
                                                     on the bus fabric to the value VAL                                        */
            uint32_t            : 26;
    } HPROT_CFG_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t MCU_SW_RESET_REQ;            /*!< (@ 0x00000018) reset request from MCU to PMP. Those 8 bits are
                                                                    part of 'mcu_status' register in gsp_regfile
                                                                    which trigger interrupt to PMP when is not
                                                                    '0'                                                        */
    
    struct {
      __IOM uint32_t MCU_SW_RESET_REQ : 8;      /*!< [7..0] MCU_SW_RESET_REQ                                                   */
            uint32_t            : 24;
    } MCU_SW_RESET_REQ_b;
  } ;
  
  union {
    __IOM uint32_t MCU_STATUS;                  /*!< (@ 0x0000001C) MCU Status Register                                        */
    
    struct {
      __IM  uint32_t SW_RST_REQ : 8;            /*!< [7..0] sw rst request (see MCU_SW_RESET_REQ register)                     */
      __IM  uint32_t M4_LOCKUP  : 1;            /*!< [8..8] cortex-m4 in lockup state                                          */
      __IM  uint32_t M4_SYSRSTREQ : 1;          /*!< [9..9] cortex-m4 requested system reset                                   */
      __IM  uint32_t M4_HALTED  : 1;            /*!< [10..10] cortex-m4 halted                                                 */
      __IM  uint32_t M4_DEBUG_MODE : 1;         /*!< [11..11] cortex-m4 in debug mode                                          */
      __IM  uint32_t SIC_FAIL   : 1;            /*!< [12..12] sic authentication failure                                       */
      __IM  uint32_t MCU_WD     : 1;            /*!< [13..13] mcu watchdog trigger                                             */
      __IM  uint32_t MCU_USER_TIMER : 1;        /*!< [14..14] mcu user timer interrupt                                         */
            uint32_t            : 17;
    } MCU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t MCU_STATUS_MASK_NMI;         /*!< (@ 0x00000020) Mask Status register to NMI                                */
    
    struct {
      __IOM uint32_t MCU_STATUS_MASK_NMI : 16;  /*!< [15..0] NMI for the Cortex M4 is given if one of the bits of
                                                     MCU_STATUS is 1 after masking.This register configures
                                                     the masking:0 - masked1 - not masked                                      */
            uint32_t            : 16;
    } MCU_STATUS_MASK_NMI_b;
  } ;
  
  union {
    __IOM uint32_t MCU_STATUS_MASK_PMP;         /*!< (@ 0x00000024) Mask Status register to PMP                                */
    
    struct {
      __IOM uint32_t MCU_STATUS_MASK_PMP : 16;  /*!< [15..0] Interrupt to the PMP processor is given if one of the
                                                     bits of MCU_STATUS is 1 after masking.This register configures
                                                     the masking:0 - masked1 - not masked                                      */
            uint32_t            : 16;
    } MCU_STATUS_MASK_PMP_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t MCU_DMA_HANDSHAKE;           /*!< (@ 0x00000038) mcu dma handshake settings                                 */
    
    struct {
      __IOM uint32_t CFG_SELECT : 2;            /*!< [1..0] CFG_SELECT                                                         */
      __IOM uint32_t SELECT     : 3;            /*!< [4..2] Select between ext_dma_rdy0-ext_dma_rdy4 (see functional
                                                     IO muxing table); selection is used as ready signal to
                                                     GDMA from external device.Option 7 selects a constant zero                */
            uint32_t            : 27;
    } MCU_DMA_HANDSHAKE_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK32K_EDGE_INT_STAT;    /*!< (@ 0x0000003C) MCU_CLK32K_EDGE_INT_STAT                                   */
    
    struct {
      __IM  uint32_t MCU_CLK32K_EDGE_INT_STAT : 1;/*!< [0..0] 32khz clock edge interrupt status                                */
            uint32_t            : 31;
    } MCU_CLK32K_EDGE_INT_STAT_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK32K_EDGE_INT_RC;      /*!< (@ 0x00000040) MCU_CLK32K_EDGE_INT_RC                                     */
    
    struct {
      __IM  uint32_t MCU_CLK32K_EDGE_INT_RC : 1;/*!< [0..0] read and clear 32khz clock edge interrupt status                   */
            uint32_t            : 31;
    } MCU_CLK32K_EDGE_INT_RC_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK32K_EDGE_INT_EN;      /*!< (@ 0x00000044) MCU_CLK32K_EDGE_INT_EN                                     */
    
    struct {
      __IOM uint32_t MCU_CLK32K_EDGE_INT_EN : 1;/*!< [0..0] Enables interrupt on 32khz clock edge. Interrupt will
                                                     be given when rising edge of the 32k clock is detected                    */
            uint32_t            : 31;
    } MCU_CLK32K_EDGE_INT_EN_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t UART0_WAKEUP_CFG;            /*!< (@ 0x00000050) UART0_WAKEUP_CFG                                           */
    
    struct {
      __IOM uint32_t UART_WAKEUP_EN : 1;        /*!< [0..0] Enables wakeup from UART                                           */
            uint32_t            : 31;
    } UART0_WAKEUP_CFG_b;
  } ;
  
  union {
    __IOM uint32_t UART0_WAKEUP_STAT;           /*!< (@ 0x00000054) UART0_WAKEUP_STAT                                          */
    
    struct {
      __IM  uint32_t UART_WAKEUP : 1;           /*!< [0..0] UART wakeup status                                                 */
            uint32_t            : 31;
    } UART0_WAKEUP_STAT_b;
  } ;
  
  union {
    __IOM uint32_t UART0_WAKEUP_RC;             /*!< (@ 0x00000058) UART0_WAKEUP_RC                                            */
    
    struct {
      __IOM uint32_t UART_WAKEUP : 1;           /*!< [0..0] Reads and clear UART wakeup status                                 */
            uint32_t            : 31;
    } UART0_WAKEUP_RC_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t UART1_WAKEUP_CFG;            /*!< (@ 0x00000060) UART1_WAKEUP_CFG                                           */
    
    struct {
      __IOM uint32_t UART_WAKEUP_EN : 1;        /*!< [0..0] Enables wakeup from UART                                           */
            uint32_t            : 31;
    } UART1_WAKEUP_CFG_b;
  } ;
  
  union {
    __IOM uint32_t UART1_WAKEUP_STAT;           /*!< (@ 0x00000064) UART1_WAKEUP_STAT                                          */
    
    struct {
      __IM  uint32_t UART_WAKEUP : 1;           /*!< [0..0] UART wakeup status                                                 */
            uint32_t            : 31;
    } UART1_WAKEUP_STAT_b;
  } ;
  
  union {
    __IOM uint32_t UART1_WAKEUP_RC;             /*!< (@ 0x00000068) UART1_WAKEUP_RC                                            */
    
    struct {
      __IOM uint32_t UART_WAKEUP : 1;           /*!< [0..0] Reads and clear UART wakeup status                                 */
            uint32_t            : 31;
    } UART1_WAKEUP_RC_b;
  } ;
} REGFILE_Type;                                 /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                       GP_TIMER_CTRL                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timer (GP_TIMER_CTRL)
  */

typedef struct {                                /*!< (@ 0x01580000) GP_TIMER_CTRL Structure                                    */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CTRL                                                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] 0: timer disabled; 1: timer enabled                                */
            uint32_t            : 31;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t PRESET_VALUE;                /*!< (@ 0x00000004) PRESET_VALUE                                               */
    
    struct {
      __IOM uint32_t PRESET_VALUE : 32;         /*!< [31..0] Value to load to the GP timer                                     */
    } PRESET_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t UPDT_OFFSET;                 /*!< (@ 0x00000008) UPDT_OFFSET                                                */
    
    struct {
      __IOM uint32_t OFFSET_VALUE : 32;         /*!< [31..0] This value is added to the GP timer                               */
    } UPDT_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t VALUE;                       /*!< (@ 0x0000000C) VALUE                                                      */
    
    struct {
      __IM  uint32_t VALUE      : 32;           /*!< [31..0] GP timer current value for reading                                */
    } VALUE_b;
  } ;
  
  union {
    __IOM uint32_t INT;                         /*!< (@ 0x00000010) INT                                                        */
    
    struct {
      __IM  uint32_t INT        : 1;            /*!< [0..0] Holds interrupt status until the SW disable the interrupt
                                                     or write a new target value that doesn&#8217;t match 0:
                                                     interrupt inactive 1: Interrupt active                                    */
            uint32_t            : 31;
    } INT_b;
  } ;
} GP_TIMER_CTRL_Type;                           /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            NCO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose NCO
The MCU NCO is a 16bits accumulator that for each clock cycle the MCU_NCO_RATE is added; 
when the MCU_NCO reaches or pass the MCU_NCO_WRAP_VALUE; it generates an output tick. (NCO)
  */

typedef struct {                                /*!< (@ 0x015B0000) NCO Structure                                              */
  
  union {
    __IOM uint32_t CFG;                         /*!< (@ 0x00000000) CFG                                                        */
    
    struct {
      __IOM uint32_t MCU_NCO_RATE : 16;         /*!< [15..0] the value added to the NCO each clock cycle.This value
                                                     defines the NCO target frequency according to the following
                                                     fomula:target_rate = nco_clock * (nco_rate / wrap_value)                  */
      __IOM uint32_t MCU_NCO_ENABLE : 1;        /*!< [16..16] 0: NCO is disabled.1: NCO is enabled                             */
            uint32_t            : 15;
    } CFG_b;
  } ;
  
  union {
    __IOM uint32_t WRAP_VALUE;                  /*!< (@ 0x00000004) WRAP_VALUE                                                 */
    
    struct {
      __IOM uint32_t WRAP_VALUE : 17;           /*!< [16..0] The NCO generates a tick each time it&#8217;s accumulator
                                                     is bigger then the wrap value. This value defines the target
                                                     NCO frequency according to the following fomula:target_rate
                                                     = nco_clock * (nco_rate / wrap_value)Configure other value
                                                     rather then the default 0x10000 wrap value allows more
                                                     accurate ticks periods by finding wrap_value and nco_rate
                                                     numbers which are integers                                                */
            uint32_t            : 15;
    } WRAP_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t ACC_VALUE;                   /*!< (@ 0x00000008) ACC_VALUE                                                  */
    
    struct {
      __IM  uint32_t ACC_VALUE  : 16;           /*!< [15..0] Current NCO timer value for reading                               */
            uint32_t            : 16;
    } ACC_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t ACC_LOAD_VALUE;              /*!< (@ 0x0000000C) ACC_LOAD_VALUE                                             */
    
    struct {
      __IOM uint32_t ACC_LOAD_VALUE : 16;       /*!< [15..0] Write to this register loads the NCO timer by the given
                                                     value                                                                     */
            uint32_t            : 16;
    } ACC_LOAD_VALUE_b;
  } ;
} NCO_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                       SLEEP_TIMERS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Timers Halt/Recover for sleep modes (SLEEP_TIMERS)
  */

typedef struct {                                /*!< (@ 0x015C0000) SLEEP_TIMERS Structure                                     */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CTRL                                                       */
    
    struct {
      __OM  uint32_t HALT_TIMERS : 1;           /*!< [0..0] Command to safely halt timers before entering sleep mode.
                                                     Timers and NCO&#8217;s will halt at next 32KHz clock boundary.
                                                     The HW reset this bit after halt is done.                                 */
      __OM  uint32_t RECOVER_TIMERS : 1;        /*!< [1..1] Command to safely continue timers operation after going
                                                     out from sleep mode. Timers will start counting at next
                                                     32KHz clock boundary. The HW reset this bit after recover
                                                     is done.                                                                  */
      __OM  uint32_t STALL_TIMERS : 1;          /*!< [2..2] Command to halt timers as if they were in sleep mode.
                                                     Timers and NCO&#8217;s will halt immediatly. The HW reset
                                                     this bit after halt is done.                                              */
      __IOM uint32_t TIMERS_HALT_DONE : 1;      /*!< [3..3] Indication that timers halt sequence is completed and
                                                     FW can continue power down sequence                                       */
      __IOM uint32_t TIMERS_RECOVER_DONE : 1;   /*!< [4..4] Indication that timers recovery sequence is completed;
                                                     and timers are operational                                                */
            uint32_t            : 27;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MASK_CTRL;                   /*!< (@ 0x00000004) MASK_CTRL                                                  */
    
    struct {
      __IOM uint32_t MCU_TIMERS_MASK : 2;       /*!< [1..0] chooses which timers will be halt/recovered by the 32KHz
                                                     RTC timerthis register controls whether each timer receives
                                                     the halt/recover strobe from the 32khz alignment machine.0
                                                     - the timer will receive the strobe from this machine1
                                                     - the timer will not receive the strobe from this machine[0]
                                                     - MCU GP TIMER + NCO[1] - MCU SHADOW 32K TIMER                            */
            uint32_t            : 30;
    } MASK_CTRL_b;
  } ;
} SLEEP_TIMERS_Type;                            /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                      SLOW_IF_CLKOUT                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock controller for output to IO (SLOW_IF_CLKOUT)
  */

typedef struct {                                /*!< (@ 0x016D0000) SLOW_IF_CLKOUT Structure                                   */
  
  union {
    __IOM uint32_t CLKOUT_CFG;                  /*!< (@ 0x00000000) CLKOUT_CFG                                                 */
    
    struct {
      __IOM uint32_t SLOW_IF_CLKOUT_GRACEFUL_STOP_EN : 1;/*!< [0..0] 1 - when clock is disabled - stop gracefully at the configured
                                                     default value of the clock0 - when clock is disabled -
                                                     stop immediately and keep current output value                            */
      __IOM uint32_t SLOW_IF_CLKOUT_DEFAULT_HIGH : 1;/*!< [1..1] default value of the output clock when not running            */
            uint32_t            : 30;
    } CLKOUT_CFG_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT_EN;                   /*!< (@ 0x00000004) CLKOUT_EN                                                  */
    
    struct {
      __IOM uint32_t CLKOUT_EN  : 1;            /*!< [0..0] 1 - clock is enabled and running0 - clock is stopped
                                                     (either immediately or if graceful stop is configured will
                                                     be stopped at the default value)                                          */
            uint32_t            : 31;
    } CLKOUT_EN_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT_MAX_CNT;              /*!< (@ 0x00000008) CLKOUT_MAX_CNT                                             */
    
    struct {
      __IOM uint32_t CLKOUT_MAX_CNT : 32;       /*!< [31..0] Maximum value of the NCO counter. Used with the RATE
                                                     reg in order to define the clock output.When this register
                                                     equals RATE reg - the clock output frequency is the system
                                                     clock/2                                                                   */
    } CLKOUT_MAX_CNT_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT_RATE;                 /*!< (@ 0x0000000C) CLKOUT_RATE                                                */
    
    struct {
      __IOM uint32_t CLKOUT_RATE : 32;          /*!< [31..0] Rate of the NCO - the step size of counter. Used with
                                                     the MAX_CNT reg in order to define the clock.When step
                                                     size equals MAX_CNT - the clock output frequency is the
                                                     system clock/2Minimum value is 1 (for a configuration of
                                                     0 the clock will not toggle)                                              */
    } CLKOUT_RATE_b;
  } ;
  
  union {
    __IOM uint32_t SEL_EXT_CLK;                 /*!< (@ 0x00000010) SEL_EXT_CLK                                                */
    
    struct {
      __IOM uint32_t SEL_EXT_CLK : 1;           /*!< [0..0] Select external clock instead of the clock generated
                                                     by the NCO:0: output of the module is the clock generated
                                                     by the NCO1: output of the module is MCU_PLL output                       */
            uint32_t            : 31;
    } SEL_EXT_CLK_b;
  } ;
} SLOW_IF_CLKOUT_Type;                          /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                        USER_TIMERS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief User Timer module (USER_TIMERS)
  */

typedef struct {                                /*!< (@ 0x00105000) USER_TIMERS Structure                                      */
  
  union {
    __IOM uint32_t IDCODE_PERIPHERAL;           /*!< (@ 0x00000000) IDCODE_PERIPHERAL                                          */
    
    struct {
      __IM  uint32_t IDCODE_PERIPHERAL : 32;    /*!< [31..0] Peripheral&#160;unique&#160;id&#160;code                          */
    } IDCODE_PERIPHERAL_b;
  } ;
  
  union {
    __IOM uint32_t IDCODE_INSTANCE;             /*!< (@ 0x00000004) IDCODE_INSTANCE                                            */
    
    struct {
      __IM  uint32_t IDCODE_INSTANCE : 32;      /*!< [31..0] Instance&#160;unique&#160;id&#160;code                            */
    } IDCODE_INSTANCE_b;
  } ;
  
  union {
    __IOM uint32_t IDCODE_REVISION;             /*!< (@ 0x00000008) IDCODE_REVISION                                            */
    
    struct {
      __IM  uint32_t USER_TIMER_IDCODE_REVISION_SUB : 16;/*!< [15..0] Sub&#160;revision&#160;number                            */
      __IM  uint32_t USER_TIMER_IDCODE_REVISION_MAIN : 16;/*!< [31..16] Main&#160;revision&#160;number                         */
    } IDCODE_REVISION_b;
  } ;
  
  union {
    __IOM uint32_t IDCODE_SVN;                  /*!< (@ 0x0000000C) IDCODE_SVN                                                 */
    
    struct {
      __IM  uint32_t IDCODE_SVN : 32;           /*!< [31..0] Subversion&#160;release&#160;number                               */
    } IDCODE_SVN_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_CONFIG;              /*!< (@ 0x00000010) CONTROL_CONFIG                                             */
    
    struct {
      __IOM uint32_t CONTROL_CONFIG_LOOP_MODE : 1;/*!< [0..0] Loop&#160;back&#160;mode                                         */
            uint32_t            : 31;
    } CONTROL_CONFIG_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_OR_OUT0;             /*!< (@ 0x00000014) CONTROL_OR_OUT0                                            */
    
    struct {
      __IOM uint32_t CONTROL_OR_OUT0 : 4;       /*!< [3..0] Output&#160;0&#160;OR&#160;function&#160;configuration             */
            uint32_t            : 28;
    } CONTROL_OR_OUT0_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_OR_OUT1;             /*!< (@ 0x00000018) CONTROL_OR_OUT1                                            */
    
    struct {
      __IOM uint32_t CONTROL_OR_OUT1 : 4;       /*!< [3..0] Output&#160;1&#160;OR&#160;function&#160;configuration             */
            uint32_t            : 28;
    } CONTROL_OR_OUT1_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_OR_OUT2;             /*!< (@ 0x0000001C) CONTROL_OR_OUT2                                            */
    
    struct {
      __IOM uint32_t CONTROL_OR_OUT2 : 4;       /*!< [3..0] Output&#160;2&#160;OR&#160;function&#160;configuration             */
            uint32_t            : 28;
    } CONTROL_OR_OUT2_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_OR_OUT3;             /*!< (@ 0x00000020) CONTROL_OR_OUT3                                            */
    
    struct {
      __IOM uint32_t CONTROL_OR_OUT3 : 4;       /*!< [3..0] Output&#160;3&#160;OR&#160;function&#160;configuration             */
            uint32_t            : 28;
    } CONTROL_OR_OUT3_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_DEBOUNCE_INPUT0;     /*!< (@ 0x00000024) CONTROL_DEBOUNCE_INPUT0                                    */
    
    struct {
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT0_LEVEL : 3;/*!< [2..0] debounce levelExplicit values are :  0x1 = match_periods_2
                                                     0x2 = match_periods_3 0x3 = match_periods_4 0x4 = match_periods_5
                                                     0x5 = match_periods_6 0x6 = match_periods_7 0x7 = match_periods_8
                                                     0x0 = no_debounce                                                         */
            uint32_t            : 13;
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT0_CLOCK : 2;/*!< [17..16] debounce&#160;clock&#160;selectionExplicit values are
                                                     :  0x0 = clock1 0x1 = clock2 0x2 = clock3 0x3 = clock4                    */
            uint32_t            : 14;
    } CONTROL_DEBOUNCE_INPUT0_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_DEBOUNCE_INPUT1;     /*!< (@ 0x00000028) CONTROL_DEBOUNCE_INPUT1                                    */
    
    struct {
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT1_LEVEL : 3;/*!< [2..0] debounce levelExplicit values are :  0x1 = match_periods_2
                                                     0x2 = match_periods_3 0x3 = match_periods_4 0x4 = match_periods_5
                                                     0x5 = match_periods_6 0x6 = match_periods_7 0x7 = match_periods_8
                                                     0x0 = no_debounce                                                         */
            uint32_t            : 13;
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT1_CLOCK : 2;/*!< [17..16] debounce&#160;clock&#160;selectionExplicit values are
                                                     :  0x0 = clock1 0x1 = clock2 0x2 = clock3 0x3 = clock4                    */
            uint32_t            : 14;
    } CONTROL_DEBOUNCE_INPUT1_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_DEBOUNCE_INPUT2;     /*!< (@ 0x0000002C) CONTROL_DEBOUNCE_INPUT2                                    */
    
    struct {
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT2_LEVEL : 3;/*!< [2..0] debounce levelExplicit values are :  0x1 = match_periods_2
                                                     0x2 = match_periods_3 0x3 = match_periods_4 0x4 = match_periods_5
                                                     0x5 = match_periods_6 0x6 = match_periods_7 0x7 = match_periods_8
                                                     0x0 = no_debounce                                                         */
            uint32_t            : 13;
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT2_CLOCK : 2;/*!< [17..16] debounce&#160;clock&#160;selectionExplicit values are
                                                     :  0x0 = clock1 0x1 = clock2 0x2 = clock3 0x3 = clock4                    */
            uint32_t            : 14;
    } CONTROL_DEBOUNCE_INPUT2_b;
  } ;
  
  union {
    __IOM uint32_t CONTROL_DEBOUNCE_INPUT3;     /*!< (@ 0x00000030) CONTROL_DEBOUNCE_INPUT3                                    */
    
    struct {
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT3_LEVEL : 3;/*!< [2..0] debounce levelExplicit values are :  0x1 = match_periods_2
                                                     0x2 = match_periods_3 0x3 = match_periods_4 0x4 = match_periods_5
                                                     0x5 = match_periods_6 0x6 = match_periods_7 0x7 = match_periods_8
                                                     0x0 = no_debounce                                                         */
            uint32_t            : 13;
      __IOM uint32_t USER_TIMER_CONTROL_DEBOUNCE_INPUT3_CLOCK : 2;/*!< [17..16] debounce&#160;clock&#160;selectionExplicit values are
                                                     :  0x0 = clock1 0x1 = clock2 0x2 = clock3 0x3 = clock4                    */
            uint32_t            : 14;
    } CONTROL_DEBOUNCE_INPUT3_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_CTRL;                 /*!< (@ 0x00000034) TIMER0_CTRL                                                */
    
    struct {
      __IM  uint32_t USER_TIMER_TIMER0_CTRL_LOAD_TIMER : 1;/*!< [0..0] Load&#160;timer&#160;command                            */
      __IOM uint32_t USER_TIMER_TIMER0_CTRL_ENABLE : 1;/*!< [1..1] Timer&#160;enable                                           */
      __IOM uint32_t USER_TIMER_TIMER0_CTRL_TIMER_MODE : 2;/*!< [3..2] Timer&#160;mode                                         */
            uint32_t            : 28;
    } TIMER0_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_COUNTER;              /*!< (@ 0x00000038) TIMER0_COUNTER                                             */
    
    struct {
      __IOM uint32_t TIMER0_COUNTER : 16;       /*!< [15..0] Counter&#160;load&#160;value&#160;register                        */
            uint32_t            : 16;
    } TIMER0_COUNTER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_PRESCALER;            /*!< (@ 0x0000003C) TIMER0_PRESCALER                                           */
    
    struct {
      __IOM uint32_t TIMER0_PRESCALER : 16;     /*!< [15..0] Prescaler&#160;load&#160;value&#160;register                      */
            uint32_t            : 16;
    } TIMER0_PRESCALER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_SW_IT;                /*!< (@ 0x00000040) TIMER0_SW_IT                                               */
    
    struct {
      __IOM uint32_t TIMER0_SW_IT : 32;         /*!< [31..0] Timer&#160;software&#160;interrupt&#160;configuration&#160;register */
    } TIMER0_SW_IT_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_TIMER;                /*!< (@ 0x00000044) TIMER0_TIMER                                               */
    
    struct {
      __IM  uint32_t TIMER0_TIMER : 32;         /*!< [31..0] Timer&#160;current&#160;value&#160;register                       */
    } TIMER0_TIMER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_CTRL;                 /*!< (@ 0x00000048) TIMER1_CTRL                                                */
    
    struct {
      __IM  uint32_t USER_TIMER_TIMER1_CTRL_LOAD_TIMER : 1;/*!< [0..0] Load&#160;timer&#160;command                            */
      __IOM uint32_t USER_TIMER_TIMER1_CTRL_ENABLE : 1;/*!< [1..1] Timer&#160;enable                                           */
      __IOM uint32_t USER_TIMER_TIMER1_CTRL_TIMER_MODE : 2;/*!< [3..2] Timer&#160;mode                                         */
            uint32_t            : 28;
    } TIMER1_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_COUNTER;              /*!< (@ 0x0000004C) TIMER1_COUNTER                                             */
    
    struct {
      __IOM uint32_t TIMER1_COUNTER : 16;       /*!< [15..0] Counter&#160;load&#160;value&#160;register                        */
            uint32_t            : 16;
    } TIMER1_COUNTER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_PRESCALER;            /*!< (@ 0x00000050) TIMER1_PRESCALER                                           */
    
    struct {
      __IOM uint32_t TIMER1_PRESCALER : 16;     /*!< [15..0] Prescaler&#160;load&#160;value&#160;register                      */
            uint32_t            : 16;
    } TIMER1_PRESCALER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_SW_IT;                /*!< (@ 0x00000054) TIMER1_SW_IT                                               */
    
    struct {
      __IOM uint32_t TIMER1_SW_IT : 32;         /*!< [31..0] Timer&#160;software&#160;interrupt&#160;configuration&#160;register */
    } TIMER1_SW_IT_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_TIMER;                /*!< (@ 0x00000058) TIMER1_TIMER                                               */
    
    struct {
      __IM  uint32_t TIMER1_TIMER : 32;         /*!< [31..0] Timer&#160;current&#160;value&#160;register                       */
    } TIMER1_TIMER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_CTRL;                 /*!< (@ 0x0000005C) TIMER2_CTRL                                                */
    
    struct {
      __IM  uint32_t USER_TIMER_TIMER2_CTRL_LOAD_TIMER : 1;/*!< [0..0] Load&#160;timer&#160;command                            */
      __IOM uint32_t USER_TIMER_TIMER2_CTRL_ENABLE : 1;/*!< [1..1] Timer&#160;enable                                           */
      __IOM uint32_t USER_TIMER_TIMER2_CTRL_TIMER_MODE : 2;/*!< [3..2] Timer&#160;mode                                         */
            uint32_t            : 28;
    } TIMER2_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_COUNTER;              /*!< (@ 0x00000060) TIMER2_COUNTER                                             */
    
    struct {
      __IOM uint32_t TIMER2_COUNTER : 16;       /*!< [15..0] Counter&#160;load&#160;value&#160;register                        */
            uint32_t            : 16;
    } TIMER2_COUNTER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_PRESCALER;            /*!< (@ 0x00000064) TIMER2_PRESCALER                                           */
    
    struct {
      __IOM uint32_t TIMER2_PRESCALER : 16;     /*!< [15..0] Prescaler&#160;load&#160;value&#160;register                      */
            uint32_t            : 16;
    } TIMER2_PRESCALER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_SW_IT;                /*!< (@ 0x00000068) TIMER2_SW_IT                                               */
    
    struct {
      __IOM uint32_t TIMER2_SW_IT : 32;         /*!< [31..0] Timer&#160;software&#160;interrupt&#160;configuration&#160;register */
    } TIMER2_SW_IT_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_TIMER;                /*!< (@ 0x0000006C) TIMER2_TIMER                                               */
    
    struct {
      __IM  uint32_t TIMER2_TIMER : 32;         /*!< [31..0] Timer&#160;current&#160;value&#160;register                       */
    } TIMER2_TIMER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_CTRL;                 /*!< (@ 0x00000070) TIMER3_CTRL                                                */
    
    struct {
      __IM  uint32_t USER_TIMER_TIMER3_CTRL_LOAD_TIMER : 1;/*!< [0..0] Load&#160;timer&#160;command                            */
      __IOM uint32_t USER_TIMER_TIMER3_CTRL_ENABLE : 1;/*!< [1..1] Timer&#160;enable                                           */
      __IOM uint32_t USER_TIMER_TIMER3_CTRL_TIMER_MODE : 2;/*!< [3..2] Timer&#160;mode                                         */
            uint32_t            : 28;
    } TIMER3_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_COUNTER;              /*!< (@ 0x00000074) TIMER3_COUNTER                                             */
    
    struct {
      __IOM uint32_t TIMER3_COUNTER : 16;       /*!< [15..0] Counter&#160;load&#160;value&#160;register                        */
            uint32_t            : 16;
    } TIMER3_COUNTER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_PRESCALER;            /*!< (@ 0x00000078) TIMER3_PRESCALER                                           */
    
    struct {
      __IOM uint32_t TIMER3_PRESCALER : 16;     /*!< [15..0] Prescaler&#160;load&#160;value&#160;register                      */
            uint32_t            : 16;
    } TIMER3_PRESCALER_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_SW_IT;                /*!< (@ 0x0000007C) TIMER3_SW_IT                                               */
    
    struct {
      __IOM uint32_t TIMER3_SW_IT : 32;         /*!< [31..0] Timer&#160;software&#160;interrupt&#160;configuration&#160;register */
    } TIMER3_SW_IT_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_TIMER;                /*!< (@ 0x00000080) TIMER3_TIMER                                               */
    
    struct {
      __IM  uint32_t TIMER3_TIMER : 32;         /*!< [31..0] Timer&#160;current&#160;value&#160;register                       */
    } TIMER3_TIMER_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_COMPARE_CTRL;       /*!< (@ 0x00000084) COMPARE0_COMPARE_CTRL                                      */
    
    struct {
      __IOM uint32_t USER_TIMER_COMPARE0_COMPARE_CTRL_SELECT_POLARITY : 1;/*!< [0..0] Output&#160;data&#160;polarity&#160;selection */
      __IOM uint32_t USER_TIMER_COMPARE0_COMPARE_CTRL_DEDICATED_2TIMER : 2;/*!< [2..1] Dedicated&#160;timer&#160;selection     */
      __IOM uint32_t USER_TIMER_COMPARE0_COMPARE_CTRL_ENABLE : 1;/*!< [3..3] Compare&#160;unit&#160;enable                     */
      __IM  uint32_t USER_TIMER_COMPARE0_COMPARE_CTRL_LOAD_VALUE : 1;/*!< [4..4] Load&#160;all&#160;compare&#160;value         */
            uint32_t            : 27;
    } COMPARE0_COMPARE_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_COUNTER_START;      /*!< (@ 0x00000088) COMPARE0_COUNTER_START                                     */
    
    struct {
      __IOM uint32_t COMPARE0_COUNTER_START : 16;/*!< [15..0] Compare&#160;counter&#160;start&#160;value&#160;register         */
            uint32_t            : 16;
    } COMPARE0_COUNTER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_COUNTER_STOP;       /*!< (@ 0x0000008C) COMPARE0_COUNTER_STOP                                      */
    
    struct {
      __IOM uint32_t COMPARE0_COUNTER_STOP : 16;/*!< [15..0] Compare&#160;counter&#160;stop&#160;value&#160;register           */
            uint32_t            : 16;
    } COMPARE0_COUNTER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_PRESCALER_START;    /*!< (@ 0x00000090) COMPARE0_PRESCALER_START                                   */
    
    struct {
      __IOM uint32_t COMPARE0_PRESCALER_START : 16;/*!< [15..0] Compare&#160;prescaler&#160;start&#160;value&#160;register     */
            uint32_t            : 16;
    } COMPARE0_PRESCALER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_PRESCALER_STOP;     /*!< (@ 0x00000094) COMPARE0_PRESCALER_STOP                                    */
    
    struct {
      __IOM uint32_t COMPARE0_PRESCALER_STOP : 16;/*!< [15..0] Compare&#160;prescaler&#160;stop&#160;value&#160;register       */
            uint32_t            : 16;
    } COMPARE0_PRESCALER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE0_CYCLE_COMPARE;      /*!< (@ 0x00000098) COMPARE0_CYCLE_COMPARE                                     */
    
    struct {
      __IOM uint32_t COMPARE0_CYCLE_COMPARE : 8;/*!< [7..0] Compare&#160;cycle&#160;value&#160;register                        */
            uint32_t            : 24;
    } COMPARE0_CYCLE_COMPARE_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_COMPARE_CTRL;       /*!< (@ 0x0000009C) COMPARE1_COMPARE_CTRL                                      */
    
    struct {
      __IOM uint32_t USER_TIMER_COMPARE1_COMPARE_CTRL_SELECT_POLARITY : 1;/*!< [0..0] Output&#160;data&#160;polarity&#160;selection */
      __IOM uint32_t USER_TIMER_COMPARE1_COMPARE_CTRL_DEDICATED_2TIMER : 2;/*!< [2..1] Dedicated&#160;timer&#160;selection     */
      __IOM uint32_t USER_TIMER_COMPARE1_COMPARE_CTRL_ENABLE : 1;/*!< [3..3] Compare&#160;unit&#160;enable                     */
      __IM  uint32_t USER_TIMER_COMPARE1_COMPARE_CTRL_LOAD_VALUE : 1;/*!< [4..4] Load&#160;all&#160;compare&#160;value         */
            uint32_t            : 27;
    } COMPARE1_COMPARE_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_COUNTER_START;      /*!< (@ 0x000000A0) COMPARE1_COUNTER_START                                     */
    
    struct {
      __IOM uint32_t COMPARE1_COUNTER_START : 16;/*!< [15..0] Compare&#160;counter&#160;start&#160;value&#160;register         */
            uint32_t            : 16;
    } COMPARE1_COUNTER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_COUNTER_STOP;       /*!< (@ 0x000000A4) COMPARE1_COUNTER_STOP                                      */
    
    struct {
      __IOM uint32_t COMPARE1_COUNTER_STOP : 16;/*!< [15..0] Compare&#160;counter&#160;stop&#160;value&#160;register           */
            uint32_t            : 16;
    } COMPARE1_COUNTER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_PRESCALER_START;    /*!< (@ 0x000000A8) COMPARE1_PRESCALER_START                                   */
    
    struct {
      __IOM uint32_t COMPARE1_PRESCALER_START : 16;/*!< [15..0] Compare&#160;prescaler&#160;start&#160;value&#160;register     */
            uint32_t            : 16;
    } COMPARE1_PRESCALER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_PRESCALER_STOP;     /*!< (@ 0x000000AC) COMPARE1_PRESCALER_STOP                                    */
    
    struct {
      __IOM uint32_t COMPARE1_PRESCALER_STOP : 16;/*!< [15..0] Compare&#160;prescaler&#160;stop&#160;value&#160;register       */
            uint32_t            : 16;
    } COMPARE1_PRESCALER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE1_CYCLE_COMPARE;      /*!< (@ 0x000000B0) COMPARE1_CYCLE_COMPARE                                     */
    
    struct {
      __IOM uint32_t COMPARE1_CYCLE_COMPARE : 8;/*!< [7..0] Compare&#160;cycle&#160;value&#160;register                        */
            uint32_t            : 24;
    } COMPARE1_CYCLE_COMPARE_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_COMPARE_CTRL;       /*!< (@ 0x000000B4) COMPARE2_COMPARE_CTRL                                      */
    
    struct {
      __IOM uint32_t USER_TIMER_COMPARE2_COMPARE_CTRL_SELECT_POLARITY : 1;/*!< [0..0] Output&#160;data&#160;polarity&#160;selection */
      __IOM uint32_t USER_TIMER_COMPARE2_COMPARE_CTRL_DEDICATED_2TIMER : 2;/*!< [2..1] Dedicated&#160;timer&#160;selection     */
      __IOM uint32_t USER_TIMER_COMPARE2_COMPARE_CTRL_ENABLE : 1;/*!< [3..3] Compare&#160;unit&#160;enable                     */
      __IM  uint32_t USER_TIMER_COMPARE2_COMPARE_CTRL_LOAD_VALUE : 1;/*!< [4..4] Load&#160;all&#160;compare&#160;value         */
            uint32_t            : 27;
    } COMPARE2_COMPARE_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_COUNTER_START;      /*!< (@ 0x000000B8) COMPARE2_COUNTER_START                                     */
    
    struct {
      __IOM uint32_t COMPARE2_COUNTER_START : 16;/*!< [15..0] Compare&#160;counter&#160;start&#160;value&#160;register         */
            uint32_t            : 16;
    } COMPARE2_COUNTER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_COUNTER_STOP;       /*!< (@ 0x000000BC) COMPARE2_COUNTER_STOP                                      */
    
    struct {
      __IOM uint32_t COMPARE2_COUNTER_STOP : 16;/*!< [15..0] Compare&#160;counter&#160;stop&#160;value&#160;register           */
            uint32_t            : 16;
    } COMPARE2_COUNTER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_PRESCALER_START;    /*!< (@ 0x000000C0) COMPARE2_PRESCALER_START                                   */
    
    struct {
      __IOM uint32_t COMPARE2_PRESCALER_START : 16;/*!< [15..0] Compare&#160;prescaler&#160;start&#160;value&#160;register     */
            uint32_t            : 16;
    } COMPARE2_PRESCALER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_PRESCALER_STOP;     /*!< (@ 0x000000C4) COMPARE2_PRESCALER_STOP                                    */
    
    struct {
      __IOM uint32_t COMPARE2_PRESCALER_STOP : 16;/*!< [15..0] Compare&#160;prescaler&#160;stop&#160;value&#160;register       */
            uint32_t            : 16;
    } COMPARE2_PRESCALER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE2_CYCLE_COMPARE;      /*!< (@ 0x000000C8) COMPARE2_CYCLE_COMPARE                                     */
    
    struct {
      __IOM uint32_t COMPARE2_CYCLE_COMPARE : 8;/*!< [7..0] Compare&#160;cycle&#160;value&#160;register                        */
            uint32_t            : 24;
    } COMPARE2_CYCLE_COMPARE_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_COMPARE_CTRL;       /*!< (@ 0x000000CC) COMPARE3_COMPARE_CTRL                                      */
    
    struct {
      __IOM uint32_t USER_TIMER_COMPARE3_COMPARE_CTRL_SELECT_POLARITY : 1;/*!< [0..0] Output&#160;data&#160;polarity&#160;selection */
      __IOM uint32_t USER_TIMER_COMPARE3_COMPARE_CTRL_DEDICATED_2TIMER : 2;/*!< [2..1] Dedicated&#160;timer&#160;selection     */
      __IOM uint32_t USER_TIMER_COMPARE3_COMPARE_CTRL_ENABLE : 1;/*!< [3..3] Compare&#160;unit&#160;enable                     */
      __IM  uint32_t USER_TIMER_COMPARE3_COMPARE_CTRL_LOAD_VALUE : 1;/*!< [4..4] Load&#160;all&#160;compare&#160;value         */
            uint32_t            : 27;
    } COMPARE3_COMPARE_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_COUNTER_START;      /*!< (@ 0x000000D0) COMPARE3_COUNTER_START                                     */
    
    struct {
      __IOM uint32_t COMPARE3_COUNTER_START : 16;/*!< [15..0] Compare&#160;counter&#160;start&#160;value&#160;register         */
            uint32_t            : 16;
    } COMPARE3_COUNTER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_COUNTER_STOP;       /*!< (@ 0x000000D4) COMPARE3_COUNTER_STOP                                      */
    
    struct {
      __IOM uint32_t COMPARE3_COUNTER_STOP : 16;/*!< [15..0] Compare&#160;counter&#160;stop&#160;value&#160;register           */
            uint32_t            : 16;
    } COMPARE3_COUNTER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_PRESCALER_START;    /*!< (@ 0x000000D8) COMPARE3_PRESCALER_START                                   */
    
    struct {
      __IOM uint32_t COMPARE3_PRESCALER_START : 16;/*!< [15..0] Compare&#160;prescaler&#160;start&#160;value&#160;register     */
            uint32_t            : 16;
    } COMPARE3_PRESCALER_START_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_PRESCALER_STOP;     /*!< (@ 0x000000DC) COMPARE3_PRESCALER_STOP                                    */
    
    struct {
      __IOM uint32_t COMPARE3_PRESCALER_STOP : 16;/*!< [15..0] Compare&#160;prescaler&#160;stop&#160;value&#160;register       */
            uint32_t            : 16;
    } COMPARE3_PRESCALER_STOP_b;
  } ;
  
  union {
    __IOM uint32_t COMPARE3_CYCLE_COMPARE;      /*!< (@ 0x000000E0) COMPARE3_CYCLE_COMPARE                                     */
    
    struct {
      __IOM uint32_t COMPARE3_CYCLE_COMPARE : 8;/*!< [7..0] Compare&#160;cycle&#160;value&#160;register                        */
            uint32_t            : 24;
    } COMPARE3_CYCLE_COMPARE_b;
  } ;
  
  union {
    __IOM uint32_t CRT_VALUE;                   /*!< (@ 0x000000E4) CRT_VALUE                                                  */
    
    struct {
      __IOM uint32_t CRT_VALUE  : 8;            /*!< [7..0] CRT&#160;Value&#160;register                                       */
            uint32_t            : 24;
    } CRT_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t CRT_CONTROL;                 /*!< (@ 0x000000E8) CRT_CONTROL                                                */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t USER_TIMER_CRT_CONTROL_DEDICATED_TIMER : 2;/*!< [9..8] CRT&#160;timer&#160;selection                      */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CRT_CONTROL_OUTPUT_SELECT : 4;/*!< [19..16] active&#160;the&#160;input&#160;from&#160;the&#160;comparator */
            uint32_t            : 12;
    } CRT_CONTROL_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_CTRL;               /*!< (@ 0x000000EC) CAPTURE0_CTRL                                              */
    
    struct {
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_SELECT_DATA : 2;/*!< [1..0] Selection&#160;of&#160;the&#160;captured&#160;input  */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_DEDICATED_2TIMER : 2;/*!< [9..8] Dedicated&#160;timer&#160;selection             */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_STOP_CONDITION : 1;/*!< [16..16] Stop&#160;condition&#160;enable                 */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_TIMEOUT : 1;/*!< [17..17] Timeout&#160;enable                                    */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_MODE : 1;/*!< [18..18] Capture&#160;mode&#160;selection                          */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_START_RF_EDGE : 1;/*!< [19..19] Start&#160;edge&#160;type&#160;selection         */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_STOP_RF_EDGE : 1;/*!< [20..20] Stop&#160;edge&#160;type&#160;selection           */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_ENABLE : 1;/*!< [21..21] Capture&#160;enable                                     */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_ALARM_CONDITION : 1;/*!< [22..22] Alarm&#160;condition                           */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_CONDITION : 2;/*!< [24..23] Alarm&#160;prescaler&#160;condition  */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_OPERATOR : 1;/*!< [25..25] Explicit values are :  0x1 = and (AND operator between
                                                     lsb and msb results) 0x0 = or (OR operator between lsb
                                                     and msb results)                                                          */
      __IOM uint32_t USER_TIMER_CAPTURE0_CTRL_CAPTURE_UNIT_REINIT : 1;/*!< [26..26] capture&#160;unit&#160;reinitialization    */
            uint32_t            : 5;
    } CAPTURE0_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_TIMEOUT_DELAY;      /*!< (@ 0x000000F0) CAPTURE0_TIMEOUT_DELAY                                     */
    
    struct {
      __IOM uint32_t CAPTURE0_TIMEOUT_DELAY : 32;/*!< [31..0] Timeout&#160;delay&#160;value                                    */
    } CAPTURE0_TIMEOUT_DELAY_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_STOP_N_OCCURRENCE;  /*!< (@ 0x000000F4) CAPTURE0_STOP_N_OCCURRENCE                                 */
    
    struct {
      __IOM uint32_t CAPTURE0_STOP_N_OCCURRENCE : 16;/*!< [15..0] Number&#160;of&#160;STOP&#160;occurrences                    */
            uint32_t            : 16;
    } CAPTURE0_STOP_N_OCCURRENCE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_START_TIME_CAPTURE; /*!< (@ 0x000000F8) CAPTURE0_START_TIME_CAPTURE                                */
    
    struct {
      __IM  uint32_t CAPTURE0_START_TIME_CAPTURE : 32;/*!< [31..0] Start&#160;time&#160;capture&#160;command                   */
    } CAPTURE0_START_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_STOP_TIME_CAPTURE;  /*!< (@ 0x000000FC) CAPTURE0_STOP_TIME_CAPTURE                                 */
    
    struct {
      __IM  uint32_t CAPTURE0_STOP_TIME_CAPTURE : 32;/*!< [31..0] Stop&#160;time&#160;capture&#160;command                     */
    } CAPTURE0_STOP_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE0_ALARM_THRESHOLD;    /*!< (@ 0x00000100) CAPTURE0_ALARM_THRESHOLD                                   */
    
    struct {
      __IOM uint32_t CAPTURE0_ALARM_THRESHOLD : 32;/*!< [31..0] Threshold&#160;alarm                                           */
    } CAPTURE0_ALARM_THRESHOLD_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_CTRL;               /*!< (@ 0x00000104) CAPTURE1_CTRL                                              */
    
    struct {
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_SELECT_DATA : 2;/*!< [1..0] Selection&#160;of&#160;the&#160;captured&#160;input  */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_DEDICATED_2TIMER : 2;/*!< [9..8] Dedicated&#160;timer&#160;selection             */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_STOP_CONDITION : 1;/*!< [16..16] Stop&#160;condition&#160;enable                 */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_TIMEOUT : 1;/*!< [17..17] Timeout&#160;enable                                    */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_MODE : 1;/*!< [18..18] Capture&#160;mode&#160;selection                          */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_START_RF_EDGE : 1;/*!< [19..19] Start&#160;edge&#160;type&#160;selection         */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_STOP_RF_EDGE : 1;/*!< [20..20] Stop&#160;edge&#160;type&#160;selection           */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_ENABLE : 1;/*!< [21..21] Capture&#160;enable                                     */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_ALARM_CONDITION : 1;/*!< [22..22] Alarm&#160;condition                           */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_CONDITION : 2;/*!< [24..23] Alarm&#160;prescaler&#160;condition  */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_OPERATOR : 1;/*!< [25..25] Explicit values are :  0x1 = and (AND operator between
                                                     lsb and msb results) 0x0 = or (OR operator between lsb
                                                     and msb results)                                                          */
      __IOM uint32_t USER_TIMER_CAPTURE1_CTRL_CAPTURE_UNIT_REINIT : 1;/*!< [26..26] capture&#160;unit&#160;reinitialization    */
            uint32_t            : 5;
    } CAPTURE1_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_TIMEOUT_DELAY;      /*!< (@ 0x00000108) CAPTURE1_TIMEOUT_DELAY                                     */
    
    struct {
      __IOM uint32_t CAPTURE1_TIMEOUT_DELAY : 32;/*!< [31..0] Timeout&#160;delay&#160;value                                    */
    } CAPTURE1_TIMEOUT_DELAY_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_STOP_N_OCCURRENCE;  /*!< (@ 0x0000010C) CAPTURE1_STOP_N_OCCURRENCE                                 */
    
    struct {
      __IOM uint32_t CAPTURE1_STOP_N_OCCURRENCE : 16;/*!< [15..0] Number&#160;of&#160;STOP&#160;occurrences                    */
            uint32_t            : 16;
    } CAPTURE1_STOP_N_OCCURRENCE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_START_TIME_CAPTURE; /*!< (@ 0x00000110) CAPTURE1_START_TIME_CAPTURE                                */
    
    struct {
      __IM  uint32_t CAPTURE1_START_TIME_CAPTURE : 32;/*!< [31..0] Start&#160;time&#160;capture&#160;command                   */
    } CAPTURE1_START_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_STOP_TIME_CAPTURE;  /*!< (@ 0x00000114) CAPTURE1_STOP_TIME_CAPTURE                                 */
    
    struct {
      __IM  uint32_t CAPTURE1_STOP_TIME_CAPTURE : 32;/*!< [31..0] Stop&#160;time&#160;capture&#160;command                     */
    } CAPTURE1_STOP_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE1_ALARM_THRESHOLD;    /*!< (@ 0x00000118) CAPTURE1_ALARM_THRESHOLD                                   */
    
    struct {
      __IOM uint32_t CAPTURE1_ALARM_THRESHOLD : 32;/*!< [31..0] Threshold&#160;alarm                                           */
    } CAPTURE1_ALARM_THRESHOLD_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_CTRL;               /*!< (@ 0x0000011C) CAPTURE2_CTRL                                              */
    
    struct {
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_SELECT_DATA : 2;/*!< [1..0] Selection&#160;of&#160;the&#160;captured&#160;input  */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_DEDICATED_2TIMER : 2;/*!< [9..8] Dedicated&#160;timer&#160;selection             */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_STOP_CONDITION : 1;/*!< [16..16] Stop&#160;condition&#160;enable                 */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_TIMEOUT : 1;/*!< [17..17] Timeout&#160;enable                                    */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_MODE : 1;/*!< [18..18] Capture&#160;mode&#160;selection                          */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_START_RF_EDGE : 1;/*!< [19..19] Start&#160;edge&#160;type&#160;selection         */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_STOP_RF_EDGE : 1;/*!< [20..20] Stop&#160;edge&#160;type&#160;selection           */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_ENABLE : 1;/*!< [21..21] Capture&#160;enable                                     */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_ALARM_CONDITION : 1;/*!< [22..22] Alarm&#160;condition                           */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_CONDITION : 2;/*!< [24..23] Alarm&#160;prescaler&#160;condition  */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_OPERATOR : 1;/*!< [25..25] Explicit values are :  0x1 = and (AND operator between
                                                     lsb and msb results) 0x0 = or (OR operator between lsb
                                                     and msb results)                                                          */
      __IOM uint32_t USER_TIMER_CAPTURE2_CTRL_CAPTURE_UNIT_REINIT : 1;/*!< [26..26] capture&#160;unit&#160;reinitialization    */
            uint32_t            : 5;
    } CAPTURE2_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_TIMEOUT_DELAY;      /*!< (@ 0x00000120) CAPTURE2_TIMEOUT_DELAY                                     */
    
    struct {
      __IOM uint32_t CAPTURE2_TIMEOUT_DELAY : 32;/*!< [31..0] Timeout&#160;delay&#160;value                                    */
    } CAPTURE2_TIMEOUT_DELAY_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_STOP_N_OCCURRENCE;  /*!< (@ 0x00000124) CAPTURE2_STOP_N_OCCURRENCE                                 */
    
    struct {
      __IOM uint32_t CAPTURE2_STOP_N_OCCURRENCE : 16;/*!< [15..0] Number&#160;of&#160;STOP&#160;occurrences                    */
            uint32_t            : 16;
    } CAPTURE2_STOP_N_OCCURRENCE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_START_TIME_CAPTURE; /*!< (@ 0x00000128) CAPTURE2_START_TIME_CAPTURE                                */
    
    struct {
      __IM  uint32_t CAPTURE2_START_TIME_CAPTURE : 32;/*!< [31..0] Start&#160;time&#160;capture&#160;command                   */
    } CAPTURE2_START_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_STOP_TIME_CAPTURE;  /*!< (@ 0x0000012C) CAPTURE2_STOP_TIME_CAPTURE                                 */
    
    struct {
      __IM  uint32_t CAPTURE2_STOP_TIME_CAPTURE : 32;/*!< [31..0] Stop&#160;time&#160;capture&#160;command                     */
    } CAPTURE2_STOP_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE2_ALARM_THRESHOLD;    /*!< (@ 0x00000130) CAPTURE2_ALARM_THRESHOLD                                   */
    
    struct {
      __IOM uint32_t CAPTURE2_ALARM_THRESHOLD : 32;/*!< [31..0] Threshold&#160;alarm                                           */
    } CAPTURE2_ALARM_THRESHOLD_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_CTRL;               /*!< (@ 0x00000134) CAPTURE3_CTRL                                              */
    
    struct {
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_SELECT_DATA : 2;/*!< [1..0] Selection&#160;of&#160;the&#160;captured&#160;input  */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_DEDICATED_2TIMER : 2;/*!< [9..8] Dedicated&#160;timer&#160;selection             */
            uint32_t            : 6;
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_STOP_CONDITION : 1;/*!< [16..16] Stop&#160;condition&#160;enable                 */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_TIMEOUT : 1;/*!< [17..17] Timeout&#160;enable                                    */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_MODE : 1;/*!< [18..18] Capture&#160;mode&#160;selection                          */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_START_RF_EDGE : 1;/*!< [19..19] Start&#160;edge&#160;type&#160;selection         */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_STOP_RF_EDGE : 1;/*!< [20..20] Stop&#160;edge&#160;type&#160;selection           */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_ENABLE : 1;/*!< [21..21] Capture&#160;enable                                     */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_ALARM_CONDITION : 1;/*!< [22..22] Alarm&#160;condition                           */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_CONDITION : 2;/*!< [24..23] Alarm&#160;prescaler&#160;condition  */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_OPERATOR : 1;/*!< [25..25] Explicit values are :  0x1 = and (AND operator between
                                                     lsb and msb results) 0x0 = or (OR operator between lsb
                                                     and msb results)                                                          */
      __IOM uint32_t USER_TIMER_CAPTURE3_CTRL_CAPTURE_UNIT_REINIT : 1;/*!< [26..26] capture&#160;unit&#160;reinitialization    */
            uint32_t            : 5;
    } CAPTURE3_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_TIMEOUT_DELAY;      /*!< (@ 0x00000138) CAPTURE3_TIMEOUT_DELAY                                     */
    
    struct {
      __IOM uint32_t CAPTURE3_TIMEOUT_DELAY : 32;/*!< [31..0] Timeout&#160;delay&#160;value                                    */
    } CAPTURE3_TIMEOUT_DELAY_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_STOP_N_OCCURRENCE;  /*!< (@ 0x0000013C) CAPTURE3_STOP_N_OCCURRENCE                                 */
    
    struct {
      __IOM uint32_t CAPTURE3_STOP_N_OCCURRENCE : 16;/*!< [15..0] Number&#160;of&#160;STOP&#160;occurrences                    */
            uint32_t            : 16;
    } CAPTURE3_STOP_N_OCCURRENCE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_START_TIME_CAPTURE; /*!< (@ 0x00000140) CAPTURE3_START_TIME_CAPTURE                                */
    
    struct {
      __IM  uint32_t CAPTURE3_START_TIME_CAPTURE : 32;/*!< [31..0] Start&#160;time&#160;capture&#160;command                   */
    } CAPTURE3_START_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_STOP_TIME_CAPTURE;  /*!< (@ 0x00000144) CAPTURE3_STOP_TIME_CAPTURE                                 */
    
    struct {
      __IM  uint32_t CAPTURE3_STOP_TIME_CAPTURE : 32;/*!< [31..0] Stop&#160;time&#160;capture&#160;command                     */
    } CAPTURE3_STOP_TIME_CAPTURE_b;
  } ;
  
  union {
    __IOM uint32_t CAPTURE3_ALARM_THRESHOLD;    /*!< (@ 0x00000148) CAPTURE3_ALARM_THRESHOLD                                   */
    
    struct {
      __IOM uint32_t CAPTURE3_ALARM_THRESHOLD : 32;/*!< [31..0] Threshold&#160;alarm                                           */
    } CAPTURE3_ALARM_THRESHOLD_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_INTERRUPT_CPU_MASK;   /*!< (@ 0x0000014C) TIMER0_INTERRUPT_CPU_MASK                                  */
    
    struct {
      __IOM uint32_t TIMER0_INTERRUPT_CPU_MASK : 4;/*!< [3..0] Interrupt&#160;maskInterrupt bit mapping is : 0 = timeout_it
                                                     1 = alarm_it 2 = capture_it 3 = software_it                               */
            uint32_t            : 28;
    } TIMER0_INTERRUPT_CPU_MASK_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_INTERRUPT_CPU_STATUS; /*!< (@ 0x00000150) TIMER0_INTERRUPT_CPU_STATUS                                */
    
    struct {
      __IM  uint32_t TIMER0_INTERRUPT_CPU_STATUS : 4;/*!< [3..0] Interrupt&#160;status&#160;(see&#160;mapping&#160;above)      */
            uint32_t            : 28;
    } TIMER0_INTERRUPT_CPU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_INTERRUPT_CPU_RAW_STATUS;/*!< (@ 0x00000154) TIMER0_INTERRUPT_CPU_RAW_STATUS                         */
    
    struct {
      __IM  uint32_t TIMER0_INTERRUPT_CPU_RAW_STATUS : 4;/*!< [3..0] Interrupt&#160;raw&#160;status&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER0_INTERRUPT_CPU_RAW_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER0_INTERRUPT_CPU_STATUS_CLEAR;/*!< (@ 0x00000158) TIMER0_INTERRUPT_CPU_STATUS_CLEAR                     */
    
    struct {
      __IOM uint32_t TIMER0_INTERRUPT_CPU_STATUS_CLEAR : 4;/*!< [3..0] Interrupt&#160;status&#160;clear&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER0_INTERRUPT_CPU_STATUS_CLEAR_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_INTERRUPT_CPU_MASK;   /*!< (@ 0x0000015C) TIMER1_INTERRUPT_CPU_MASK                                  */
    
    struct {
      __IOM uint32_t TIMER1_INTERRUPT_CPU_MASK : 4;/*!< [3..0] Interrupt&#160;maskInterrupt bit mapping is : 0 = timeout_it
                                                     1 = alarm_it 2 = capture_it 3 = software_it                               */
            uint32_t            : 28;
    } TIMER1_INTERRUPT_CPU_MASK_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_INTERRUPT_CPU_STATUS; /*!< (@ 0x00000160) TIMER1_INTERRUPT_CPU_STATUS                                */
    
    struct {
      __IM  uint32_t TIMER1_INTERRUPT_CPU_STATUS : 4;/*!< [3..0] Interrupt&#160;status&#160;(see&#160;mapping&#160;above)      */
            uint32_t            : 28;
    } TIMER1_INTERRUPT_CPU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_INTERRUPT_CPU_RAW_STATUS;/*!< (@ 0x00000164) TIMER1_INTERRUPT_CPU_RAW_STATUS                         */
    
    struct {
      __IM  uint32_t TIMER1_INTERRUPT_CPU_RAW_STATUS : 4;/*!< [3..0] Interrupt&#160;raw&#160;status&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER1_INTERRUPT_CPU_RAW_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER1_INTERRUPT_CPU_STATUS_CLEAR;/*!< (@ 0x00000168) TIMER1_INTERRUPT_CPU_STATUS_CLEAR                     */
    
    struct {
      __IOM uint32_t TIMER1_INTERRUPT_CPU_STATUS_CLEAR : 4;/*!< [3..0] Interrupt&#160;status&#160;clear&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER1_INTERRUPT_CPU_STATUS_CLEAR_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_INTERRUPT_CPU_MASK;   /*!< (@ 0x0000016C) TIMER2_INTERRUPT_CPU_MASK                                  */
    
    struct {
      __IOM uint32_t TIMER2_INTERRUPT_CPU_MASK : 4;/*!< [3..0] Interrupt&#160;maskInterrupt bit mapping is : 0 = timeout_it
                                                     1 = alarm_it 2 = capture_it 3 = software_it                               */
            uint32_t            : 28;
    } TIMER2_INTERRUPT_CPU_MASK_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_INTERRUPT_CPU_STATUS; /*!< (@ 0x00000170) TIMER2_INTERRUPT_CPU_STATUS                                */
    
    struct {
      __IM  uint32_t TIMER2_INTERRUPT_CPU_STATUS : 4;/*!< [3..0] Interrupt&#160;status&#160;(see&#160;mapping&#160;above)      */
            uint32_t            : 28;
    } TIMER2_INTERRUPT_CPU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_INTERRUPT_CPU_RAW_STATUS;/*!< (@ 0x00000174) TIMER2_INTERRUPT_CPU_RAW_STATUS                         */
    
    struct {
      __IM  uint32_t TIMER2_INTERRUPT_CPU_RAW_STATUS : 4;/*!< [3..0] Interrupt&#160;raw&#160;status&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER2_INTERRUPT_CPU_RAW_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER2_INTERRUPT_CPU_STATUS_CLEAR;/*!< (@ 0x00000178) TIMER2_INTERRUPT_CPU_STATUS_CLEAR                     */
    
    struct {
      __IOM uint32_t TIMER2_INTERRUPT_CPU_STATUS_CLEAR : 4;/*!< [3..0] Interrupt&#160;status&#160;clear&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER2_INTERRUPT_CPU_STATUS_CLEAR_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_INTERRUPT_CPU_MASK;   /*!< (@ 0x0000017C) TIMER3_INTERRUPT_CPU_MASK                                  */
    
    struct {
      __IOM uint32_t TIMER3_INTERRUPT_CPU_MASK : 4;/*!< [3..0] Interrupt&#160;maskInterrupt bit mapping is : 0 = timeout_it
                                                     1 = alarm_it 2 = capture_it 3 = software_it                               */
            uint32_t            : 28;
    } TIMER3_INTERRUPT_CPU_MASK_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_INTERRUPT_CPU_STATUS; /*!< (@ 0x00000180) TIMER3_INTERRUPT_CPU_STATUS                                */
    
    struct {
      __IM  uint32_t TIMER3_INTERRUPT_CPU_STATUS : 4;/*!< [3..0] Interrupt&#160;status&#160;(see&#160;mapping&#160;above)      */
            uint32_t            : 28;
    } TIMER3_INTERRUPT_CPU_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_INTERRUPT_CPU_RAW_STATUS;/*!< (@ 0x00000184) TIMER3_INTERRUPT_CPU_RAW_STATUS                         */
    
    struct {
      __IM  uint32_t TIMER3_INTERRUPT_CPU_RAW_STATUS : 4;/*!< [3..0] Interrupt&#160;raw&#160;status&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER3_INTERRUPT_CPU_RAW_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t TIMER3_INTERRUPT_CPU_STATUS_CLEAR;/*!< (@ 0x00000188) TIMER3_INTERRUPT_CPU_STATUS_CLEAR                     */
    
    struct {
      __IOM uint32_t TIMER3_INTERRUPT_CPU_STATUS_CLEAR : 4;/*!< [3..0] Interrupt&#160;status&#160;clear&#160;(see&#160;mapping&#160;above) */
            uint32_t            : 28;
    } TIMER3_INTERRUPT_CPU_STATUS_CLEAR_b;
  } ;
  
  union {
    __IOM uint32_t SPARE;                       /*!< (@ 0x0000018C) SPARE                                                      */
    
    struct {
      __IOM uint32_t SPARE      : 4;            /*!< [3..0] SPARE                                                              */
            uint32_t            : 28;
    } SPARE_b;
  } ;
} USER_TIMERS_Type;                             /*!< Size = 400 (0x190)                                                        */



/* =========================================================================================================================== */
/* ================                                            PCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PCM/I2S controller (PCM)
  */

typedef struct {                                /*!< (@ 0x00240000) PCM Structure                                              */
  
  union {
    __IOM uint32_t TIMING_CFG;                  /*!< (@ 0x00000000) TIMING_CFG                                                 */
    
    struct {
      __IOM uint32_t PCLK2PCM_OUT_FCLK_CYCLES : 7;/*!< [6..0] Number of fclk cycles from PCLK edge to PCM_OUT transmission     */
      __IOM uint32_t PCLK2PCM_IN_FCLK_CYCLES : 7;/*!< [13..7] Number of fclk cycles from PCLK edge to PCM_IN sampling.         */
      __IOM uint32_t PCLK2FS_FCLK_CYCLES : 7;   /*!< [20..14] Number of fclk cycles from PCLK edge to FS generating.           */
      __IOM uint32_t FS2PCM_OUT_PCLK_CYCLES : 3;/*!< [23..21] Number of PCLK cycles from FS pulse to PCM_OUT transmission.     */
      __IOM uint32_t FS2PCM_IN_PCLK_CYCLES : 3; /*!< [26..24] Number of PCLK cycles from FS pulse to PCM_IN sampling.          */
      __IOM uint32_t FS_ON_RISING : 1;          /*!< [27..27] Select FS PCLK edge generation'1' &#8211; PCLK rising
                                                     edge'0' &#8211; PCLK falling edge                                         */
      __IOM uint32_t PCM_IN_ON_RISING : 1;      /*!< [28..28] Select PCM_IN PCLK edge sampling'1' &#8211; PCLK rising
                                                     edge'0' &#8211; PCLK falling edge                                         */
      __IOM uint32_t PCM_OUT_ON_RISING : 1;     /*!< [29..29] Select PCM_OUT PCLK edge transmission'1' &#8211; PCLK
                                                     rising edge'0' &#8211; PCLK falling edge                                  */
            uint32_t            : 2;
    } TIMING_CFG_b;
  } ;
  
  union {
    __IOM uint32_t GLOBAL_CFG;                  /*!< (@ 0x00000004) GLOBAL_CFG                                                 */
    
    struct {
      __IOM uint32_t PCM_ENABLE : 1;            /*!< [0..0] 1 - PCM/I2S controlelr is enabled0 - PCM/I2S controller
                                                     is disabled                                                               */
      __IOM uint32_t PCM_TS0    : 5;            /*!< [5..1] Select valid time slot for RX/TX TS0 FIFO                          */
      __IOM uint32_t PCM_TS1    : 5;            /*!< [10..6] Select valid time slot for RX/TX TS1 FIFO                         */
      __IOM uint32_t PCM_OUT_LSB_FIRST : 1;     /*!< [11..11] Select TX FIFO bit order transmission on the PCM_OUT
                                                     line. '1' &#8211; TX FIFO data LSB is the first PCM_OUT
                                                     transmitted bit.'0' &#8211; TX FIFO data LSB is the last
                                                     PCM_OUT transmitted bit.                                                  */
      __IOM uint32_t PCM_IN_LSB_FIRST : 1;      /*!< [12..12] Select PCM_IN bit order read from RX FIFO'1' &#8211;
                                                     RX FIFO data MSB is the last PCM_IN sampled bit.'0' &#8211;
                                                     RX FIFO data MSB is the first PCM_IN sampled bit.                         */
      __IOM uint32_t TS1_DISABLE : 1;           /*!< [13..13] 1- Disable TS1 buffers TX and RX0 - TS1 buffers are
                                                     enabled                                                                   */
      __IOM uint32_t NUM_OF_TS  : 5;            /*!< [18..14] Number of time slots up to 32. Values [0..31] peratin
                                                     to [1..32] time slots.In I2S mode this is the length of
                                                     one frame (left channel plus right channel)                               */
      __IOM uint32_t OCP_BYTE_ENABLE : 2;       /*!< [20..19] OCP byte enable when reading/writing to FIFO's in words
                                                     which byte on the OCP data is valid.0 - pcm_ocp_MData[7:0]
                                                     is valid1 - pcm_ocp_MData[15:8] is valid2 - pcm_ocp_MData[23:16]
                                                     is valid3 - pcm_ocp_MData[31:24] is valid                                 */
      __IOM uint32_t PCM_TS1_16BITS : 1;        /*!< [21..21] 1 - Time slot 1 is in 16 bits mode0 - Time slot 1 is
                                                     in 8 bits mode                                                            */
      __IOM uint32_t PCM_TS0_16BITS : 1;        /*!< [22..22] 1 - Time slot 0 is in 16 bits mode0 - Time slot 0 is
                                                     in 8 bits mode                                                            */
      __IOM uint32_t I2S_FS_MODE : 1;           /*!< [23..23] 1 - I2s frame sync mode0 - PCM mode                              */
      __IOM uint32_t I2S_FS_INV : 1;            /*!< [24..24] 1 - I2S Frame sync inverted logic0 - I2S standard frame
                                                     sync                                                                      */
      __IOM uint32_t FIFO_ACCESS_WORD : 1;      /*!< [25..25] 1 - TX/RX FIFO word (4 bytes) access0 - byte access              */
      __IOM uint32_t FIFO_SINGLE_MODE : 1;      /*!< [26..26] combine the two TX/RX FIFO's to one bug FIFO                     */
      __IOM uint32_t FIFO_ACCESS_BIG_ENDIAN : 1;/*!< [27..27] 1 - In FIFO word access use big endian0 - litlle endian          */
            uint32_t            : 1;
      __IOM uint32_t FIFO_HALF_WORD_SWAP : 1;   /*!< [29..29] Enable half work swapping to and from fifos                      */
            uint32_t            : 2;
    } GLOBAL_CFG_b;
  } ;
  
  union {
    __IOM uint32_t NCO_RATIO_L;                 /*!< (@ 0x00000008) NCO_RATIO_L                                                */
    
    struct {
      __IOM uint32_t RATIO_REGISTER_L : 32;     /*!< [31..0] 32 lower bits of the NCO ratio register                           */
    } NCO_RATIO_L_b;
  } ;
  
  union {
    __IOM uint32_t NCO_RATIO_H;                 /*!< (@ 0x0000000C) NCO_RATIO_H                                                */
    
    struct {
      __IOM uint32_t RATIO_REGISTER_H : 16;     /*!< [15..0] 16 upper bits of the NCO ratio register                           */
            uint32_t            : 16;
    } NCO_RATIO_H_b;
  } ;
  
  union {
    __IOM uint32_t NCO_DRATIO;                  /*!< (@ 0x00000010) NCO_DRATIO                                                 */
    
    struct {
      __IOM uint32_t DELTA_RATIO : 32;          /*!< [31..0] NCO Delta ratio register                                          */
    } NCO_DRATIO_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_STAT;                /*!< (@ 0x00000014) FIFO_TX_STAT                                               */
    
    struct {
      __IM  uint32_t FIFO_TX_TS0_DATA_CNT : 10; /*!< [9..0] Time slot 0 TX FIFO data count                                     */
            uint32_t            : 6;
      __IM  uint32_t FIFO_TX_TS1_DATA_CNT : 10; /*!< [25..16] Time slot 1 TX FIFO data count                                   */
            uint32_t            : 6;
    } FIFO_TX_STAT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_RX_STAT;                /*!< (@ 0x00000018) FIFO_RX_STAT                                               */
    
    struct {
      __IM  uint32_t FIFO_RX_TS0_DATA_CNT : 10; /*!< [9..0] Time slot 0 RX FIFO data count                                     */
            uint32_t            : 6;
      __IM  uint32_t FIFO_RX_TS1_DATA_CNT : 10; /*!< [25..16] Time slot 1 RX FIFO data count                                   */
            uint32_t            : 6;
    } FIFO_RX_STAT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_ERR_STAT;            /*!< (@ 0x0000001C) FIFO_TX_ERR_STAT                                           */
    
    struct {
      __IOM uint32_t FIFO_TX_TS1_OFLOW_CNT : 8; /*!< [7..0] Time slot 1 TX FIFO overflow counter - how many times
                                                     write was performed to the FIFO while in overflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_TX_TS1_UFLOW_CNT : 8; /*!< [15..8] Time slot 1 TX FIFO underflow counter - how many times
                                                     read was performed from the FIFO while in underflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_TX_TS0_OFLOW_CNT : 8; /*!< [23..16] Time slot 0 TX FIFO overflow counter - how many times
                                                     write was performed to the FIFO while in overflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_TX_TS0_UFLOW_CNT : 8; /*!< [31..24] Time slot 0 TX FIFO underflow counter - how many times
                                                     read was performed from the FIFO while in underflow state.
                                                     Reading clears this counter                                               */
    } FIFO_TX_ERR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_RX_ERR_STAT;            /*!< (@ 0x00000020) FIFO_RX_ERR_STAT                                           */
    
    struct {
      __IOM uint32_t FIFO_RX_TS1_OFLOW_CNT : 8; /*!< [7..0] Time slot 1 RX FIFO overflow counter - how many times
                                                     write was performed to the FIFO while in overflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_RX_TS1_UFLOW_CNT : 8; /*!< [15..8] Time slot 1 RX FIFO underflow counter - how many times
                                                     read was performed from the FIFO while in underflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_RX_TS0_OFLOW_CNT : 8; /*!< [23..16] Time slot 0 RX FIFO overflow counter - how many times
                                                     write was performed to the FIFO while in overflow state.
                                                     Reading clears this counter                                               */
      __IOM uint32_t FIFO_RX_TS0_UFLOW_CNT : 8; /*!< [31..24] Time slot 0 RX FIFO underflow counter - how many times
                                                     read was performed from the FIFO while in underflow state.
                                                     Reading clears this counter                                               */
    } FIFO_RX_ERR_STAT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_TS0_THR_INT;         /*!< (@ 0x00000024) FIFO_TX_TS0_THR_INT                                        */
    
    struct {
      __IOM uint32_t TX_TS0_THR_LO : 11;        /*!< [10..0] Low threshold configuration when TX TS0 data count is
                                                     lower thanthis threshold pcm_thr_int will assert if tx_ts0_cross_thr_lo_i
                                                     t is high the pcm_thr_int will assert only when TX TS0
                                                     data count will cross below this threshold.                               */
            uint32_t            : 5;
      __IOM uint32_t TX_TS0_THR_HI : 11;        /*!< [26..16] High threshold configuration when TX TS0 data count
                                                     is higher than this threshold pcm_thr_int will assert if
                                                     tx_ts0_cross_thr_hi_int is high the pcm_thr_int will assert
                                                     only when TX TS0 data count will cross behind this threshold.             */
            uint32_t            : 5;
    } FIFO_TX_TS0_THR_INT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_TS1_THR_INT;         /*!< (@ 0x00000028) FIFO_TX_TS1_THR_INT                                        */
    
    struct {
      __IOM uint32_t TX_TS1_THR_LO : 11;        /*!< [10..0] Low threshold configuration when TX TS1 data count is
                                                     lower thanthis threshold pcm_thr_int will assert if tx_ts1_cross_thr_lo_i
                                                     t is high the pcm_thr_int will assert only when TX TS1
                                                     data count will cross below this threshold.                               */
            uint32_t            : 5;
      __IOM uint32_t TX_TS1_THR_HI : 11;        /*!< [26..16] High threshold configuration when TX TS1 data count
                                                     is higher than this threshold pcm_thr_int will assert if
                                                     tx_ts1_cross_thr_hi_int is high the pcm_thr_int will assert
                                                     only when TX TS01data count will cross behind this threshold.             */
            uint32_t            : 5;
    } FIFO_TX_TS1_THR_INT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_RX_TS0_THR_INT;         /*!< (@ 0x0000002C) FIFO_RX_TS0_THR_INT                                        */
    
    struct {
      __IOM uint32_t RX_TS0_THR_LO : 11;        /*!< [10..0] Low threshold configuration when RX TS0 data count is
                                                     lower thanthis threshold pcm_thr_int will assert if rx_ts0_cross_thr_lo_i
                                                     t is high the pcm_thr_int will assert only when RX TS0
                                                     data count will cross below this threshold.                               */
            uint32_t            : 5;
      __IOM uint32_t RX_TS0_THR_HI : 11;        /*!< [26..16] High threshold configuration when RX TS0 data count
                                                     is higher than this threshold pcm_thr_int will assert if
                                                     rx_ts0_cross_thr_hi_int is high the pcm_thr_int will assert
                                                     only when RX TS0 data count will cross behind this threshold.             */
            uint32_t            : 5;
    } FIFO_RX_TS0_THR_INT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_RX_TS1_THR_INT;         /*!< (@ 0x00000030) FIFO_RX_TS1_THR_INT                                        */
    
    struct {
      __IOM uint32_t RX_TS1_THR_LO : 11;        /*!< [10..0] Low threshold configuration when RX TS1 data count is
                                                     lower thanthis threshold pcm_thr_int will assert if rx_ts1_cross_thr_lo_i
                                                     t is high the pcm_thr_int will assert only when RX TS1
                                                     data count will cross below this threshold.                               */
            uint32_t            : 5;
      __IOM uint32_t RX_TS1_THR_HI : 11;        /*!< [26..16] High threshold configuration when RX TS1 data count
                                                     is higher than this threshold pcm_thr_int will assert if
                                                     rx_ts1_cross_thr_hi_int is high the pcm_thr_int will assert
                                                     only when RX TS01data count will cross behind this threshold.             */
            uint32_t            : 5;
    } FIFO_RX_TS1_THR_INT_b;
  } ;
  
  union {
    __IOM uint32_t THR_INT_CFG;                 /*!< (@ 0x00000034) THR_INT_CFG                                                */
    
    struct {
      __IOM uint32_t RX_TS1_THR_LO_INT_MSK : 1; /*!< [0..0] Mask RX TS1 low threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t RX_TS1_THR_HI_INT_MSK : 1; /*!< [1..1] Mask RX TS1 high threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t RX_TS0_THR_LO_INT_MSK : 1; /*!< [2..2] Mask RX TS0 low threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t RX_TS0_THR_HI_INT_MSK : 1; /*!< [3..3] Mask RX TS0 high threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t TX_TS1_THR_LO_INT_MSK : 1; /*!< [4..4] Mask TX TS1 low threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t TX_TS1_THR_HI_INT_MSK : 1; /*!< [5..5] Mask TX TS1 high threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t TX_TS0_THR_LO_INT_MSK : 1; /*!< [6..6] Mask TX TS0 low threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t TX_TS0_THR_HI_INT_MSK : 1; /*!< [7..7] Mask TX TS0 high threshold interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t RX_TS1_CROSS_THR_LO_INT_EN : 1;/*!< [8..8] When this bit is high threshold RX FIFO TS1 interrupt
                                                     will assert only when data count crossed blow the threshold.              */
      __IOM uint32_t RX_TS1_CROSS_THR_HI_INT_EN : 1;/*!< [9..9] When this bit is high threshold RX FIFO TS1 interrupt
                                                     will assert only when data count crossed behind the threshold.            */
      __IOM uint32_t RX_TS0_CROSS_THR_LO_INT_EN : 1;/*!< [10..10] When this bit is high threshold RX FIFO TS0 interrupt
                                                     will assert only when data count crossed blow the threshold.              */
      __IOM uint32_t RX_TS0_CROSS_THR_HI_INT_EN : 1;/*!< [11..11] When this bit is high threshold RX FIFO TS0 interrupt
                                                     will assert only when data count crossed behind the threshold.            */
      __IOM uint32_t TX_TS1_CROSS_THR_LO_INT_EN : 1;/*!< [12..12] When this bit is high threshold TX FIFO TS1 interrupt
                                                     will assert only when data count crossed blow the threshold.              */
      __IOM uint32_t TX_TS1_CROSS_THR_HI_INT_EN : 1;/*!< [13..13] When this bit is high threshold TX FIFO TS1 interrupt
                                                     will assert only when data count crossed behind the threshold.            */
      __IOM uint32_t TX_TS0_CROSS_THR_LO_INT_EN : 1;/*!< [14..14] When this bit is high threshold TX FIFO TS0 interrupt
                                                     will assert onlywhen data count crossed blow the threshold.               */
      __IOM uint32_t TX_TS0_CROSS_THR_HI_INT_EN : 1;/*!< [15..15] When this bit is high threshold TX FIFO TS0 interrupt
                                                     will assert onlywhen data count crossed behind the threshold.             */
            uint32_t            : 16;
    } THR_INT_CFG_b;
  } ;
  
  union {
    __IOM uint32_t THR_INT_CSE;                 /*!< (@ 0x00000038) Reading from this register will clear the interrupts       */
    
    struct {
      __IOM uint32_t RX_TS1_THR_LO_INT_CSE : 1; /*!< [0..0] RX TS1 low threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t RX_TS1_THR_HI_INT_CSE : 1; /*!< [1..1] RX TS1 high threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t RX_TS0_THR_LO_INT_CSE : 1; /*!< [2..2] RX TS0 low threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t RX_TS0_THR_HI_INT_CSE : 1; /*!< [3..3] RX TS0 high threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t TX_TS1_THR_LO_INT_CSE : 1; /*!< [4..4] TX TS1 low threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t TX_TS1_THR_HI_INT_CSE : 1; /*!< [5..5] TX TS1 high threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t TX_TS0_THR_LO_INT_CSE : 1; /*!< [6..6] TX TS0 low threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
      __IOM uint32_t TX_TS0_THR_HI_INT_CSE : 1; /*!< [7..7] TX TS0 high threshold interrupt cause (interrupt source
                                                     after masking)                                                            */
            uint32_t            : 24;
    } THR_INT_CSE_b;
  } ;
  
  union {
    __IOM uint32_t THR_INT_SRC;                 /*!< (@ 0x0000003C) THR_INT_SRC                                                */
    
    struct {
      __IM  uint32_t RX_TS1_THR_LO_INT_SRC : 1; /*!< [0..0] RX TS1 low threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t RX_TS1_THR_HI_INT_SRC : 1; /*!< [1..1] RX TS1 high threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t RX_TS0_THR_LO_INT_SRC : 1; /*!< [2..2] RX TS0 low threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t RX_TS0_THR_HI_INT_SRC : 1; /*!< [3..3] RX TS0 high threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t TX_TS1_THR_LO_INT_SRC : 1; /*!< [4..4] TX TS1 low threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t TX_TS1_THR_HI_INT_SRC : 1; /*!< [5..5] TX TS1 high threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t TX_TS0_THR_LO_INT_SRC : 1; /*!< [6..6] TX TS0 low threshold interrupt source (before interrupt
                                                     masking)                                                                  */
      __IM  uint32_t TX_TS0_THR_HI_INT_SRC : 1; /*!< [7..7] TX TS0 high threshold interrupt source (before interrupt
                                                     masking)                                                                  */
            uint32_t            : 24;
    } THR_INT_SRC_b;
  } ;
  
  union {
    __IOM uint32_t ERR_INT_CFG;                 /*!< (@ 0x00000040) ERR_INT_CFG                                                */
    
    struct {
      __IOM uint32_t FIFO_RX_TS1_OFLOW_INT_MSK : 1;/*!< [0..0] Mask RX TS1 overflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_RX_TS1_UFLOW_INT_MSK : 1;/*!< [1..1] Mask RX TS1 underflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_RX_TS0_OFLOW_INT_MSK : 1;/*!< [2..2] Mask RX TS0 overflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_RX_TS0_UFLOW_INT_MSK : 1;/*!< [3..3] Mask RX TS0 underflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_TX_TS1_OFLOW_INT_MSK : 1;/*!< [4..4] Mask TX TS1 overflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_TX_TS1_UFLOW_INT_MSK : 1;/*!< [5..5] Mask TX TS1 underflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_TX_TS0_OFLOW_INT_MSK : 1;/*!< [6..6] Mask TX TS0 overflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
      __IOM uint32_t FIFO_TX_TS0_UFLOW_INT_MSK : 1;/*!< [7..7] Mask TX TS0 underflow interrupt (1- interrupt masked;
                                                     0 - interrupt enabled)                                                    */
            uint32_t            : 24;
    } ERR_INT_CFG_b;
  } ;
  
  union {
    __IOM uint32_t ERR_INT_CSE;                 /*!< (@ 0x00000044) Reading from this register will clear the interrupts       */
    
    struct {
      __IOM uint32_t FIFO_RX_TS1_OFLOW_INT_CSE : 1;/*!< [0..0] RX TS1 overflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_RX_TS1_UFLOW_INT_CSE : 1;/*!< [1..1] RX TS1 underflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_RX_TS0_OFLOW_INT_CSE : 1;/*!< [2..2] RX TS0 overflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_RX_TS0_UFLOW_INT_CSE : 1;/*!< [3..3] RX TS0 underflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_TX_TS1_OFLOW_INT_CSE : 1;/*!< [4..4] TX TS1 overflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_TX_TS1_UFLOW_INT_CSE : 1;/*!< [5..5] TX TS1 underflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_TX_TS0_OFLOW_INT_CSE : 1;/*!< [6..6] TX TS0 overflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
      __IOM uint32_t FIFO_TX_TS0_UFLOW_INT_CSE : 1;/*!< [7..7] TX TS0 underflow interrupt cause (interrupt source after
                                                     masking)                                                                  */
            uint32_t            : 24;
    } ERR_INT_CSE_b;
  } ;
  
  union {
    __IOM uint32_t TS0_THR_DMA;                 /*!< (@ 0x00000048) TS0_THR_DMA                                                */
    
    struct {
      __IOM uint32_t DMA_TX_TS0_THR_LO : 11;    /*!< [10..0] TS0 TX low threshold for triggering the DMA                       */
            uint32_t            : 5;
      __IOM uint32_t DMA_RX_TS0_THR_HI : 11;    /*!< [26..16] TS0 RX high threshold for triggering the DMA                     */
            uint32_t            : 5;
    } TS0_THR_DMA_b;
  } ;
  
  union {
    __IOM uint32_t TS1_THR_DMA;                 /*!< (@ 0x0000004C) TS1_THR_DMA                                                */
    
    struct {
      __IOM uint32_t DMA_TX_TS1_THR_LO : 11;    /*!< [10..0] TS1 TX low threshold for triggering the DMA                       */
            uint32_t            : 5;
      __IOM uint32_t DMA_RX_TS1_THR_HI : 11;    /*!< [26..16] TS1 RX high threshold for triggering the DMA                     */
            uint32_t            : 5;
    } TS1_THR_DMA_b;
  } ;
  
  union {
    __IOM uint32_t PCM_STAT;                    /*!< (@ 0x00000050) PCM_STAT                                                   */
    
    struct {
      __IM  uint32_t PCM_CLK_RUN : 1;           /*!< [0..0] Indication if PCM clock is running                                 */
            uint32_t            : 31;
    } PCM_STAT_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_CLEAR;                  /*!< (@ 0x00000054) FIFO_CLEAR                                                 */
    
    struct {
      __IOM uint32_t RX         : 1;            /*!< [0..0] RX FIFO's clear                                                    */
      __IOM uint32_t TX         : 1;            /*!< [1..1] TX FIFO's clear                                                    */
            uint32_t            : 30;
    } FIFO_CLEAR_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_TS0_RD_HALT_THR;     /*!< (@ 0x00000058) FIFO_TX_TS0_RD_HALT_THR                                    */
    
    struct {
      __IOM uint32_t RD_HALT_THR : 11;          /*!< [10..0] TX FIFO TS0 Read halt threshold - controller reads from
                                                     this fifo are blocked once it is getting empty and until
                                                     reaches this threshhold                                                   */
            uint32_t            : 21;
    } FIFO_TX_TS0_RD_HALT_THR_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_TX_TS1_RD_HALT_THR;     /*!< (@ 0x0000005C) FIFO_TX_TS1_RD_HALT_THR                                    */
    
    struct {
      __IOM uint32_t RD_HALT_THR : 11;          /*!< [10..0] TX FIFO TS1 Read halt threshold - controller reads from
                                                     this fifo are blocked once it is getting empty and until
                                                     reaches this threshhold                                                   */
            uint32_t            : 21;
    } FIFO_TX_TS1_RD_HALT_THR_b;
  } ;
  
  union {
    __IOM uint32_t SIDETONE_CFG;                /*!< (@ 0x00000060) SIDETONE_CFG                                               */
    
    struct {
      __IOM uint32_t RX_TS0_SIDETONE_VOLUME : 4;/*!< [3..0] Volume control of RX TS0 - 6db nodes0x0 - max volume0xf
                                                     - min volume                                                              */
      __IOM uint32_t TS0_SIDETONE_SRC_SEL : 2;  /*!< [5..4] Selects sidetone channel for TS00 - Received TS01 - Received
                                                     TS12 - Avarage of received TS0 and TS1                                    */
            uint32_t            : 2;
      __IOM uint32_t TS0_SIDETONE_EN : 1;       /*!< [8..8] TS0 Sidetone enable                                                */
            uint32_t            : 3;
      __IOM uint32_t RX_TS1_SIDETONE_VOLUME : 4;/*!< [15..12] Volume control of RX TS1 - 6db nodes0x0 - max volume0xf
                                                     - min volume                                                              */
      __IOM uint32_t TS1_SIDETONE_SRC_SEL : 2;  /*!< [17..16] Selects sidetone channel for TS10 - Received TS01 -
                                                     Received TS12 - Avarage of received TS0 and TS1                           */
            uint32_t            : 2;
      __IOM uint32_t TS1_SIDETONE_EN : 1;       /*!< [20..20] TS1 Sidetone enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SIDETONE_SIGNED : 1;       /*!< [24..24] Defines if sidetone is using signed or unsigned symbols0
                                                     - unsigned1 - signed                                                      */
            uint32_t            : 7;
    } SIDETONE_CFG_b;
  } ;
  __IM  uint32_t  RESERVED[103];
  
  union {
    __IOM uint32_t FIFO_TX_TS0;                 /*!< (@ 0x00000200) FIFO_TX_TS0                                                */
    
    struct {
      __OM  uint32_t FIFO_TX_TS0_DATA : 32;     /*!< [31..0] Time slot 0 TX FIFO write data                                    */
    } FIFO_TX_TS0_b;
  } ;
  __IM  uint32_t  RESERVED1[127];
  
  union {
    __IOM uint32_t FIFO_TX_TS1;                 /*!< (@ 0x00000400) FIFO_TX_TS1                                                */
    
    struct {
      __OM  uint32_t FIFO_TX_TS1_DATA : 32;     /*!< [31..0] Time slot 1 TX FIFO write data                                    */
    } FIFO_TX_TS1_b;
  } ;
  __IM  uint32_t  RESERVED2[127];
  
  union {
    __IOM uint32_t FIFO_RX_TS0;                 /*!< (@ 0x00000600) FIFO_RX_TS0                                                */
    
    struct {
      __IM  uint32_t FIFO_RX_TS0_Q : 32;        /*!< [31..0] Time slot 0 RX FIFO read data                                     */
    } FIFO_RX_TS0_b;
  } ;
  __IM  uint32_t  RESERVED3[127];
  
  union {
    __IOM uint32_t FIFO_RX_TS1;                 /*!< (@ 0x00000800) FIFO_RX_TS1                                                */
    
    struct {
      __IM  uint32_t FIFO_RX_TS1_Q : 32;        /*!< [31..0] Time slot 1 RX FIFO read data                                     */
    } FIFO_RX_TS1_b;
  } ;
} PCM_Type;                                     /*!< Size = 2052 (0x804)                                                       */



/* =========================================================================================================================== */
/* ================                                          PWM_DAC                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PWM 1-bit DAC controllers (PWM_DAC)
  */

typedef struct {                                /*!< (@ 0x016C0000) PWM_DAC Structure                                          */
  
  union {
    __IOM uint32_t OP_RATE0;                    /*!< (@ 0x00000000) OP_RATE0                                                   */
    
    struct {
      __IOM uint32_t OP_RATE    : 4;            /*!< [3..0] Clock divider - by how much to divide the system clock
                                                     at the input to the counter that generates the PWM output                 */
      __IOM uint32_t EN         : 1;            /*!< [4..4] Enable the PWM                                                     */
      __IOM uint32_t DISABLE_VAL : 1;           /*!< [5..5] Output value of the PWM when it is disabled                        */
      __IOM uint32_t MASK_HW_DISABLE : 1;       /*!< [6..6] Mask the external HW disable. In DF2 the external HW
                                                     disable is connected to the PMU's OVP (over voltage protection).1
                                                     - Ignore the external HW disable0 - halt the PWM when the
                                                     external HW disable is asserted                                           */
            uint32_t            : 25;
    } OP_RATE0_b;
  } ;
  
  union {
    __IOM uint32_t RATE0;                       /*!< (@ 0x00000004) RATE0                                                      */
    
    struct {
      __IOM uint32_t RATE       : 10;           /*!< [9..0] Rate of the output PWM                                             */
            uint32_t            : 22;
    } RATE0_b;
  } ;
  
  union {
    __IOM uint32_t OP_RATE1;                    /*!< (@ 0x00000008) OP_RATE1                                                   */
    
    struct {
      __IOM uint32_t OP_RATE    : 4;            /*!< [3..0] Clock divider - by how much to divide the system clock
                                                     at the input to the counter that generates the PWM output                 */
      __IOM uint32_t EN         : 1;            /*!< [4..4] Enable the PWM                                                     */
      __IOM uint32_t DISABLE_VAL : 1;           /*!< [5..5] Output value of the PWM when it is disabled                        */
      __IOM uint32_t MASK_HW_DISABLE : 1;       /*!< [6..6] Mask the external HW disable. In DF2 the external HW
                                                     disable is connected to the PMU's OVP (over voltage protection).1
                                                     - Ignore the external HW disable0 - halt the PWM when the
                                                     external HW disable is asserted                                           */
            uint32_t            : 25;
    } OP_RATE1_b;
  } ;
  
  union {
    __IOM uint32_t RATE1;                       /*!< (@ 0x0000000C) RATE1                                                      */
    
    struct {
      __IOM uint32_t RATE       : 10;           /*!< [9..0] Rate of the output PWM                                             */
            uint32_t            : 22;
    } RATE1_b;
  } ;
  
  union {
    __IOM uint32_t OP_RATE2;                    /*!< (@ 0x00000010) OP_RATE2                                                   */
    
    struct {
      __IOM uint32_t OP_RATE    : 4;            /*!< [3..0] Clock divider - by how much to divide the system clock
                                                     at the input to the counter that generates the PWM output                 */
      __IOM uint32_t EN         : 1;            /*!< [4..4] Enable the PWM                                                     */
      __IOM uint32_t DISABLE_VAL : 1;           /*!< [5..5] Output value of the PWM when it is disabled                        */
      __IOM uint32_t MASK_HW_DISABLE : 1;       /*!< [6..6] Mask the external HW disable. In DF2 the external HW
                                                     disable is connected to the PMU's OVP (over voltage protection).1
                                                     - Ignore the external HW disable0 - halt the PWM when the
                                                     external HW disable is asserted                                           */
            uint32_t            : 25;
    } OP_RATE2_b;
  } ;
  
  union {
    __IOM uint32_t RATE2;                       /*!< (@ 0x00000014) RATE2                                                      */
    
    struct {
      __IOM uint32_t RATE       : 10;           /*!< [9..0] Rate of the output PWM                                             */
            uint32_t            : 22;
    } RATE2_b;
  } ;
  
  union {
    __IOM uint32_t OP_RATE3;                    /*!< (@ 0x00000018) OP_RATE3                                                   */
    
    struct {
      __IOM uint32_t OP_RATE    : 4;            /*!< [3..0] Clock divider - by how much to divide the system clock
                                                     at the input to the counter that generates the PWM output                 */
      __IOM uint32_t EN         : 1;            /*!< [4..4] Enable the PWM                                                     */
      __IOM uint32_t DISABLE_VAL : 1;           /*!< [5..5] Output value of the PWM when it is disabled                        */
      __IOM uint32_t MASK_HW_DISABLE : 1;       /*!< [6..6] Mask the external HW disable. In DF2 the external HW
                                                     disable is connected to the PMU's OVP (over voltage protection).1
                                                     - Ignore the external HW disable0 - halt the PWM when the
                                                     external HW disable is asserted                                           */
            uint32_t            : 25;
    } OP_RATE3_b;
  } ;
  
  union {
    __IOM uint32_t RATE3;                       /*!< (@ 0x0000001C) RATE3                                                      */
    
    struct {
      __IOM uint32_t RATE       : 10;           /*!< [9..0] Rate of the output PWM                                             */
            uint32_t            : 22;
    } RATE3_b;
  } ;
} PWM_DAC_Type;                                 /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                        PMP_IO_CFG                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PMP_IO_CFG (PMP_IO_CFG)
  */

typedef struct {                                /*!< (@ 0x0D000300) PMP_IO_CFG Structure                                       */
  
  union {
    __IOM uint32_t CS_N0;                       /*!< (@ 0x00000000) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_CS_N0 : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_CS_N0 : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_CS_N0 : 1;/*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_CS_N0 : 1;/*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_CS_N0 : 1;/*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_CS_N0 : 1;/*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_CS_N0 : 1;/*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } CS_N0_b;
  } ;
  
  union {
    __IOM uint32_t CS_N1;                       /*!< (@ 0x00000004) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_CS_N1 : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_CS_N1 : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_CS_N1 : 1;/*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_CS_N1 : 1;/*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_CS_N1 : 1;/*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_CS_N1 : 1;/*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_CS_N1 : 1;/*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } CS_N1_b;
  } ;
  
  union {
    __IOM uint32_t SCK;                         /*!< (@ 0x00000008) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_SCK : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_SCK : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_SCK : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_SCK : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_SCK : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_SCK : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_SCK : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SCK_b;
  } ;
  
  union {
    __IOM uint32_t RESETN;                      /*!< (@ 0x0000000C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_RESETN : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_RESETN : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_RESETN : 1;/*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_RESETN : 1;/*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_RESETN : 1;/*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_RESETN : 1;/*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_RESETN : 1;/*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } RESETN_b;
  } ;
  
  union {
    __IOM uint32_t DQS;                         /*!< (@ 0x00000010) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_DQS : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_DQS : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_DQS : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_DQS : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_DQS : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_DQS : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_DQS : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } DQS_b;
  } ;
  
  union {
    __IOM uint32_t IO0;                         /*!< (@ 0x00000014) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO0 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO0 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO0 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO0 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO0 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO0 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO0 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO0_b;
  } ;
  
  union {
    __IOM uint32_t IO1;                         /*!< (@ 0x00000018) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO1 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO1 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO1 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO1 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO1 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO1 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO1 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO1_b;
  } ;
  
  union {
    __IOM uint32_t IO2;                         /*!< (@ 0x0000001C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO2 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO2 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO2 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO2 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO2 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO2 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO2 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO2_b;
  } ;
  
  union {
    __IOM uint32_t IO3;                         /*!< (@ 0x00000020) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO3 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO3 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO3 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO3 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO3 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO3 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO3 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO3_b;
  } ;
  
  union {
    __IOM uint32_t IO4;                         /*!< (@ 0x00000024) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO4 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO4 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO4 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO4 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO4 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO4 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO4 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO4_b;
  } ;
  
  union {
    __IOM uint32_t IO5;                         /*!< (@ 0x00000028) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO5 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO5 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO5 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO5 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO5 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO5 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO5 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO5_b;
  } ;
  
  union {
    __IOM uint32_t IO6;                         /*!< (@ 0x0000002C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO6 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO6 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO6 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO6 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO6 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO6 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO6 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO6_b;
  } ;
  
  union {
    __IOM uint32_t IO7;                         /*!< (@ 0x00000030) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_IO7 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_IO7 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_IO7 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_IO7 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_IO7 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_IO7 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_IO7 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } IO7_b;
  } ;
  
  union {
    __IOM uint32_t CS_N2;                       /*!< (@ 0x00000034) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH0_CS_N2 : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH0_CS_N2 : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH0_CS_N2 : 1;/*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH0_CS_N2 : 1;/*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH0_CS_N2 : 1;/*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH0_CS_N2 : 1;/*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH0_CS_N2 : 1;/*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } CS_N2_b;
  } ;
} PMP_IO_CFG_Type;                              /*!< Size = 56 (0x38)                                                          */



/* =========================================================================================================================== */
/* ================                                        PMP_IO_PAR                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PMP_IO_PAR (PMP_IO_PAR)
  */

typedef struct {                                /*!< (@ 0x0D000600) PMP_IO_PAR Structure                                       */
  
  union {
    __IOM uint32_t CS_N0;                       /*!< (@ 0x00000000) CS_N0                                                      */
    
    struct {
      __IOM uint32_t CS_N0      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } CS_N0_b;
  } ;
  
  union {
    __IOM uint32_t CS_N1;                       /*!< (@ 0x00000004) CS_N1                                                      */
    
    struct {
      __IOM uint32_t CS_N1      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } CS_N1_b;
  } ;
  
  union {
    __IOM uint32_t SCK;                         /*!< (@ 0x00000008) SCK                                                        */
    
    struct {
      __IOM uint32_t SCK        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SCK_b;
  } ;
  
  union {
    __IOM uint32_t RESETN;                      /*!< (@ 0x0000000C) RESETN                                                     */
    
    struct {
      __IOM uint32_t RESETN     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } RESETN_b;
  } ;
  
  union {
    __IOM uint32_t DQS;                         /*!< (@ 0x00000010) DQS                                                        */
    
    struct {
      __IOM uint32_t DQS        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } DQS_b;
  } ;
  
  union {
    __IOM uint32_t IO0;                         /*!< (@ 0x00000014) IO0                                                        */
    
    struct {
      __IOM uint32_t IO0        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO0_b;
  } ;
  
  union {
    __IOM uint32_t IO1;                         /*!< (@ 0x00000018) IO1                                                        */
    
    struct {
      __IOM uint32_t IO1        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO1_b;
  } ;
  
  union {
    __IOM uint32_t IO2;                         /*!< (@ 0x0000001C) IO2                                                        */
    
    struct {
      __IOM uint32_t IO2        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO2_b;
  } ;
  
  union {
    __IOM uint32_t IO3;                         /*!< (@ 0x00000020) IO3                                                        */
    
    struct {
      __IOM uint32_t IO3        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO3_b;
  } ;
  
  union {
    __IOM uint32_t IO4;                         /*!< (@ 0x00000024) IO4                                                        */
    
    struct {
      __IOM uint32_t IO4        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO4_b;
  } ;
  
  union {
    __IOM uint32_t IO5;                         /*!< (@ 0x00000028) IO5                                                        */
    
    struct {
      __IOM uint32_t IO5        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO5_b;
  } ;
  
  union {
    __IOM uint32_t IO6;                         /*!< (@ 0x0000002C) IO6                                                        */
    
    struct {
      __IOM uint32_t IO6        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO6_b;
  } ;
  
  union {
    __IOM uint32_t IO7;                         /*!< (@ 0x00000030) IO7                                                        */
    
    struct {
      __IOM uint32_t IO7        : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } IO7_b;
  } ;
  
  union {
    __IOM uint32_t CS_N2;                       /*!< (@ 0x00000034) CS_N2                                                      */
    
    struct {
      __IOM uint32_t CS_N2      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } CS_N2_b;
  } ;
} PMP_IO_PAR_Type;                              /*!< Size = 56 (0x38)                                                          */



/* =========================================================================================================================== */
/* ================                                 SERIAL_FLASH_CTRL_MANUAL                                  ================ */
/* =========================================================================================================================== */


/**
  * @brief FLASH manual control (SERIAL_FLASH_CTRL_MANUAL)
  */

typedef struct {                                /*!< (@ 0x0D006200) SERIAL_FLASH_CTRL_MANUAL Structure                         */
  
  union {
    __IOM uint32_t CS_SEL;                      /*!< (@ 0x00000000) chip select                                                */
    
    struct {
      __IOM uint32_t CS_SEL     : 1;            /*!< [0..0] Selector between 2 serial flahs CS (sf_cs_n0 and sf_cs_n1);
                                                     in order to support 2 serial flash devices. Default: 0                    */
      __IOM uint32_t CS_BY_ADDR : 2;            /*!< [2..1] Who controlls the CS; in order to support big serial
                                                     flashes that have two CSs. Default: 00 - controlled by
                                                     SW in bit 0; 01 - bit 23 controlls the CS; 10 - bit 24
                                                     controlls the CS; 11 - bit 25 controlls the CS                            */
            uint32_t            : 29;
    } CS_SEL_b;
  } ;
  
  union {
    __IOM uint32_t CMD;                         /*!< (@ 0x00000004) Command                                                    */
    
    struct {
      __IOM uint32_t CMD_OPCODE : 8;            /*!< [7..0] Command opcode that is transferred to the SF. For future
                                                     use; this command can be anything. Current opcodes supported
                                                     by known SF memories are:'h9F &#8211; RDID (read ID)'h06
                                                     &#8211; WREN (write enable)'h04 &#8211; WRDI (write disable)'h05
                                                     &#8211; RDSR (read status register)'h01 &#8211; WRSR (write
                                                     status register)'h20 &#8211; SE (sector erase)'h52; 'hD8
                                                     &#8211; BE (block erase)'h60; 'hC7 &#8211; CE (chip erase)'hB9
                                                     &#8211; DP (deep power down)'hAB &#8211; RDP (release from
                                                     deep power                                                                */
      __IOM uint32_t ADDR_SIZE  : 3;            /*!< [10..8] 3 bits of address size; to select the number of address
                                                     bytes that should be driven to the SF memory. Dummy byte;
                                                     if needed; should be included in the address data. For
                                                     command which have only opcode (no address or dummy bytes
                                                     needed); address size should be '0'.The address value itself
                                                     is taken from the command address register; which is 24
                                                     bits. The command address register should be set prior
                                                     to writing to the command register.0 &#8211; no address
                                                     is driven.1 &#8211; 1 LSByte of address register                          */
      __IOM uint32_t DATA_SIZE  : 3;            /*!< [13..11] 3 bits of data size; which specify how many bytes will
                                                     be read or written. For write transaction; the SF controller
                                                     will drive 1-4 bytes of data; taken from command data register.
                                                     For read transaction; the SF controller will read 1-4 bytes
                                                     of data. Example command: WRSR (write status register);
                                                     RDID (read ID). For write; the command data register should
                                                     be set prior to writing to the command register. 0 &#8211;
                                                     no data is driven/read.1 &#8211; 1 byte is driven/read.2
                                                     &#8211; 2 bytes is driven/read.                                           */
      __IOM uint32_t INT_EN     : 1;            /*!< [14..14] When enabled; the SF controller continues to read the
                                                     status register until it will match interrupt data value
                                                     & mask. Then; an interrupt will be asserted; notifying
                                                     the match. This field should be set only for read status
                                                     register (RDSR) operation. Otherwise; The SF controller
                                                     may be deadlocked and need to be reset. Interrupt data
                                                     value and mask registers should be set prior to writing
                                                     to this register.This register will be self cleared to
                                                     'interrupt disabled' when command is done. Thus; preventing
                                                     re                                                                        */
      __IOM uint32_t DIRECTION  : 1;            /*!< [15..15] Set the direction of the operation (read or write).
                                                     During read; the SF controller will assembly data from
                                                     si pin; During write; the SF controller will drive data
                                                     through so pin.0 &#8211; Read1 &#8211; Write                              */
            uint32_t            : 16;
    } CMD_b;
  } ;
  
  union {
    __IOM uint32_t CMD_16;                      /*!< (@ 0x00000008) same as CMD if command of 16 is needed                     */
    
    struct {
      __IOM uint32_t CMD_OPCODE : 16;           /*!< [15..0] Command opcode that is transferred to the SF. For future
                                                     use; this command can be anything. Current opcodes supported
                                                     by known SF memories are:'h9F &#8211; RDID (read ID)'h06
                                                     &#8211; WREN (write enable)'h04 &#8211; WRDI (write disable)'h05
                                                     &#8211; RDSR (read status register)'h01 &#8211; WRSR (write
                                                     status register)'h20 &#8211; SE (sector erase)'h52; 'hD8
                                                     &#8211; BE (block erase)'h60; 'hC7 &#8211; CE (chip erase)'hB9
                                                     &#8211; DP (deep power down)'hAB &#8211; RDP (release from
                                                     deep power                                                                */
      __IOM uint32_t ADDR_SIZE  : 3;            /*!< [18..16] 3 bits of address size; to select the number of address
                                                     bytes that should be driven to the SF memory. Dummy byte;
                                                     if needed; should be included in the address data. For
                                                     command which have only opcode (no address or dummy bytes
                                                     needed); address size should be '0'.The address value itself
                                                     is taken from the command address register; which is 24
                                                     bits. The command address register should be set prior
                                                     to writing to the command register.0 &#8211; no address
                                                     is driven.1 &#8211; 1 LSByte of address register                          */
      __IOM uint32_t DATA_SIZE  : 3;            /*!< [21..19] 3 bits of data size; which specify how many bytes will
                                                     be read or written. For write transaction; the SF controller
                                                     will drive 1-4 bytes of data; taken from command data register.
                                                     For read transaction; the SF controller will read 1-4 bytes
                                                     of data. Example command: WRSR (write status register);
                                                     RDID (read ID). For write; the command data register should
                                                     be set prior to writing to the command register. 0 &#8211;
                                                     no data is driven/read.1 &#8211; 1 byte is driven/read.2
                                                     &#8211; 2 bytes is driven/read.                                           */
      __IOM uint32_t INT_EN     : 1;            /*!< [22..22] When enabled; the SF controller continues to read the
                                                     status register until it will match interrupt data value
                                                     & mask. Then; an interrupt will be asserted; notifying
                                                     the match. This field should be set only for read status
                                                     register (RDSR) operation. Otherwise; The SF controller
                                                     may be deadlocked and need to be reset. Interrupt data
                                                     value and mask registers should be set prior to writing
                                                     to this register.This register will be self cleared to
                                                     'interrupt disabled' when command is done. Thus; preventing
                                                     re                                                                        */
      __IOM uint32_t DIRECTION  : 1;            /*!< [23..23] Set the direction of the operation (read or write).
                                                     During read; the SF controller will assembly data from
                                                     si pin; During write; the SF controller will drive data
                                                     through so pin.0 &#8211; Read1 &#8211; Write                              */
            uint32_t            : 8;
    } CMD_16_b;
  } ;
  
  union {
    __IOM uint32_t CMD_ADDR;                    /*!< (@ 0x0000000C) Command address                                            */
    
    struct {
      __IOM uint32_t CMD_ADDR   : 26;           /*!< [25..0] 26 bits of address field; which should be driven to
                                                     the SF memory after the opcode. Number of address bytes
                                                     (0-4) driven is set by 'address size' field in the command
                                                     register. If Dummy bytes are needed; they should be included
                                                     in the address value. Hence; the design supports up to
                                                     1 dummy byte + 3 address bytes. This register should be
                                                     set prior to writing to the command register.                             */
            uint32_t            : 1;
      __IOM uint32_t CMD_PSRAM_EN : 1;          /*!< [27..27] when 1b1. psram is enabled. For DM/DQS driving                   */
      __IOM uint32_t CMD_DATA_BYTE_EN : 4;      /*!< [31..28] 4 bits of data byte enable field; which should be driven
                                                     to the controoler in case of write to PSRAM; for commands
                                                     requiring data writing; the default is F; hence all the
                                                     4 bytes are beind sent. Usable only in PSRAM. When want
                                                     to write only part of the word. need to write 0 to the
                                                     masked bits. in sflash. this is dont care.                                */
    } CMD_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t CMD_DATA;                    /*!< (@ 0x00000010) Command data                                               */
    
    struct {
      __IOM uint32_t CMD_DATA   : 32;           /*!< [31..0] 32 bits of data field; which should be driven to the
                                                     SF memory; for commands requiring data writing; such as
                                                     WRSR (write status register). This register should be set
                                                     prior to writing to the command register.Data is delivered
                                                     to the serial flash from the msb - meaning if only a byte
                                                     should be written it should be placed in the MSB                          */
    } CMD_DATA_b;
  } ;
  
  union {
    __IOM uint32_t CMD_RESULT0;                 /*!< (@ 0x00000014) Command result0                                            */
    
    struct {
      __IM  uint32_t CMD_RESULT0 : 32;          /*!< [31..0] This register will store the result of relevant commands
                                                     such as ID; status register; etc. Reading this register
                                                     will clear the sfc_cmd_result0_valid field in Status register.Data
                                                     is read from the serial flash to the lsb - meaning if only
                                                     a byte should be read it will reside in the LSB                           */
    } CMD_RESULT0_b;
  } ;
  
  union {
    __IOM uint32_t CMD_RESULT1;                 /*!< (@ 0x00000018) Command result1                                            */
    
    struct {
      __IM  uint32_t CMD_RESULT1 : 32;          /*!< [31..0] This register will store the result of relevant commands
                                                     such as ID; status register; etc. in case of more than
                                                     one word.Reading this register will clear the sfc_cmd_result1_valid
                                                     field in Status register.Data is read from the serial flash
                                                     to the lsb - meaning if only a byte should be read it will
                                                     reside in the LSB                                                         */
    } CMD_RESULT1_b;
  } ;
  
  union {
    __IOM uint32_t INT_DATA_VALUE;              /*!< (@ 0x0000001C) interrupt data                                             */
    
    struct {
      __IOM uint32_t INT_DATA_VALUE : 32;       /*!< [31..0] 32 bits of interrupt data value field; to be compared
                                                     with status register; when setting the interrupt enable
                                                     bit in the command register. The SF controller will keep
                                                     polling SF status register until it matches this value;
                                                     masked with interrupt data mask register. An interrupt
                                                     will be issued upon such match; and thus notify on command
                                                     status. This register should be set prior to writing to
                                                     the command register.                                                     */
    } INT_DATA_VALUE_b;
  } ;
  
  union {
    __IOM uint32_t INT_DATA_MASK;               /*!< (@ 0x00000020) Interupt data mask                                         */
    
    struct {
      __IOM uint32_t INT_DATA_MASK : 32;        /*!< [31..0] 32 bits of interrupt data mask field; to be compared
                                                     with when interrupt enable bit in command register is set.
                                                     The SF controller will poll SF status register until it
                                                     matches interrupt value; masked with interrupt data mask
                                                     (this register). An interrupt will be issued upon such
                                                     match; and thus notify on command status. This register
                                                     should be set prior to writing to the command register.0
                                                     &#8211; don&#8217;t mask (compare)1 &#8211; mask (don't
                                                     compare)                                                                  */
    } INT_DATA_MASK_b;
  } ;
  
  union {
    __IOM uint32_t XIP_PAT;                     /*!< (@ 0x00000024) XIP Xonfiguration                                          */
    
    struct {
      __IOM uint32_t XIP_IN_PATTERN : 8;        /*!< [7..0] xip in pattern to drive                                            */
      __IOM uint32_t XIP_IN_PAT_SIZE : 3;       /*!< [10..8] xip in pattern size to drive                                      */
            uint32_t            : 5;
      __IOM uint32_t XIP_OUT_PATTERN : 8;       /*!< [23..16] xip out pattern to drive                                         */
      __IOM uint32_t XIP_OUT_PAT_SIZE : 3;      /*!< [26..24] xip out pattern size to drive                                    */
            uint32_t            : 3;
      __IOM uint32_t XIP_PAT_DURING_XIP : 1;    /*!< [30..30] once in XIP does dummypattern comes from XIP in or
                                                     dummy pattern                                                             */
      __IOM uint32_t XIP_EN     : 1;            /*!< [31..31] XIP enable - once set the next RD will do the XIP in
                                                     pattern and after first RD no opcode is issued. Once disabled
                                                     the first RD will do the out pattern and xip is no longer
                                                     active. In between no other commands but RD are allowed                   */
    } XIP_PAT_b;
  } ;
  
  union {
    __IOM uint32_t INTERRUPT_MASK;              /*!< (@ 0x00000028) Interrupt mask                                             */
    
    struct {
      __IOM uint32_t SFCI_INT   : 1;            /*!< [0..0] when 1b1. masks the current ability of the intruupt.This
                                                     interrupt includes write or erase done interrupts.                        */
      __IOM uint32_t CMD_RESULT0 : 1;           /*!< [1..1] when 1b1. masks the current ability of the intruupt                */
      __IOM uint32_t CMD_RESULT1 : 1;           /*!< [2..2] when 1b1. masks the current ability of the intruupt                */
      __IOM uint32_t PERF_CNTR_MSB : 1;         /*!< [3..3] when 1b1. masks the current ability of the intruupt.This
                                                     triggered when msb of the perfoments conter goes to 1.                    */
            uint32_t            : 28;
    } INTERRUPT_MASK_b;
  } ;
  
  union {
    __IOM uint32_t HALT;                        /*!< (@ 0x0000002C) halt                                                       */
    
    struct {
      __IOM uint32_t SEL        : 1;            /*!< [0..0] When a bit is set the SW does not allow write or read              */
            uint32_t            : 31;
    } HALT_b;
  } ;
  
  union {
    __IOM uint32_t DUMMY_PATTERN;               /*!< (@ 0x00000030) dummy pattern                                              */
    
    struct {
      __IOM uint32_t DUMMY_PATTERN : 32;        /*!< [31..0] Dummy pattern for read transactions. Used with dummy
                                                     pattern size register.                                                    */
    } DUMMY_PATTERN_b;
  } ;
  
  union {
    __IOM uint32_t STATUS;                      /*!< (@ 0x00000034) status                                                     */
    
    struct {
      __IM  uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status.0 &#8211; interrupt was not asserted.1
                                                     &#8211; interrupt was asserted.                                           */
      __IM  uint32_t CMD_RESULT1_VALID : 1;     /*!< [1..1] Command result is valid and may be read from the Command
                                                     Result 1 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t CMD_RESULT0_VALID : 1;     /*!< [2..2] Command result is valid and may be read from the Command
                                                     Result 0 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t HALT_ACTIVE : 1;           /*!< [3..3] halt is taking place - no more rd or wr from fabric till
                                                     removed                                                                   */
      __IM  uint32_t SM         : 4;            /*!< [7..4] The current State Machine of Main controller block.                */
      __IM  uint32_t MAIN_SM    : 5;            /*!< [12..8] The current State Machine of Main controller block.               */
      __IM  uint32_t WR_FIFO_FULL : 5;          /*!< [17..13] wr fifo full                                                     */
      __IM  uint32_t WR_FIFO_EMPTY : 5;         /*!< [22..18] wr fifo empty                                                    */
      __IM  uint32_t PERF_MSB_FLIP : 1;         /*!< [23..23] one of the performance count msb flipped - read it
                                                     all                                                                       */
      __IM  uint32_t WR_ACTIVE  : 1;            /*!< [24..24] write states are on now                                          */
      __IM  uint32_t ERASE_ACTIVE : 1;          /*!< [25..25] erase states are now working                                     */
      __IM  uint32_t RESUME_ACTIVE : 1;         /*!< [26..26] resume command works now (very fast - will be hard
                                                     to catch it)                                                              */
      __IM  uint32_t SUSPEN_ACTIVE : 1;         /*!< [27..27] suspen command on                                                */
      __IM  uint32_t ER_WR_ACTIVE : 1;          /*!< [28..28] the erase or write are still active even if suspend
                                                     is active it is still on                                                  */
      __IM  uint32_t ER_WR_ACTIVE_AGENT : 3;    /*!< [31..29] which of the agents is active in erase or write right
                                                     now - 7 is error 6 is none 0-4 are the agents                             */
    } STATUS_b;
  } ;
  
  union {
    __IOM uint32_t STATUS_RC;                   /*!< (@ 0x00000038) status read-clear                                          */
    
    struct {
      __IM  uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status.0 &#8211; interrupt was not asserted.1
                                                     &#8211; interrupt was asserted.                                           */
      __IM  uint32_t CMD_RESULT1_VALID : 1;     /*!< [1..1] Command result is valid and may be read from the Command
                                                     Result 1 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t CMD_RESULT0_VALID : 1;     /*!< [2..2] Command result is valid and may be read from the Command
                                                     Result 0 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t HALT_ACTIVE : 1;           /*!< [3..3] halt is taking place - no more rd or wr from fabric till
                                                     removed                                                                   */
      __IM  uint32_t SM         : 4;            /*!< [7..4] The current State Machine of Main controller block.                */
      __IM  uint32_t MAIN_SM    : 5;            /*!< [12..8] The current State Machine of Main controller block.               */
      __IM  uint32_t WR_FIFO_FULL : 5;          /*!< [17..13] wr fifo full                                                     */
      __IM  uint32_t WR_FIFO_EMPTY : 5;         /*!< [22..18] wr fifo empty                                                    */
      __IM  uint32_t PERF_MSB_FLIP : 1;         /*!< [23..23] one of the performance count msb flipped - read it
                                                     all                                                                       */
      __IM  uint32_t WR_ACTIVE  : 1;            /*!< [24..24] write states are on now                                          */
      __IM  uint32_t ERASE_ACTIVE : 1;          /*!< [25..25] erase states are now working                                     */
      __IM  uint32_t RESUME_ACTIVE : 1;         /*!< [26..26] resume command works now (very fast - will be hard
                                                     to catch it)                                                              */
      __IM  uint32_t SUSPEN_ACTIVE : 1;         /*!< [27..27] suspen command on                                                */
      __IM  uint32_t ER_WR_ACTIVE : 1;          /*!< [28..28] the erase or write are still active even if suspend
                                                     is active it is still on                                                  */
      __IM  uint32_t ER_WR_ACTIVE_AGENT : 3;    /*!< [31..29] which of the agents is active in erase or write right
                                                     now - 7 is error 6 is none 0-4 are the agents                             */
    } STATUS_RC_b;
  } ;
  
  union {
    __IOM uint32_t ERR_STATUS;                  /*!< (@ 0x0000003C) error status                                               */
    
    struct {
      __IM  uint32_t ERR_STAT   : 1;            /*!< [0..0] error status - bit 12-16                                           */
      __IM  uint32_t WR_ERROR   : 1;            /*!< [1..1] a write request came within a buffer to a non cosecutive
                                                     address                                                                   */
      __IM  uint32_t PP_ERROR   : 1;            /*!< [2..2] Error indication asserted in case a PP command was executed
                                                     without preceding WREN.                                                   */
      __IM  uint32_t WR_ERROR_FIRST_ADDR : 24;  /*!< [26..3] the first addr in the cunk of the wr error (the good
                                                     one)                                                                      */
      __IM  uint32_t WR_ERROR_AGENT : 3;        /*!< [29..27] the agent that cased wr_error                                    */
            uint32_t            : 2;
    } ERR_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t ERR_STATUS_RC;               /*!< (@ 0x00000040) error status read-clear                                    */
    
    struct {
      __IOM uint32_t ERR_STAT   : 1;            /*!< [0..0] error status - bit 12-16                                           */
      __IM  uint32_t WR_ERROR   : 1;            /*!< [1..1] a write request came within a buffer to a non cosecutive
                                                     address                                                                   */
      __IM  uint32_t PP_ERROR   : 1;            /*!< [2..2] Error indication asserted in case a PP command was executed
                                                     without preceding WREN.                                                   */
      __IM  uint32_t WR_ERROR_FIRST_ADDR : 24;  /*!< [26..3] the first addr in the cunk of the wr error (the good
                                                     one)                                                                      */
      __IM  uint32_t WR_ERROR_AGENT : 3;        /*!< [29..27] the agent that cased wr_error                                    */
            uint32_t            : 2;
    } ERR_STATUS_RC_b;
  } ;
  
  union {
    __IOM uint32_t CUSTOM_OPCODE_EN;            /*!< (@ 0x00000044) custom opcode enable                                       */
    
    struct {
      __IOM uint32_t CUSTOM_OPCODE_EN : 1;      /*!< [0..0] Custom opcode; in case more than 1 byte is needed. Relevant
                                                     if sfr_custom_opcode_en == 1.                                             */
            uint32_t            : 31;
    } CUSTOM_OPCODE_EN_b;
  } ;
  
  union {
    __IOM uint32_t CUSTOM_OPCODE;               /*!< (@ 0x00000048) custome opcode                                             */
    
    struct {
      __IOM uint32_t CUSTOM_OPCODE : 32;        /*!< [31..0] Custom opcode; in case more than 1 byte is needed. Relevant
                                                     if sfr_custom_opcode_en == 1.                                             */
    } CUSTOM_OPCODE_b;
  } ;
  
  union {
    __IOM uint32_t STATUS2;                     /*!< (@ 0x0000004C) status2                                                    */
    
    struct {
      __IM  uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status.0 &#8211; interrupt was not asserted.1
                                                     &#8211; interrupt was asserted.                                           */
      __IM  uint32_t CMD_RESULT1_VALID : 1;     /*!< [1..1] Command result is valid and may be read from the Command
                                                     Result 1 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t CMD_RESULT0_VALID : 1;     /*!< [2..2] Command result is valid and may be read from the Command
                                                     Result 0 register. This field will be cleared after the
                                                     Command Result register is read.0 &#8211; Command Result
                                                     is not valid1 &#8211; Command Result is valid                             */
      __IM  uint32_t HALT_ACTIVE : 1;           /*!< [3..3] halt is taking place - no more rd or wr from fabric till
                                                     removed                                                                   */
      __IM  uint32_t SM         : 4;            /*!< [7..4] The current State Machine of Main controller block.                */
      __IM  uint32_t MAIN_SM    : 5;            /*!< [12..8] The current State Machine of Main controller block.               */
      __IM  uint32_t WR_FIFO_FULL : 5;          /*!< [17..13] wr fifo full                                                     */
      __IM  uint32_t WR_FIFO_EMPTY : 5;         /*!< [22..18] wr fifo empty                                                    */
      __IM  uint32_t RD_ACTIVE  : 1;            /*!< [23..23] read is active                                                   */
      __IM  uint32_t WR_ACTIVE  : 1;            /*!< [24..24] write states are on now                                          */
      __IM  uint32_t ERASE_ACTIVE : 1;          /*!< [25..25] erase states are now working                                     */
      __IM  uint32_t RESUME_ACTIVE : 1;         /*!< [26..26] resume command works now (very fast - will be hard
                                                     to catch it)                                                              */
      __IM  uint32_t SUSPEN_ACTIVE : 1;         /*!< [27..27] suspen command on                                                */
      __IM  uint32_t ER_WR_ACTIVE : 1;          /*!< [28..28] the erase or write are still active even if suspend
                                                     is active it is still on                                                  */
      __IM  uint32_t ER_WR_ACTIVE_AGENT : 3;    /*!< [31..29] which of the agents is active in erase or write right
                                                     now - 7 is error 6 is none 0-4 are the agents                             */
    } STATUS2_b;
  } ;
} SERIAL_FLASH_CTRL_MANUAL_Type;                /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                               SERIAL_FLASH_CTRL_MCU_SUBSYS                                ================ */
/* =========================================================================================================================== */


/**
  * @brief SERIAL_FLASH_CTRL_MCU_SUBSYS (SERIAL_FLASH_CTRL_MCU_SUBSYS)
  */

typedef struct {                                /*!< (@ 0x0D006280) SERIAL_FLASH_CTRL_MCU_SUBSYS Structure                     */
  
  union {
    __IOM uint32_t CFG_SYSTEM;                  /*!< (@ 0x00000000) MCU channel configuration                                  */
    
    struct {
      __IOM uint32_t CLEAR_PREFETCH_MCU_PULSE : 1;/*!< [0..0] writing 1b1 to this field generates a puls to clear all
                                                     prefetch data for current agent.Note that in order to use
                                                     this. the agent must be idle! Use carefully.                              */
      __IOM uint32_t CLEAR_PREFETCH_MCU_OTHER_PULSE : 1;/*!< [1..1] writing 1b1 to this field generates a puls to clear all
                                                     prefetch data for current agent.Note that in order to use
                                                     this. the agent must be idle! Use carefully.                              */
            uint32_t            : 30;
    } CFG_SYSTEM_b;
  } ;
  
  union {
    __IOM uint32_t STATUS_MCU;                  /*!< (@ 0x00000004) MCU channel status                                         */
    
    struct {
      __IM  uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status.0 &#8211; interrupt was not asserted.1
                                                     &#8211; interrupt was asserted.                                           */
            uint32_t            : 3;
      __IM  uint32_t WR_FIFO_EMPTY : 1;         /*!< [4..4] wr fifo empty                                                      */
      __IM  uint32_t WR_FIFO_FULL : 1;          /*!< [5..5] wr fifo full                                                       */
      __IM  uint32_t WR_FIFO_ALL_WRITE_IN_FIFO : 1;/*!< [6..6] all data needed to be in the fifo for this write is already
                                                     arrved to fifo.                                                           */
            uint32_t            : 1;
      __IM  uint32_t WRITE_PENDING_TO_ARB : 1;  /*!< [8..8] there is a data in the fifo which waits for arbitration            */
      __IM  uint32_t WRITE_EXECUTING : 1;       /*!< [9..9] write is now got arbitration and ececutes. This will
                                                     stay 1b1 untill interrupt will come. Even in suspend mode.                */
      __IM  uint32_t ERASE_PENDING_TO_ARB : 1;  /*!< [10..10] there is a data in the fifo which waits for arbitration          */
      __IM  uint32_t ERASE_EXECUTING : 1;       /*!< [11..11] write is now got arbitration and ececutes. This will
                                                     stay 1b1 untill interrupt will come. Even in suspend mode.                */
            uint32_t            : 20;
    } STATUS_MCU_b;
  } ;
  
  union {
    __IOM uint32_t STATUS_MCU_RC;               /*!< (@ 0x00000008) MCU channel status read clear                              */
    
    struct {
      __IOM uint32_t INT_STAT   : 1;            /*!< [0..0] Interrupt status.0 &#8211; interrupt was not asserted.1
                                                     &#8211; interrupt was asserted.                                           */
            uint32_t            : 3;
      __IM  uint32_t WR_FIFO_EMPTY : 1;         /*!< [4..4] wr fifo empty                                                      */
      __IM  uint32_t WR_FIFO_FULL : 1;          /*!< [5..5] wr fifo full                                                       */
      __IM  uint32_t WR_FIFO_ALL_WRITE_IN_FIFO : 1;/*!< [6..6] all data needed to be in the fifo for this write is already
                                                     arrved to fifo.                                                           */
            uint32_t            : 1;
      __IM  uint32_t WRITE_PENDING_TO_ARB : 1;  /*!< [8..8] there is a data in the fifo which waits for arbitration            */
      __IM  uint32_t WRITE_EXECUTING : 1;       /*!< [9..9] write is now got arbitration and ececutes. This will
                                                     stay 1b1 untill interrupt will come. Even in suspend mode.                */
      __IM  uint32_t ERASE_PENDING_TO_ARB : 1;  /*!< [10..10] there is a data in the fifo which waits for arbitration          */
      __IM  uint32_t ERASE_EXECUTING : 1;       /*!< [11..11] write is now got arbitration and ececutes. This will
                                                     stay 1b1 untill interrupt will come. Even in suspend mode.                */
            uint32_t            : 20;
    } STATUS_MCU_RC_b;
  } ;
  
  union {
    __IOM uint32_t WRITE_COUNT;                 /*!< (@ 0x0000000C) MCU channel write count                                    */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t VAL        : 7;            /*!< [8..2] how many words to write out before allowing INT to requester
                                                     (may be more if has more to write out if not enough write
                                                     words come - no INT is issued!)                                           */
            uint32_t            : 7;
      __IM  uint32_t OUT_COUNTER : 7;           /*!< [22..16] how many words were sent to the memory by now                    */
            uint32_t            : 1;
      __IM  uint32_t IN_COUNTER : 7;            /*!< [30..24] how many words were received till now                            */
      __IOM uint32_t COUNT_CLR  : 1;            /*!< [31..31] clear the counters - due to error need to start over.
                                                     Note that if write had started already (wr_out_count is
                                                     non zero) this may cause unexpected data out                              */
    } WRITE_COUNT_b;
  } ;
  
  union {
    __IOM uint32_t SFC_ERASE_CFG;               /*!< (@ 0x00000010) MCU channel erase configuration                            */
    
    struct {
      __IOM uint32_t REQUEST_ERASE : 1;         /*!< [0..0] write 1 bit to this register in order to request erase.
                                                     The bit will be 1'b1 untill erase is done                                 */
            uint32_t            : 3;
      __IOM uint32_t OPCODE_SEL : 1;            /*!< [4..4] selects between opcode0 and opcode1 predefined inSFC_ERASE_OPCODE_CFG
                                                     per cs                                                                    */
            uint32_t            : 3;
      __IOM uint32_t ADDR       : 24;           /*!< [31..8] erase requestor address                                           */
    } SFC_ERASE_CFG_b;
  } ;
  
  union {
    __IOM uint32_t ERROR_STATUS;                /*!< (@ 0x00000014) MCU channel error status                                   */
    
    struct {
      __IM  uint32_t WR_ERR_STAT : 1;           /*!< [0..0] a write request came within a buffer to a non cosecutive
                                                     address                                                                   */
            uint32_t            : 1;
      __IM  uint32_t PP_ERROR   : 1;            /*!< [2..2] Error indication asserted in case a PP command was executed
                                                     without preceding WREN.Note that this is common for all
                                                     systems                                                                   */
      __IM  uint32_t WR_ERROR_FIRST_ADDR : 24;  /*!< [26..3] the first addr in the cunk of the wr error (the good
                                                     one)Note that this is common for all systems. When reading.
                                                     Need to understand in case this is correct addr.READ Clear
                                                     will clear for all systems                                                */
            uint32_t            : 5;
    } ERROR_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t ERROR_STATUS_RC;             /*!< (@ 0x00000018) MCU channel error status read clear                        */
    
    struct {
      __IOM uint32_t WR_ERR_STAT : 1;           /*!< [0..0] a write request came within a buffer to a non cosecutive
                                                     address                                                                   */
            uint32_t            : 1;
      __IOM uint32_t PP_ERROR   : 1;            /*!< [2..2] Error indication asserted in case a PP command was executed
                                                     without preceding WREN.Note that this is common for all
                                                     systemsREAD Clear will clear for all systems                              */
      __IOM uint32_t WR_ERROR_FIRST_ADDR : 24;  /*!< [26..3] the first addr in the cunk of the wr error (the good
                                                     one)Note that this is common for all systems. When reading.
                                                     Need to understand in case this is correct addr                           */
            uint32_t            : 5;
    } ERROR_STATUS_RC_b;
  } ;
  
  union {
    __IOM uint32_t WRITE_PROTECT;               /*!< (@ 0x0000001C) write protect                                              */
    
    struct {
      __IOM uint32_t WRITE_PROTECT : 1;         /*!< [0..0] Don't allow writing and erasing of the flash from this
                                                     subsystem.1'b0 - no write protection1'b1 - flash is write
                                                     protected. The protection is done using the security module
                                                     therefore need to configure the relevant security registers
                                                     in the SERIAL_FLASH_CTRL_SECURITY group even if security
                                                     is disabled. Need to configure all windows and permissions
                                                     for this susbystem's connIDs and the junk pointers                        */
            uint32_t            : 31;
    } WRITE_PROTECT_b;
  } ;
} SERIAL_FLASH_CTRL_MCU_SUBSYS_Type;            /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                SERIAL_FLASH_CTRL_SECURITY                                 ================ */
/* =========================================================================================================================== */


/**
  * @brief SERIAL_FLASH_CTRL_SECURITY (SERIAL_FLASH_CTRL_SECURITY)
  */

typedef struct {                                /*!< (@ 0x0D006C00) SERIAL_FLASH_CTRL_SECURITY Structure                       */
  
  union {
    __IOM uint32_t SECURED_CONID0_WINDOW0;      /*!< (@ 0x00000000) MSE FLASH window 0                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID0_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID0_WINDOW1;      /*!< (@ 0x00000004) MSE FLASH window 1                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID0_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID1_WINDOW0;      /*!< (@ 0x00000008) ISE FLASH window 0                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID1_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID1_WINDOW1;      /*!< (@ 0x0000000C) ISE FLASH window 1                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID1_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID2_WINDOW0;      /*!< (@ 0x00000010) MCU FLASH window 0                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID2_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID2_WINDOW1;      /*!< (@ 0x00000014) MCU FLASH window 1                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID2_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID3_WINDOW0;      /*!< (@ 0x00000018) PMPA FLASH window 0                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end - PMPA full access bydefault                          */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant. PMPA full access by default                   */
            uint32_t            : 5;
    } SECURED_CONID3_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID3_WINDOW1;      /*!< (@ 0x0000001C) PMPA FLASH window 1                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID3_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID4_WINDOW0;      /*!< (@ 0x00000020) PMP FLASH window 0                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID4_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID4_WINDOW1;      /*!< (@ 0x00000024) PMP FLASH window 1                                         */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID4_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID5_WINDOW0;      /*!< (@ 0x00000028) PMPG FLASH window 0                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID5_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID5_WINDOW1;      /*!< (@ 0x0000002C) PMPG FLASH window 1                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID5_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID6_WINDOW0;      /*!< (@ 0x00000030) MODEM FLASH window 0                                       */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID6_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID6_WINDOW1;      /*!< (@ 0x00000034) MODEM FLASH window 0                                       */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID6_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID7_WINDOW0;      /*!< (@ 0x00000038) PMPS FLASH window 0                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID7_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID7_WINDOW1;      /*!< (@ 0x0000003C) PMPS FLASH window 1                                        */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
            uint32_t            : 5;
    } SECURED_CONID7_WINDOW1_b;
  } ;
  __IM  uint32_t  RESERVED[16];
  
  union {
    __IOM uint32_t SECURED_FREE_WINDOW0;        /*!< (@ 0x00000080) General usage FLASH window 0                               */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
      __IOM uint32_t CONID      : 3;            /*!< [29..27] defines the connid for the configurable security window          */
            uint32_t            : 2;
    } SECURED_FREE_WINDOW0_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_FREE_WINDOW1;        /*!< (@ 0x00000084) General usage FLASH window 1                               */
    
    struct {
      __IOM uint32_t START      : 12;           /*!< [11..0] sector start                                                      */
      __IOM uint32_t END        : 12;           /*!< [23..12] sector end                                                       */
      __IOM uint32_t CMD_EN     : 3;            /*!< [26..24] defines which command is relevant for the window (erase;write;read)
                                                     0-not relevant 1- relevant                                                */
      __IOM uint32_t CONID      : 3;            /*!< [29..27] defines the connid for the configurable security window          */
            uint32_t            : 2;
    } SECURED_FREE_WINDOW1_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_WR_JUNK_ADDR;        /*!< (@ 0x00000088) Dummy WR address                                           */
    
    struct {
      __IOM uint32_t WR_JUNK_ADDR : 26;         /*!< [25..0] address for junk write (on write violation)                       */
            uint32_t            : 6;
    } SECURED_WR_JUNK_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_RD_JUNK_ADDR;        /*!< (@ 0x0000008C) Dummy RD address                                           */
    
    struct {
      __IOM uint32_t RD_JUNK_ADDR : 26;         /*!< [25..0] address for junk read (on read violation)                         */
            uint32_t            : 6;
    } SECURED_RD_JUNK_ADDR_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID0_OFFSET;       /*!< (@ 0x00000090) MSE FLASH offset                                           */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID0_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID1_OFFSET;       /*!< (@ 0x00000094) ISE FLASH offset                                           */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID1_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID2_OFFSET;       /*!< (@ 0x00000098) MCU FLASH offset                                           */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID2_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID3_OFFSET;       /*!< (@ 0x0000009C) PMPA FLASH offset                                          */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID3_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID4_OFFSET;       /*!< (@ 0x000000A0) PMP FLASH offset                                           */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID4_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID5_OFFSET;       /*!< (@ 0x000000A4) PMPG FLASH offset                                          */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID5_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID6_OFFSET;       /*!< (@ 0x000000A8) MODEM FLASH offset                                         */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID6_OFFSET_b;
  } ;
  
  union {
    __IOM uint32_t SECURED_CONID7_OFFSET;       /*!< (@ 0x000000AC) PMPS FLASH offset                                          */
    
    struct {
      __IOM uint32_t OFFSET     : 12;           /*!< [11..0] conid offset (applied before flash security check)                */
            uint32_t            : 20;
    } SECURED_CONID7_OFFSET_b;
  } ;
  __IM  uint32_t  RESERVED1[7];
  
  union {
    __IOM uint32_t SECURITY_RD_WR_DEBUG;        /*!< (@ 0x000000CC) debug                                                      */
    
    struct {
      __IOM uint32_t SFC_VIOLATION_ADDR : 26;   /*!< [25..0] FLAM sticky indication of violating address                       */
      __IOM uint32_t SFC_VIOLATION_CONID : 3;   /*!< [28..26] FLAM sticky indication of violating permission group             */
      __IOM uint32_t SFC_VIOLATION_FLAG : 1;    /*!< [29..29] FLAM sticky indication of security violation (0 - no
                                                     violation; 1=read/write violation occurred)                               */
            uint32_t            : 2;
    } SECURITY_RD_WR_DEBUG_b;
  } ;
  
  union {
    __IOM uint32_t SECURITY_ER_DEBUG;           /*!< (@ 0x000000D0) debug                                                      */
    
    struct {
      __IOM uint32_t SFC_VIOLATION_ADDR : 26;   /*!< [25..0] FLAM sticky indication of violating address                       */
      __IOM uint32_t SFC_VIOLATION_CONID : 3;   /*!< [28..26] FLAM sticky indication of violating permission group             */
      __IOM uint32_t SFC_VIOLATION_FLAG : 1;    /*!< [29..29] FLAM sticky indication of security violation (0 - no
                                                     violation; 1=erase violation occured)                                     */
            uint32_t            : 2;
    } SECURITY_ER_DEBUG_b;
  } ;
} SERIAL_FLASH_CTRL_SECURITY_Type;              /*!< Size = 212 (0xd4)                                                         */



/* =========================================================================================================================== */
/* ================                                        GSP_REGFILE                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief GSP_REGFILE (GSP_REGFILE)
  */

typedef struct {                                /*!< (@ 0x0C112000) GSP_REGFILE Structure                                      */
  
  union {
    __IOM uint32_t MCU_ROM_ADDR_0X0;            /*!< (@ 0x00000000) ADDR=0x0 of the MCU processor                              */
    
    struct {
      __IOM uint32_t MCU_ROM_ADDR_0X0 : 32;     /*!< [31..0] MCU 'ROM' address 0x0 (stack-pointer)                             */
    } MCU_ROM_ADDR_0X0_b;
  } ;
  
  union {
    __IOM uint32_t MCU_ROM_ADDR_0X4;            /*!< (@ 0x00000004) ADDR=0x4 of the MCU processor                              */
    
    struct {
      __IOM uint32_t MCU_ROM_ADDR_0X4 : 32;     /*!< [31..0] MCU 'ROM' address 0x4 (reset-vector)                              */
    } MCU_ROM_ADDR_0X4_b;
  } ;
  
  union {
    __IOM uint32_t MCU_ROM_ADDR_0X8;            /*!< (@ 0x00000008) ADDR=0x8 of the MCU processor                              */
    
    struct {
      __IOM uint32_t MCU_ROM_ADDR_0X8 : 32;     /*!< [31..0] MCU 'ROM' address 0x8 (nmi)                                       */
    } MCU_ROM_ADDR_0X8_b;
  } ;
  
  union {
    __IOM uint32_t MCU_ROM_ADDR_0XC;            /*!< (@ 0x0000000C) ADDR=0xC of the MCU processor                              */
    
    struct {
      __IOM uint32_t MCU_ROM_ADDR_0XC : 32;     /*!< [31..0] MCU 'ROM' address 0x0 (hard-fault)                                */
    } MCU_ROM_ADDR_0XC_b;
  } ;
  
  union {
    __IOM uint32_t M4_RST_REQ_TARGET;           /*!< (@ 0x00000010) The MCU reset request policy                               */
    
    struct {
      __IOM uint32_t M4_RST_REQ_TARGET : 2;     /*!< [1..0] impact of m4-sys-reset-request:0 - m4 reset cycle1 -
                                                     mcu (inc. m4) reset cycle (m4 delayed)2 - gpm reset request3
                                                     - do nothing                                                              */
            uint32_t            : 30;
    } M4_RST_REQ_TARGET_b;
  } ;
  
  union {
    __IOM uint32_t MCU_CLK_EN;                  /*!< (@ 0x00000014) Mcuclk clock enable                                        */
    
    struct {
      __IOM uint32_t MCU_CLK_EN : 1;            /*!< [0..0] primary clock enable for MCU SS. gracefully (glitch-free)
                                                     gates the main clock of the MCU subsystem (mcuclk) inside
                                                     the MCU subsystem (after all the PLL/RC/bootclk muxing)
                                                     . It is intended to be used by the MCU itself to go to
                                                     sleep.                                                                    */
            uint32_t            : 31;
    } MCU_CLK_EN_b;
  } ;
  
  union {
    __IOM uint32_t MCU_STATUS_MASKED_RCLR;      /*!< (@ 0x00000018) The MCU status register read clear                         */
    
    struct {
      __IOM uint32_t MCU_STATUS_MASKED_RCLR : 16;/*!< [15..0] mcu status register after mask cleared after readmcu_status[
                                                     15] = 0;mcu_status[ 14] = mcu_user_timer_int;mcu_status[
                                                     13] = mcu_wd_rst;mcu_status[ 12] = semc_sic_auth_fail_out;mcu_status[
                                                     11] = m4_debug_mode;mcu_status[ 10] = m4_halted;mcu_status[
                                                     9] = m4_sysresetreq;mcu_status[ 8] = m4_lockup;mcu_status[7:0]
                                                     = regmcu_sw_rst_req[7:0];                                                 */
            uint32_t            : 16;
    } MCU_STATUS_MASKED_RCLR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t MCU_STATUS_MASKED;           /*!< (@ 0x00000020) The MCU status register                                    */
    
    struct {
      __IM  uint32_t MCU_STATUS_MASKED : 16;    /*!< [15..0] mcu status register after maskmcu_status[ 15] = 0;mcu_status[
                                                     14] = mcu_user_timer_int;mcu_status[ 13] = mcu_wd_rst;mcu_status[
                                                     12] = semc_sic_auth_fail_out;mcu_status[ 11] = m4_debug_mode;mcu_status[
                                                     10] = m4_halted;mcu_status[ 9] = m4_sysresetreq;mcu_status[
                                                     8] = m4_lockup;mcu_status[7:0] = regmcu_sw_rst_req[7:0];                  */
            uint32_t            : 16;
    } MCU_STATUS_MASKED_b;
  } ;
  
  union {
    __IOM uint32_t GPM_RST_REQ;                 /*!< (@ 0x00000024) GPM reset request                                          */
    
    struct {
      __IOM uint32_t GPM_RST_REQ : 1;           /*!< [0..0] gpm reset request                                                  */
            uint32_t            : 31;
    } GPM_RST_REQ_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t SEG0_SEL;                    /*!< (@ 0x0000002C) The MCU SIX segement 0 offset                              */
    
    struct {
      __IOM uint32_t SEG0_SEL   : 1;            /*!< [0..0] segment 0 select                                                   */
            uint32_t            : 31;
    } SEG0_SEL_b;
  } ;
  
  union {
    __IOM uint32_t RC_CFG;                      /*!< (@ 0x00000030) RC configuration                                           */
    
    struct {
      __IOM uint32_t TRIM       : 11;           /*!< [10..0] TRIM                                                              */
      __IOM uint32_t FREQ_SEL   : 4;            /*!< [14..11] FREQ_SEL                                                         */
            uint32_t            : 1;
      __IOM uint32_t EN         : 1;            /*!< [16..16] EN                                                               */
            uint32_t            : 15;
    } RC_CFG_b;
  } ;
  
  union {
    __IOM uint32_t RC_STT;                      /*!< (@ 0x00000034) RC status                                                  */
    
    struct {
            uint32_t            : 1;
      __IM  uint32_t LOCK       : 1;            /*!< [1..1] LOCK                                                               */
            uint32_t            : 30;
    } RC_STT_b;
  } ;
  
  union {
    __IOM uint32_t RC_RST_N;                    /*!< (@ 0x00000038) RC configuration                                           */
    
    struct {
      __IOM uint32_t RST_N      : 1;            /*!< [0..0] RST_N                                                              */
            uint32_t            : 31;
    } RC_RST_N_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t M4_CFG;                      /*!< (@ 0x00000040) Configuration of the MCU M4 core                           */
    
    struct {
      __IOM uint32_t M4_MPU_DISABLE : 1;        /*!< [0..0] M4_MPU_DISABLE                                                     */
            uint32_t            : 31;
    } M4_CFG_b;
  } ;
  
  union {
    __IOM uint32_t M4_INFO;                     /*!< (@ 0x00000044) Inforamtion if the MCU M4 core                             */
    
    struct {
      __IM  uint32_t M4_JTAGNSW : 1;            /*!< [0..0] indication if in serial-wire mode                                  */
            uint32_t            : 31;
    } M4_INFO_b;
  } ;
  
  union {
    __IOM uint32_t PMG_SSX_GSP_CFG;             /*!< (@ 0x00000048) Control over the cross-bars                                */
    
    struct {
      __IOM uint32_t REGGSP_SONICS_CLK_GSP_CNT_TARGET : 10;/*!< [9..0] Sonics clock control counter target - number of cycles
                                                     from no activity to sonics power down request.                            */
      __IOM uint32_t REGGSP_SSX_MCU_IN_POWER_DOWN : 1;/*!< [10..10] SSX_MCU power down - this bit let the SSX_GSP to make
                                                     clock gating while SSX_MCU is in power down and cant respons              */
      __IOM uint32_t REGGSP_SSX_PMP_IN_POWER_DOWN : 1;/*!< [11..11] SSX_PMP power down - this bit let the SSX_GSP to make
                                                     clock gating while SSX_PMP is in power down and cant respons              */
      __IOM uint32_t SLEEP_OK_MASK : 3;         /*!< [14..12] masking sleep ok of elements in the GSP:[0] - m4_sleep_ok
                                                     [1] - ssx_mcu_power_down_ok [2] - ssx_gsp_power_down_ok                   */
            uint32_t            : 17;
    } PMG_SSX_GSP_CFG_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t RESET_GSP_SSX_REG;           /*!< (@ 0x00000050) Reset GSP corss-bar                                        */
    
    struct {
      __IOM uint32_t RESET_GSP_SSX_REG : 1;     /*!< [0..0] sw control over gsp ssx reset signal                               */
            uint32_t            : 31;
    } RESET_GSP_SSX_REG_b;
  } ;
  
  union {
    __IOM uint32_t RESET_MCU_REG;               /*!< (@ 0x00000054) Reset MCU sub-system                                       */
    
    struct {
      __IOM uint32_t RESET_MCU_REG : 1;         /*!< [0..0] sw control over mcu_reset                                          */
            uint32_t            : 31;
    } RESET_MCU_REG_b;
  } ;
  
  union {
    __IOM uint32_t RESET_M4_REG;                /*!< (@ 0x00000058) Reset MCU core                                             */
    
    struct {
      __IOM uint32_t RESET_M4_REG : 1;          /*!< [0..0] sw control over m4_sysreset                                        */
            uint32_t            : 31;
    } RESET_M4_REG_b;
  } ;
  
  union {
    __IOM uint32_t POLICY_CFG;                  /*!< (@ 0x0000005C) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t DIS_ENLOWPOWER : 1;        /*!< [0..0] OR with MCU/PMP_APC_CFG.EN_LOW_PWR => force the enlowpower
                                                     sigmal coming from it to 1                                                */
      __IOM uint32_t DIS_XO_ISO_EN : 1;         /*!< [1..1] OR with MCU/PMP_XO_CFG.XO_ISO_EN => force the xo_isolation_en
                                                     sigmal coming from it to 1                                                */
            uint32_t            : 30;
    } POLICY_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_RC_CFG;                  /*!< (@ 0x00000060) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] OR with the RC_CFG.EN                                              */
            uint32_t            : 31;
    } MCU_RC_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_URCLK_CFG;               /*!< (@ 0x00000064) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] OR with URCLK_CFG.RING_OSC_UR_EN                                   */
            uint32_t            : 31;
    } MCU_URCLK_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_XO_CFG;                  /*!< (@ 0x00000068) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t XO_LDO_EN  : 1;            /*!< [0..0] OR with LDO_XO_CFG.DIS                                             */
      __IOM uint32_t RFXO_LDO_EN : 1;           /*!< [1..1] OR with XO_CFG.RFXO_LDO_EN                                         */
      __IOM uint32_t XO_ISO_EN  : 1;            /*!< [2..2] OR with XO_ISOLATION_REG.CO_ISOLATION                              */
            uint32_t            : 29;
    } MCU_XO_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_APC_CFG;                 /*!< (@ 0x0000006C) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN_LOW_PWR : 1;            /*!< [0..0] AND with APC_CFG.EN_LOW_PWR                                        */
            uint32_t            : 31;
    } MCU_APC_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_SIM_CFG;                 /*!< (@ 0x00000070) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t SIM_LDO_EN : 1;            /*!< [0..0] OR with LDO_SIM_CFG.DIS                                            */
            uint32_t            : 31;
    } MCU_SIM_CFG_b;
  } ;
  
  union {
    __IOM uint32_t MCU_EXTRA_CFG;               /*!< (@ 0x00000074) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EXTRA_LDO_EN : 1;          /*!< [0..0] OR with LDO_EXTRA_CFG.DIS                                          */
            uint32_t            : 31;
    } MCU_EXTRA_CFG_b;
  } ;
  
  union {
    __IOM uint32_t PMP_RC_CFG;                  /*!< (@ 0x00000078) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] OR with the RC_CFG.EN                                              */
            uint32_t            : 31;
    } PMP_RC_CFG_b;
  } ;
  
  union {
    __IOM uint32_t PMP_URCLK_CFG;               /*!< (@ 0x0000007C) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] OR with URCLK_CFG.RING_OSC_UR_EN                                   */
            uint32_t            : 31;
    } PMP_URCLK_CFG_b;
  } ;
  
  union {
    __IOM uint32_t PMP_XO_CFG;                  /*!< (@ 0x00000080) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t XO_LDO_EN  : 1;            /*!< [0..0] OR with LDO_XO_CFG.DIS                                             */
      __IOM uint32_t RFXO_LDO_EN : 1;           /*!< [1..1] OR with XO_CFG.RFXO_LDO_EN                                         */
      __IOM uint32_t XO_ISO_EN  : 1;            /*!< [2..2] OR with XO_ISOLATION_REG.CO_ISOLATION                              */
            uint32_t            : 29;
    } PMP_XO_CFG_b;
  } ;
  
  union {
    __IOM uint32_t PMP_APC_CFG;                 /*!< (@ 0x00000084) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EN_LOW_PWR : 1;            /*!< [0..0] AND with APC_CFG.EN_LOW_PWR                                        */
            uint32_t            : 31;
    } PMP_APC_CFG_b;
  } ;
  
  union {
    __IOM uint32_t PMP_SIM_CFG;                 /*!< (@ 0x00000088) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t SIM_LDO_EN : 1;            /*!< [0..0] OR with LDO_SIM_CFG.DIS                                            */
            uint32_t            : 31;
    } PMP_SIM_CFG_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t PMP_EXTRA_CFG;               /*!< (@ 0x00000090) MCU PMP policy register                                    */
    
    struct {
      __IOM uint32_t EXTRA_LDO_EN : 1;          /*!< [0..0] OR with LDO_EXTRA_CFG.DIS                                          */
            uint32_t            : 31;
    } PMP_EXTRA_CFG_b;
  } ;
  
  union {
    __IOM uint32_t M4_STCALIB;                  /*!< (@ 0x00000094) Mcu core clibration register                               */
    
    struct {
      __IOM uint32_t M4_ST_TENMS : 24;          /*!< [23..0] number of cycles requies with the selected clock for
                                                     10ms.Default calculation: 32768 Hz x 0.01 Sec = 328 = 0x148               */
      __IOM uint32_t M4_ST_SKEW : 1;            /*!< [24..24] 0: if the system timer clock (the external reference
                                                     clock or FCLK as indicated by NOREF) can guarantee an exact
                                                     multiple of 10ms.1: Otherwise                                             */
      __IOM uint32_t M4_ST_NOREF : 1;           /*!< [25..25] OR with the RC_CFG.EN                                            */
            uint32_t            : 6;
    } M4_STCALIB_b;
  } ;
  
  union {
    __IOM uint32_t MCU_RC_GATE;                 /*!< (@ 0x00000098) RC clock gate going to the MCU                             */
    
    struct {
      __IOM uint32_t RCCLK_MCU_GALTE : 1;       /*!< [0..0] Gate the clock of the RC going into the MCU                        */
            uint32_t            : 31;
    } MCU_RC_GATE_b;
  } ;
  
  union {
    __IOM uint32_t PMP_RC_GATE;                 /*!< (@ 0x0000009C) RC clock gate going to the PMP                             */
    
    struct {
      __IOM uint32_t RCCLK_PMP_GATE : 1;        /*!< [0..0] Gate the clock of the RC going into the PMP                        */
            uint32_t            : 31;
    } PMP_RC_GATE_b;
  } ;
  
  union {
    __IOM uint32_t MCU_DEBUG_MODE;              /*!< (@ 0x000000A0) MCU core debug mode                                        */
    
    struct {
      __IM  uint32_t MCU_DEBUG_MODE : 1;        /*!< [0..0] MCU_DEBUG_MODE                                                     */
            uint32_t            : 31;
    } MCU_DEBUG_MODE_b;
  } ;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t CHIP_RST_STAT;               /*!< (@ 0x000000B0) device reset status                                        */
    
    struct {
      __IM  uint32_t MODEM_RST  : 1;            /*!< [0..0] Modem reset status (Active high)                                   */
      __IM  uint32_t PMP_RST    : 1;            /*!< [1..1] PMP reset status (Active high)                                     */
      __IM  uint32_t GSP_RST    : 1;            /*!< [2..2] GSP reset status (Active high)                                     */
            uint32_t            : 29;
    } CHIP_RST_STAT_b;
  } ;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t REDUCE_MCU_INTERNAL_MEM;     /*!< (@ 0x000000C0) reduce the MCU internal memory size                        */
    
    struct {
      __IOM uint32_t REDUCE_MCU_INTERNAL_MEM : 1;/*!< [0..0] 0 - MCU internal memory size is 128KB1 - MCU internal
                                                     memory size is 32KB                                                       */
            uint32_t            : 31;
    } REDUCE_MCU_INTERNAL_MEM_b;
  } ;
} GSP_REGFILE_Type;                             /*!< Size = 196 (0xc4)                                                         */



/* =========================================================================================================================== */
/* ================                                        GPM_IO_CFG                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Configuration of the GPM IO (PU PD etc&#8230;) can be access by the sub-system that the IO was partitoned to in security enable mode (GPM_IO_CFG)
  */

typedef struct {                                /*!< (@ 0x0C111800) GPM_IO_CFG Structure                                       */
  __IM  uint32_t  RESERVED[14];
  
  union {
    __IOM uint32_t GPIO0;                       /*!< (@ 0x00000038) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO0 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO0 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO0 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO0 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO0 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO0 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO0 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO0_b;
  } ;
  
  union {
    __IOM uint32_t GPIO1;                       /*!< (@ 0x0000003C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO1 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO1 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO1 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO1 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO1 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO1 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO1 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO1_b;
  } ;
  
  union {
    __IOM uint32_t GPIO2;                       /*!< (@ 0x00000040) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO2 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO2 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO2 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO2 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO2 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO2 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO2 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO2_b;
  } ;
  
  union {
    __IOM uint32_t GPIO3;                       /*!< (@ 0x00000044) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO3 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO3 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO3 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO3 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO3 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO3 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO3 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO3_b;
  } ;
  
  union {
    __IOM uint32_t GPIO4;                       /*!< (@ 0x00000048) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO4 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO4 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO4 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO4 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO4 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO4 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO4 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO4_b;
  } ;
  
  union {
    __IOM uint32_t GPIO5;                       /*!< (@ 0x0000004C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_GPIO5 : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_GPIO5 : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_GPIO5 : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_GPIO5 : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_GPIO5 : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_GPIO5 : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_GPIO5 : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } GPIO5_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_VDDIO_OUT;              /*!< (@ 0x00000050) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_RFFE_VDDIO_OUT : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_RFFE_VDDIO_OUT : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_RFFE_VDDIO_OUT : 1;/*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_RFFE_VDDIO_OUT : 1;/*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_RFFE_VDDIO_OUT : 1;/*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_RFFE_VDDIO_OUT : 1;/*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_RFFE_VDDIO_OUT : 1;/*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } RFFE_VDDIO_OUT_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SCLK;                   /*!< (@ 0x00000054) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_RFFE_SCLK : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_RFFE_SCLK : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_RFFE_SCLK : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_RFFE_SCLK : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_RFFE_SCLK : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_RFFE_SCLK : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_RFFE_SCLK : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } RFFE_SCLK_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SDATA;                  /*!< (@ 0x00000058) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_RFFE_SDATA : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_RFFE_SDATA : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_RFFE_SDATA : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_RFFE_SDATA : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_RFFE_SDATA : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_RFFE_SDATA : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_RFFE_SDATA : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } RFFE_SDATA_b;
  } ;
  
  union {
    __IOM uint32_t SC_RST;                      /*!< (@ 0x0000005C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SC_RST : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SC_RST : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SC_RST : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SC_RST : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SC_RST : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SC_RST : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SC_RST : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SC_RST_b;
  } ;
  
  union {
    __IOM uint32_t SC_IO;                       /*!< (@ 0x00000060) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SC_IO : 1;      /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SC_IO : 1;      /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SC_IO : 1;       /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SC_IO : 1;       /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SC_IO : 1;       /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SC_IO : 1;       /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SC_IO : 1;       /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SC_IO_b;
  } ;
  
  union {
    __IOM uint32_t SC_CLK;                      /*!< (@ 0x00000064) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SC_CLK : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SC_CLK : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SC_CLK : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SC_CLK : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SC_CLK : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SC_CLK : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SC_CLK : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SC_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SC_DET;                      /*!< (@ 0x00000068) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SC_DET : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SC_DET : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SC_DET : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SC_DET : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SC_DET : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SC_DET : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SC_DET : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SC_DET_b;
  } ;
  
  union {
    __IOM uint32_t SC_SWP;                      /*!< (@ 0x0000006C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SC_SWP : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SC_SWP : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SC_SWP : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SC_SWP : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SC_SWP : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SC_SWP : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SC_SWP : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SC_SWP_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TCK;                      /*!< (@ 0x00000070) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_EJ_TCK : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_EJ_TCK : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_EJ_TCK : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_EJ_TCK : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_EJ_TCK : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_EJ_TCK : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_EJ_TCK : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } EJ_TCK_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TMS;                      /*!< (@ 0x00000074) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_EJ_TMS : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_EJ_TMS : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_EJ_TMS : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_EJ_TMS : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_EJ_TMS : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_EJ_TMS : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_EJ_TMS : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } EJ_TMS_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TRST;                     /*!< (@ 0x00000078) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_EJ_TRST : 1;    /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_EJ_TRST : 1;    /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_EJ_TRST : 1;     /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_EJ_TRST : 1;     /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_EJ_TRST : 1;     /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_EJ_TRST : 1;     /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_EJ_TRST : 1;     /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } EJ_TRST_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDI;                      /*!< (@ 0x0000007C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_EJ_TDI : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_EJ_TDI : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_EJ_TDI : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_EJ_TDI : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_EJ_TDI : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_EJ_TDI : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_EJ_TDI : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } EJ_TDI_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDO;                      /*!< (@ 0x00000080) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_EJ_TDO : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_EJ_TDO : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_EJ_TDO : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_EJ_TDO : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_EJ_TDO : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_EJ_TDO : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_EJ_TDO : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } EJ_TDO_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RX;                    /*!< (@ 0x00000084) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART0_RX : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART0_RX : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART0_RX : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART0_RX : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART0_RX : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART0_RX : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART0_RX : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART0_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_TX;                    /*!< (@ 0x00000088) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART0_TX : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART0_TX : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART0_TX : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART0_TX : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART0_TX : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART0_TX : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART0_TX : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART0_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_CTS;                   /*!< (@ 0x0000008C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART0_CTS : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART0_CTS : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART0_CTS : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART0_CTS : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART0_CTS : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART0_CTS : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART0_CTS : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART0_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RTS;                   /*!< (@ 0x00000090) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART0_RTS : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART0_RTS : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART0_RTS : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART0_RTS : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART0_RTS : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART0_RTS : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART0_RTS : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART0_RTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RX;                    /*!< (@ 0x00000094) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART2_RX : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART2_RX : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART2_RX : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART2_RX : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART2_RX : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART2_RX : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART2_RX : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART2_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_TX;                    /*!< (@ 0x00000098) IO configuration                                           */
    
    struct {
      __IM  uint32_t IO_CFG_DS1_UART2_TX : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IM  uint32_t IO_CFG_DS0_UART2_TX : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART2_TX : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART2_TX : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IM  uint32_t IO_CFG_SR_UART2_TX : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IM  uint32_t IO_CFG_IS_UART2_TX : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IM  uint32_t IO_CFG_IE_UART2_TX : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART2_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_CTS;                   /*!< (@ 0x0000009C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART2_CTS : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART2_CTS : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART2_CTS : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART2_CTS : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART2_CTS : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART2_CTS : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART2_CTS : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART2_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RTS;                   /*!< (@ 0x000000A0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_UART2_RTS : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_UART2_RTS : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_UART2_RTS : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_UART2_RTS : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_UART2_RTS : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_UART2_RTS : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_UART2_RTS : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } UART2_RTS_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_SEL;                   /*!< (@ 0x000000A4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_DEBUG_SEL : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_DEBUG_SEL : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_DEBUG_SEL : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_DEBUG_SEL : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_DEBUG_SEL : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_DEBUG_SEL : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_DEBUG_SEL : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } DEBUG_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_RSTN;                  /*!< (@ 0x000000A8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_DEBUG_RSTN : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_DEBUG_RSTN : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_DEBUG_RSTN : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_DEBUG_RSTN : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_DEBUG_RSTN : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_DEBUG_RSTN : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_DEBUG_RSTN : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } DEBUG_RSTN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MOSI;                  /*!< (@ 0x000000AC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM0_MOSI : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM0_MOSI : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM0_MOSI : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM0_MOSI : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM0_MOSI : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM0_MOSI : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM0_MOSI : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM0_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MISO;                  /*!< (@ 0x000000B0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM0_MISO : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM0_MISO : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM0_MISO : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM0_MISO : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM0_MISO : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM0_MISO : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM0_MISO : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM0_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN0;                   /*!< (@ 0x000000B4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM0_EN0 : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM0_EN0 : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM0_EN0 : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM0_EN0 : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM0_EN0 : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM0_EN0 : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM0_EN0 : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM0_EN0_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN1;                   /*!< (@ 0x000000B8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM0_EN1 : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM0_EN1 : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM0_EN1 : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM0_EN1 : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM0_EN1 : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM0_EN1 : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM0_EN1 : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM0_EN1_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_CLK;                   /*!< (@ 0x000000BC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM0_CLK : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM0_CLK : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM0_CLK : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM0_CLK : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM0_CLK : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM0_CLK : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM0_CLK : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM0_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MOSI;                  /*!< (@ 0x000000C0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM1_MOSI : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM1_MOSI : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM1_MOSI : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM1_MOSI : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM1_MOSI : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM1_MOSI : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM1_MOSI : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM1_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MISO;                  /*!< (@ 0x000000C4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM1_MISO : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM1_MISO : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM1_MISO : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM1_MISO : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM1_MISO : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM1_MISO : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM1_MISO : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM1_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_EN;                    /*!< (@ 0x000000C8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM1_EN : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM1_EN : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM1_EN : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM1_EN : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM1_EN : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM1_EN : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM1_EN : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM1_EN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_CLK;                   /*!< (@ 0x000000CC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_SPIM1_CLK : 1;  /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_SPIM1_CLK : 1;  /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_SPIM1_CLK : 1;   /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_SPIM1_CLK : 1;   /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_SPIM1_CLK : 1;   /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_SPIM1_CLK : 1;   /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_SPIM1_CLK : 1;   /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } SPIM1_CLK_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SDA;                    /*!< (@ 0x000000D0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_I2C0_SDA : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_I2C0_SDA : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_I2C0_SDA : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_I2C0_SDA : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_I2C0_SDA : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_I2C0_SDA : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_I2C0_SDA : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } I2C0_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SCL;                    /*!< (@ 0x000000D4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_I2C0_SCL : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_I2C0_SCL : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_I2C0_SCL : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_I2C0_SCL : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_I2C0_SCL : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_I2C0_SCL : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_I2C0_SCL : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } I2C0_SCL_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SDA;                    /*!< (@ 0x000000D8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_I2C1_SDA : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_I2C1_SDA : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_I2C1_SDA : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_I2C1_SDA : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_I2C1_SDA : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_I2C1_SDA : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_I2C1_SDA : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } I2C1_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SCL;                    /*!< (@ 0x000000DC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_I2C1_SCL : 1;   /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_I2C1_SCL : 1;   /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_I2C1_SCL : 1;    /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_I2C1_SCL : 1;    /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_I2C1_SCL : 1;    /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_I2C1_SCL : 1;    /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_I2C1_SCL : 1;    /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } I2C1_SCL_b;
  } ;
  
  union {
    __IOM uint32_t PCM_CLK;                     /*!< (@ 0x000000E0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PCM_CLK : 1;    /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PCM_CLK : 1;    /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PCM_CLK : 1;     /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PCM_CLK : 1;     /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PCM_CLK : 1;     /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PCM_CLK : 1;     /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PCM_CLK : 1;     /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PCM_CLK_b;
  } ;
  
  union {
    __IOM uint32_t PCM_FS;                      /*!< (@ 0x000000E4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PCM_FS : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PCM_FS : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PCM_FS : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PCM_FS : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PCM_FS : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PCM_FS : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PCM_FS : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PCM_FS_b;
  } ;
  
  union {
    __IOM uint32_t PCM_IN;                      /*!< (@ 0x000000E8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PCM_IN : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PCM_IN : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PCM_IN : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PCM_IN : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PCM_IN : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PCM_IN : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PCM_IN : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PCM_IN_b;
  } ;
  
  union {
    __IOM uint32_t PCM_OUT;                     /*!< (@ 0x000000EC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PCM_OUT : 1;    /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PCM_OUT : 1;    /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PCM_OUT : 1;     /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PCM_OUT : 1;     /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PCM_OUT : 1;     /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PCM_OUT : 1;     /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PCM_OUT : 1;     /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PCM_OUT_b;
  } ;
  
  union {
    __IOM uint32_t PWM0;                        /*!< (@ 0x000000F0) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PWM0 : 1;       /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PWM0 : 1;       /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PWM0 : 1;        /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PWM0 : 1;        /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PWM0 : 1;        /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PWM0 : 1;        /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PWM0 : 1;        /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PWM0_b;
  } ;
  
  union {
    __IOM uint32_t PWM1;                        /*!< (@ 0x000000F4) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PWM1 : 1;       /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PWM1 : 1;       /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PWM1 : 1;        /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PWM1 : 1;        /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PWM1 : 1;        /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PWM1 : 1;        /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PWM1 : 1;        /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PWM1_b;
  } ;
  
  union {
    __IOM uint32_t PWM2;                        /*!< (@ 0x000000F8) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PWM2 : 1;       /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PWM2 : 1;       /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PWM2 : 1;        /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PWM2 : 1;        /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PWM2 : 1;        /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PWM2 : 1;        /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PWM2 : 1;        /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PWM2_b;
  } ;
  
  union {
    __IOM uint32_t PWM3;                        /*!< (@ 0x000000FC) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_PWM3 : 1;       /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_PWM3 : 1;       /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_PWM3 : 1;        /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_PWM3 : 1;        /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_PWM3 : 1;        /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_PWM3 : 1;        /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_PWM3 : 1;        /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } PWM3_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_CS_N;                 /*!< (@ 0x00000100) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_CS_N : 1;/*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_CS_N : 1;/*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_CS_N : 1; /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_CS_N : 1; /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_CS_N : 1; /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_CS_N : 1; /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_CS_N : 1; /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_CS_N_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_SCK;                  /*!< (@ 0x00000104) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_SCK : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_SCK : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_SCK : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_SCK : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_SCK : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_SCK : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_SCK : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_SCK_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO0;                  /*!< (@ 0x00000108) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_IO0 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_IO0 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_IO0 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_IO0 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_IO0 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_IO0 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_IO0 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_IO0_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO1;                  /*!< (@ 0x0000010C) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_IO1 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_IO1 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_IO1 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_IO1 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_IO1 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_IO1 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_IO1 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_IO1_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO2;                  /*!< (@ 0x00000110) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_IO2 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_IO2 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_IO2 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_IO2 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_IO2 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_IO2 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_IO2 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_IO2_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO3;                  /*!< (@ 0x00000114) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_FLASH1_IO3 : 1; /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_FLASH1_IO3 : 1; /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_FLASH1_IO3 : 1;  /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_FLASH1_IO3 : 1;  /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_FLASH1_IO3 : 1;  /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_FLASH1_IO3 : 1;  /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_FLASH1_IO3 : 1;  /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } FLASH1_IO3_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT;                      /*!< (@ 0x00000118) IO configuration                                           */
    
    struct {
      __IOM uint32_t IO_CFG_DS1_CLKOUT : 1;     /*!< [0..0] PAD DS1 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_DS0_CLKOUT : 1;     /*!< [1..1] PAD DS0 (Device Select 0) signal - used to select output
                                                     driverreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_PS_CLKOUT : 1;      /*!< [2..2] PAD PS (Pull Select) signal - logic high select pull-up
                                                     and logic low selects pull-downreset value taken from pad2ball.
                                                     Only the subchip that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC)
                                                     could read/write this register and controll the PAD                       */
      __IOM uint32_t IO_CFG_PE_CLKOUT : 1;      /*!< [3..3] PAD SE (Pull Enable) signal - logic high enables weak
                                                     pull devicereset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
      __IOM uint32_t IO_CFG_SR_CLKOUT : 1;      /*!< [4..4] PAD SR (Slew Rate) signal - logic high select slow slew
                                                     rate and logic low select fast slew ratereset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IS_CLKOUT : 1;      /*!< [5..5] PAD IS (Input Select) signal - logic low select cmos
                                                     input and logic high select schmitt inputreset value taken
                                                     from pad2ball. Only the subchip that controll this PAD
                                                     in PMP_IO_PAR (MCU/PMP/SOC) could read/write this register
                                                     and controll the PAD                                                      */
      __IOM uint32_t IO_CFG_IE_CLKOUT : 1;      /*!< [6..6] PAD IE (Input Enable) signal - logic high enable the
                                                     input bufferreset value taken from pad2ball. Only the subchip
                                                     that controll this PAD in PMP_IO_PAR (MCU/PMP/SOC) could
                                                     read/write this register and controll the PAD                             */
            uint32_t            : 25;
    } CLKOUT_b;
  } ;
} GPM_IO_CFG_Type;                              /*!< Size = 284 (0x11c)                                                        */



/* =========================================================================================================================== */
/* ================                                        GPM_IO_PAR                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Control the partiton MUX of each GPM IO - partitoned to a specific sub-system:
00 not assign
01  MCU
10  PMP
11  SOC/modem (GPM_IO_PAR)
  */

typedef struct {                                /*!< (@ 0x0C111A00) GPM_IO_PAR Structure                                       */
  __IM  uint32_t  RESERVED[14];
  
  union {
    __IOM uint32_t GPIO0;                       /*!< (@ 0x00000038) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO0      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO0_b;
  } ;
  
  union {
    __IOM uint32_t GPIO1;                       /*!< (@ 0x0000003C) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO1      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO1_b;
  } ;
  
  union {
    __IOM uint32_t GPIO2;                       /*!< (@ 0x00000040) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO2      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO2_b;
  } ;
  
  union {
    __IOM uint32_t GPIO3;                       /*!< (@ 0x00000044) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO3      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO3_b;
  } ;
  
  union {
    __IOM uint32_t GPIO4;                       /*!< (@ 0x00000048) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO4      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO4_b;
  } ;
  
  union {
    __IOM uint32_t GPIO5;                       /*!< (@ 0x0000004C) IO partitition                                             */
    
    struct {
      __IOM uint32_t GPIO5      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } GPIO5_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_VDDIO_OUT;              /*!< (@ 0x00000050) IO partitition                                             */
    
    struct {
      __IOM uint32_t RFFE_VDDIO_OUT : 2;        /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } RFFE_VDDIO_OUT_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SCLK;                   /*!< (@ 0x00000054) IO partitition                                             */
    
    struct {
      __IOM uint32_t RFFE_SCLK  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } RFFE_SCLK_b;
  } ;
  
  union {
    __IOM uint32_t RFFE_SDATA;                  /*!< (@ 0x00000058) IO partitition                                             */
    
    struct {
      __IOM uint32_t RFFE_SDATA : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } RFFE_SDATA_b;
  } ;
  
  union {
    __IOM uint32_t SC_RST;                      /*!< (@ 0x0000005C) IO partitition                                             */
    
    struct {
      __IOM uint32_t SC_RST     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SC_RST_b;
  } ;
  
  union {
    __IOM uint32_t SC_IO;                       /*!< (@ 0x00000060) IO partitition                                             */
    
    struct {
      __IOM uint32_t SC_IO      : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SC_IO_b;
  } ;
  
  union {
    __IOM uint32_t SC_CLK;                      /*!< (@ 0x00000064) IO partitition                                             */
    
    struct {
      __IOM uint32_t SC_CLK     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SC_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SC_DET;                      /*!< (@ 0x00000068) IO partitition                                             */
    
    struct {
      __IOM uint32_t SC_DET     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SC_DET_b;
  } ;
  
  union {
    __IOM uint32_t SC_SWP;                      /*!< (@ 0x0000006C) IO partitition                                             */
    
    struct {
      __IOM uint32_t SC_SWP     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SC_SWP_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TCK;                      /*!< (@ 0x00000070) IO partitition                                             */
    
    struct {
      __IOM uint32_t EJ_TCK     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } EJ_TCK_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TMS;                      /*!< (@ 0x00000074) IO partitition                                             */
    
    struct {
      __IOM uint32_t EJ_TMS     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } EJ_TMS_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TRST;                     /*!< (@ 0x00000078) IO partitition                                             */
    
    struct {
      __IOM uint32_t EJ_TRST    : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } EJ_TRST_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDI;                      /*!< (@ 0x0000007C) IO partitition                                             */
    
    struct {
      __IOM uint32_t EJ_TDI     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } EJ_TDI_b;
  } ;
  
  union {
    __IOM uint32_t EJ_TDO;                      /*!< (@ 0x00000080) IO partitition                                             */
    
    struct {
      __IOM uint32_t EJ_TDO     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } EJ_TDO_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RX;                    /*!< (@ 0x00000084) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART0_RX   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART0_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_TX;                    /*!< (@ 0x00000088) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART0_TX   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART0_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART0_CTS;                   /*!< (@ 0x0000008C) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART0_CTS  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART0_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART0_RTS;                   /*!< (@ 0x00000090) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART0_RTS  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART0_RTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RX;                    /*!< (@ 0x00000094) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART2_RX   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART2_RX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_TX;                    /*!< (@ 0x00000098) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART2_TX   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART2_TX_b;
  } ;
  
  union {
    __IOM uint32_t UART2_CTS;                   /*!< (@ 0x0000009C) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART2_CTS  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART2_CTS_b;
  } ;
  
  union {
    __IOM uint32_t UART2_RTS;                   /*!< (@ 0x000000A0) IO partitition                                             */
    
    struct {
      __IOM uint32_t UART2_RTS  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } UART2_RTS_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_SEL;                   /*!< (@ 0x000000A4) IO partitition                                             */
    
    struct {
      __IOM uint32_t DEBUG_SEL  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } DEBUG_SEL_b;
  } ;
  
  union {
    __IOM uint32_t DEBUG_RSTN;                  /*!< (@ 0x000000A8) IO partitition                                             */
    
    struct {
      __IOM uint32_t DEBUG_RSTN : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } DEBUG_RSTN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MOSI;                  /*!< (@ 0x000000AC) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM0_MOSI : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM0_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_MISO;                  /*!< (@ 0x000000B0) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM0_MISO : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM0_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN0;                   /*!< (@ 0x000000B4) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM0_EN0  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM0_EN0_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_EN1;                   /*!< (@ 0x000000B8) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM0_EN1  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM0_EN1_b;
  } ;
  
  union {
    __IOM uint32_t SPIM0_CLK;                   /*!< (@ 0x000000BC) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM0_CLK  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM0_CLK_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MOSI;                  /*!< (@ 0x000000C0) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM1_MOSI : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM1_MOSI_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_MISO;                  /*!< (@ 0x000000C4) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM1_MISO : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM1_MISO_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_EN;                    /*!< (@ 0x000000C8) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM1_EN   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM1_EN_b;
  } ;
  
  union {
    __IOM uint32_t SPIM1_CLK;                   /*!< (@ 0x000000CC) IO partitition                                             */
    
    struct {
      __IOM uint32_t SPIM1_CLK  : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } SPIM1_CLK_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SDA;                    /*!< (@ 0x000000D0) IO partitition                                             */
    
    struct {
      __IOM uint32_t I2C0_SDA   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } I2C0_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C0_SCL;                    /*!< (@ 0x000000D4) IO partitition                                             */
    
    struct {
      __IOM uint32_t I2C0_SCL   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } I2C0_SCL_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SDA;                    /*!< (@ 0x000000D8) IO partitition                                             */
    
    struct {
      __IOM uint32_t I2C1_SDA   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } I2C1_SDA_b;
  } ;
  
  union {
    __IOM uint32_t I2C1_SCL;                    /*!< (@ 0x000000DC) IO partitition                                             */
    
    struct {
      __IOM uint32_t I2C1_SCL   : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } I2C1_SCL_b;
  } ;
  
  union {
    __IOM uint32_t PCM_CLK;                     /*!< (@ 0x000000E0) IO partitition                                             */
    
    struct {
      __IOM uint32_t PCM_CLK    : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PCM_CLK_b;
  } ;
  
  union {
    __IOM uint32_t PCM_FS;                      /*!< (@ 0x000000E4) IO partitition                                             */
    
    struct {
      __IOM uint32_t PCM_FS     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PCM_FS_b;
  } ;
  
  union {
    __IOM uint32_t PCM_IN;                      /*!< (@ 0x000000E8) IO partitition                                             */
    
    struct {
      __IOM uint32_t PCM_IN     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PCM_IN_b;
  } ;
  
  union {
    __IOM uint32_t PCM_OUT;                     /*!< (@ 0x000000EC) IO partitition                                             */
    
    struct {
      __IOM uint32_t PCM_OUT    : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PCM_OUT_b;
  } ;
  
  union {
    __IOM uint32_t PWM0;                        /*!< (@ 0x000000F0) IO partitition                                             */
    
    struct {
      __IOM uint32_t PWM0       : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PWM0_b;
  } ;
  
  union {
    __IOM uint32_t PWM1;                        /*!< (@ 0x000000F4) IO partitition                                             */
    
    struct {
      __IOM uint32_t PWM1       : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PWM1_b;
  } ;
  
  union {
    __IOM uint32_t PWM2;                        /*!< (@ 0x000000F8) IO partitition                                             */
    
    struct {
      __IOM uint32_t PWM2       : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PWM2_b;
  } ;
  
  union {
    __IOM uint32_t PWM3;                        /*!< (@ 0x000000FC) IO partitition                                             */
    
    struct {
      __IOM uint32_t PWM3       : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PWM3_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_CS_N;                 /*!< (@ 0x00000100) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_CS_N : 2;           /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_CS_N_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_SCK;                  /*!< (@ 0x00000104) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_SCK : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_SCK_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO0;                  /*!< (@ 0x00000108) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_IO0 : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_IO0_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO1;                  /*!< (@ 0x0000010C) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_IO1 : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_IO1_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO2;                  /*!< (@ 0x00000110) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_IO2 : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_IO2_b;
  } ;
  
  union {
    __IOM uint32_t FLASH1_IO3;                  /*!< (@ 0x00000114) IO partitition                                             */
    
    struct {
      __IOM uint32_t FLASH1_IO3 : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } FLASH1_IO3_b;
  } ;
  
  union {
    __IOM uint32_t CLKOUT;                      /*!< (@ 0x00000118) IO partitition                                             */
    
    struct {
      __IOM uint32_t CLKOUT     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } CLKOUT_b;
  } ;
  
  union {
    __IOM uint32_t WAKEUP;                      /*!< (@ 0x0000011C) IO partitition                                             */
    
    struct {
      __IOM uint32_t WAKEUP     : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } WAKEUP_b;
  } ;
  
  union {
    __IOM uint32_t PB;                          /*!< (@ 0x00000120) IO partitition                                             */
    
    struct {
      __IOM uint32_t PB         : 2;            /*!< [1..0] partition register mux control;when security is enabled
                                                     has to be written by PMP-Athis register select which subchip
                                                     (MCU/PMP/MODEM) has the control on that IO while the other
                                                     subchips has no accsess to this IO input or output2'b00-
                                                     reset value; this IO cant be access from any subchip untill
                                                     written;2'b01- MCU controll this IO2'b10- PMP controll
                                                     this IO2'b11- SOC controll this IO                                        */
            uint32_t            : 30;
    } PB_b;
  } ;
} GPM_IO_PAR_Type;                              /*!< Size = 292 (0x124)                                                        */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define AUX_ADC_B0_BASE             0x0C111000UL
#define AUX_ADC_B1_BASE             0x0C111040UL
#define AUX_ADC_B2_BASE             0x0C111080UL
#define AUX_ADC_B3_BASE             0x0C1110C0UL
#define AUX_ADC_B4_BASE             0x0C111100UL
#define AUX_ADC_B5_BASE             0x0C111140UL
#define AUX_ADC_B6_BASE             0x0C111180UL
#define AUX_ADC_B7_BASE             0x0C1111C0UL
#define GDMA_BASE                   0x01540000UL
#define UARTF0_CFG_BASE             0x01000000UL
#define UARTF0_BASE                 0x00100000UL
#define UARTF1_BASE                 0x00101000UL
#define UARTF1_CFG_BASE             0x01100000UL
#define SPI_SLAVE_BASE              0x01200000UL
#define I2C0_CTRL_BASE              0x00200000UL
#define I2C1_CTRL_BASE              0x00210000UL
#define SPI_MASTER0_BASE            0x00220000UL
#define SPI_MASTER1_BASE            0x00230000UL
#define UARTI0_BASE                 0x00102000UL
#define UARTI1_BASE                 0x00103000UL
#define UARTI2_BASE                 0x00104000UL
#define GPIO_0_BASE                 0x01600000UL
#define GPIO_1_BASE                 0x01610000UL
#define GPIO_2_BASE                 0x01620000UL
#define GPIO_3_BASE                 0x01630000UL
#define GPIO_4_BASE                 0x01640000UL
#define GPIO_5_BASE                 0x01650000UL
#define GPIO_6_BASE                 0x01660000UL
#define GPIO_7_BASE                 0x01670000UL
#define GPIO_8_BASE                 0x01680000UL
#define GPIO_9_BASE                 0x01690000UL
#define GP_TIMER_INTR_0_BASE        0x01590000UL
#define GP_TIMER_INTR_1_BASE        0x015A0000UL
#define SHADOW_32K_TIMER_INTR_BASE  0x015E0000UL
#define SHADOW_32K_TIMER_CTRL_BASE  0x015D0000UL
#define WD_BASE                     0x01570000UL
#define IO_WKUP_CTRL_BASE           0x0C111E00UL
#define ATOMIC_COUNTER_MAILBOX4_BASE 0x0D008400UL
#define ATOMIC_COUNTER_MAILBOX5_BASE 0x0D008500UL
#define ATOMIC_COUNTER_MAILBOX8_BASE 0x0D008800UL
#define ATOMIC_COUNTER_MAILBOX9_BASE 0x0D008900UL
#define LED_CTRL_BASE               0x01500000UL
#define IO_FUNC_SEL_BASE            0x01510000UL
#define CLK_CONTROL_BASE            0x01520000UL
#define RST_CONTROL_BASE            0x01530000UL
#define PERF_CNTR_BASE              0x01550000UL
#define REGFILE_BASE                0x01560000UL
#define GP_TIMER_CTRL_BASE          0x01580000UL
#define NCO_BASE                    0x015B0000UL
#define SLEEP_TIMERS_BASE           0x015C0000UL
#define SLOW_IF_CLKOUT_BASE         0x016D0000UL
#define USER_TIMERS_BASE            0x00105000UL
#define PCM_BASE                    0x00240000UL
#define PWM_DAC_BASE                0x016C0000UL
#define PMP_IO_CFG_BASE             0x0D000300UL
#define PMP_IO_PAR_BASE             0x0D000600UL
#define SERIAL_FLASH_CTRL_MANUAL_BASE 0x0D006200UL
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_BASE 0x0D006280UL
#define SERIAL_FLASH_CTRL_SECURITY_BASE 0x0D006C00UL
#define GSP_REGFILE_BASE            0x0C112000UL
#define GPM_IO_CFG_BASE             0x0C111800UL
#define GPM_IO_PAR_BASE             0x0C111A00UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define AUX_ADC_B0                  ((AUX_ADC_Type*)           AUX_ADC_B0_BASE)
#define AUX_ADC_B1                  ((AUX_ADC_Type*)           AUX_ADC_B1_BASE)
#define AUX_ADC_B2                  ((AUX_ADC_Type*)           AUX_ADC_B2_BASE)
#define AUX_ADC_B3                  ((AUX_ADC_Type*)           AUX_ADC_B3_BASE)
#define AUX_ADC_B4                  ((AUX_ADC_Type*)           AUX_ADC_B4_BASE)
#define AUX_ADC_B5                  ((AUX_ADC_Type*)           AUX_ADC_B5_BASE)
#define AUX_ADC_B6                  ((AUX_ADC_Type*)           AUX_ADC_B6_BASE)
#define AUX_ADC_B7                  ((AUX_ADC_Type*)           AUX_ADC_B7_BASE)
#define GDMA                        ((GDMA_Type*)              GDMA_BASE)
#define UARTF0_CFG                  ((UARTF_CFG_Type*)         UARTF0_CFG_BASE)
#define UARTF0                      ((UART_Type*)              UARTF0_BASE)
#define UARTF1                      ((UART_Type*)              UARTF1_BASE)
#define UARTF1_CFG                  ((UARTF_CFG_Type*)         UARTF1_CFG_BASE)
#define SPI_SLAVE                   ((SPI_SLAVE_Type*)         SPI_SLAVE_BASE)
#define I2C0_CTRL                   ((I2C_CTRL_Type*)          I2C0_CTRL_BASE)
#define I2C1_CTRL                   ((I2C_CTRL_Type*)          I2C1_CTRL_BASE)
#define SPI_MASTER0                 ((SPI_MASTER_Type*)        SPI_MASTER0_BASE)
#define SPI_MASTER1                 ((SPI_MASTER_Type*)        SPI_MASTER1_BASE)
#define UARTI0                      ((UART_Type*)              UARTI0_BASE)
#define UARTI1                      ((UART_Type*)              UARTI1_BASE)
#define UARTI2                      ((UART_Type*)              UARTI2_BASE)
#define GPIO_0                      ((GPIO_Type*)              GPIO_0_BASE)
#define GPIO_1                      ((GPIO_Type*)              GPIO_1_BASE)
#define GPIO_2                      ((GPIO_Type*)              GPIO_2_BASE)
#define GPIO_3                      ((GPIO_Type*)              GPIO_3_BASE)
#define GPIO_4                      ((GPIO_Type*)              GPIO_4_BASE)
#define GPIO_5                      ((GPIO_Type*)              GPIO_5_BASE)
#define GPIO_6                      ((GPIO_Type*)              GPIO_6_BASE)
#define GPIO_7                      ((GPIO_Type*)              GPIO_7_BASE)
#define GPIO_8                      ((GPIO_Type*)              GPIO_8_BASE)
#define GPIO_9                      ((GPIO_Type*)              GPIO_9_BASE)
#define GP_TIMER_INTR_0             ((GP_TIMER_INTR_Type*)     GP_TIMER_INTR_0_BASE)
#define GP_TIMER_INTR_1             ((GP_TIMER_INTR_Type*)     GP_TIMER_INTR_1_BASE)
#define SHADOW_32K_TIMER_INTR       ((SHADOW_32K_TIMER_INTR_Type*)  SHADOW_32K_TIMER_INTR_BASE)
#define SHADOW_32K_TIMER_CTRL       ((SHADOW_32K_TIMER_CTRL_Type*)  SHADOW_32K_TIMER_CTRL_BASE)
#define WD                          ((WD_Type*)                WD_BASE)
#define IO_WKUP_CTRL                ((IO_WKUP_CTRL_Type*)      IO_WKUP_CTRL_BASE)
#define ATOMIC_COUNTER_MAILBOX4     ((ATOMIC_COUNTER_MAILBOX_Type*)  ATOMIC_COUNTER_MAILBOX4_BASE)
#define ATOMIC_COUNTER_MAILBOX5     ((ATOMIC_COUNTER_MAILBOX_Type*)  ATOMIC_COUNTER_MAILBOX5_BASE)
#define ATOMIC_COUNTER_MAILBOX8     ((ATOMIC_COUNTER_MAILBOX_Type*)  ATOMIC_COUNTER_MAILBOX8_BASE)
#define ATOMIC_COUNTER_MAILBOX9     ((ATOMIC_COUNTER_MAILBOX_Type*)  ATOMIC_COUNTER_MAILBOX9_BASE)
#define LED_CTRL                    ((LED_CTRL_Type*)          LED_CTRL_BASE)
#define IO_FUNC_SEL                 ((IO_FUNC_SEL_Type*)       IO_FUNC_SEL_BASE)
#define CLK_CONTROL                 ((CLK_CONTROL_Type*)       CLK_CONTROL_BASE)
#define RST_CONTROL                 ((RST_CONTROL_Type*)       RST_CONTROL_BASE)
#define PERF_CNTR                   ((PERF_CNTR_Type*)         PERF_CNTR_BASE)
#define REGFILE                     ((REGFILE_Type*)           REGFILE_BASE)
#define GP_TIMER_CTRL               ((GP_TIMER_CTRL_Type*)     GP_TIMER_CTRL_BASE)
#define NCO                         ((NCO_Type*)               NCO_BASE)
#define SLEEP_TIMERS                ((SLEEP_TIMERS_Type*)      SLEEP_TIMERS_BASE)
#define SLOW_IF_CLKOUT              ((SLOW_IF_CLKOUT_Type*)    SLOW_IF_CLKOUT_BASE)
#define USER_TIMERS                 ((USER_TIMERS_Type*)       USER_TIMERS_BASE)
#define PCM                         ((PCM_Type*)               PCM_BASE)
#define PWM_DAC                     ((PWM_DAC_Type*)           PWM_DAC_BASE)
#define PMP_IO_CFG                  ((PMP_IO_CFG_Type*)        PMP_IO_CFG_BASE)
#define PMP_IO_PAR                  ((PMP_IO_PAR_Type*)        PMP_IO_PAR_BASE)
#define SERIAL_FLASH_CTRL_MANUAL    ((SERIAL_FLASH_CTRL_MANUAL_Type*)  SERIAL_FLASH_CTRL_MANUAL_BASE)
#define SERIAL_FLASH_CTRL_MCU_SUBSYS ((SERIAL_FLASH_CTRL_MCU_SUBSYS_Type*)  SERIAL_FLASH_CTRL_MCU_SUBSYS_BASE)
#define SERIAL_FLASH_CTRL_SECURITY  ((SERIAL_FLASH_CTRL_SECURITY_Type*)  SERIAL_FLASH_CTRL_SECURITY_BASE)
#define GSP_REGFILE                 ((GSP_REGFILE_Type*)       GSP_REGFILE_BASE)
#define GPM_IO_CFG                  ((GPM_IO_CFG_Type*)        GPM_IO_CFG_BASE)
#define GPM_IO_PAR                  ((GPM_IO_PAR_Type*)        GPM_IO_PAR_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


/* =========================================================================================================================== */
/* ================                                Pos/Mask Peripheral Section                                ================ */
/* =========================================================================================================================== */


/** @addtogroup PosMask_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          AUX_ADC                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  RESULT  ========================================================= */
#define AUX_ADC_B0_RESULT_RESULT_Pos      (0UL)                     /*!< RESULT (Bit 0)                                        */
#define AUX_ADC_B0_RESULT_RESULT_Msk      (0xfffUL)                 /*!< RESULT (Bitfield-Mask: 0xfff)                         */
/* ===================================================  RESULT_AND_MARKER  =================================================== */
#define AUX_ADC_B0_RESULT_AND_MARKER_RESULT_Pos (0UL)               /*!< RESULT (Bit 0)                                        */
#define AUX_ADC_B0_RESULT_AND_MARKER_RESULT_Msk (0xfffUL)           /*!< RESULT (Bitfield-Mask: 0xfff)                         */
#define AUX_ADC_B0_RESULT_AND_MARKER_MARKER_Pos (12UL)              /*!< MARKER (Bit 12)                                       */
#define AUX_ADC_B0_RESULT_AND_MARKER_MARKER_Msk (0x1000UL)          /*!< MARKER (Bitfield-Mask: 0x01)                          */
/* =================================================  RESULT_AND_MARKER_CLR  ================================================= */
#define AUX_ADC_B0_RESULT_AND_MARKER_CLR_RESULT_Pos (0UL)           /*!< RESULT (Bit 0)                                        */
#define AUX_ADC_B0_RESULT_AND_MARKER_CLR_RESULT_Msk (0xfffUL)       /*!< RESULT (Bitfield-Mask: 0xfff)                         */
#define AUX_ADC_B0_RESULT_AND_MARKER_CLR_MARKER_Pos (12UL)          /*!< MARKER (Bit 12)                                       */
#define AUX_ADC_B0_RESULT_AND_MARKER_CLR_MARKER_Msk (0x1000UL)      /*!< MARKER (Bitfield-Mask: 0x01)                          */
/* =====================================================  SOURCE_SELECT  ===================================================== */
#define AUX_ADC_B0_SOURCE_SELECT_SOURCE_SELECT_Pos (0UL)            /*!< SOURCE_SELECT (Bit 0)                                 */
#define AUX_ADC_B0_SOURCE_SELECT_SOURCE_SELECT_Msk (0x7UL)          /*!< SOURCE_SELECT (Bitfield-Mask: 0x07)                   */
/* ==========================================================  CFG  ========================================================== */
#define AUX_ADC_B0_CFG_EN_SAMPLE_Pos      (0UL)                     /*!< EN_SAMPLE (Bit 0)                                     */
#define AUX_ADC_B0_CFG_EN_SAMPLE_Msk      (0x1UL)                   /*!< EN_SAMPLE (Bitfield-Mask: 0x01)                       */
#define AUX_ADC_B0_CFG_EN_OVERWRITE_Pos   (1UL)                     /*!< EN_OVERWRITE (Bit 1)                                  */
#define AUX_ADC_B0_CFG_EN_OVERWRITE_Msk   (0x2UL)                   /*!< EN_OVERWRITE (Bitfield-Mask: 0x01)                    */
#define AUX_ADC_B0_CFG_EN_AGU_Pos         (2UL)                     /*!< EN_AGU (Bit 2)                                        */
#define AUX_ADC_B0_CFG_EN_AGU_Msk         (0x4UL)                   /*!< EN_AGU (Bitfield-Mask: 0x01)                          */
#define AUX_ADC_B0_CFG_AGU_ACCUMULATE_Pos (3UL)                     /*!< AGU_ACCUMULATE (Bit 3)                                */
#define AUX_ADC_B0_CFG_AGU_ACCUMULATE_Msk (0x8UL)                   /*!< AGU_ACCUMULATE (Bitfield-Mask: 0x01)                  */
#define AUX_ADC_B0_CFG_EN_GATED_Pos       (4UL)                     /*!< EN_GATED (Bit 4)                                      */
#define AUX_ADC_B0_CFG_EN_GATED_Msk       (0x10UL)                  /*!< EN_GATED (Bitfield-Mask: 0x01)                        */
#define AUX_ADC_B0_CFG_AVG_PROGRAM_Pos    (8UL)                     /*!< AVG_PROGRAM (Bit 8)                                   */
#define AUX_ADC_B0_CFG_AVG_PROGRAM_Msk    (0x7f00UL)                /*!< AVG_PROGRAM (Bitfield-Mask: 0x7f)                     */
#define AUX_ADC_B0_CFG_AVG_PROGRAM_EN_Pos (15UL)                    /*!< AVG_PROGRAM_EN (Bit 15)                               */
#define AUX_ADC_B0_CFG_AVG_PROGRAM_EN_Msk (0x8000UL)                /*!< AVG_PROGRAM_EN (Bitfield-Mask: 0x01)                  */
/* ======================================================  AGU_STATUS  ======================================================= */
#define AUX_ADC_B0_AGU_STATUS_AGU_STATUS_Pos (0UL)                  /*!< AGU_STATUS (Bit 0)                                    */
#define AUX_ADC_B0_AGU_STATUS_AGU_STATUS_Msk (0x1fffffUL)           /*!< AGU_STATUS (Bitfield-Mask: 0x1fffff)                  */
/* ========================================================  AVG_CNT  ======================================================== */
#define AUX_ADC_B0_AVG_CNT_AVG_CNT_Pos    (0UL)                     /*!< AVG_CNT (Bit 0)                                       */
#define AUX_ADC_B0_AVG_CNT_AVG_CNT_Msk    (0x7fUL)                  /*!< AVG_CNT (Bitfield-Mask: 0x7f)                         */
/* ========================================================  AVG_ACC  ======================================================== */
#define AUX_ADC_B0_AVG_ACC_AVG_ACC_Pos    (0UL)                     /*!< AVG_ACC (Bit 0)                                       */
#define AUX_ADC_B0_AVG_ACC_AVG_ACC_Msk    (0x7ffffUL)               /*!< AVG_ACC (Bitfield-Mask: 0x7ffff)                      */
/* =====================================================  AVG_64_RESULT  ===================================================== */
#define AUX_ADC_B0_AVG_64_RESULT_AVG_64_RESULT_Pos (0UL)            /*!< AVG_64_RESULT (Bit 0)                                 */
#define AUX_ADC_B0_AVG_64_RESULT_AVG_64_RESULT_Msk (0xfffUL)        /*!< AVG_64_RESULT (Bitfield-Mask: 0xfff)                  */
/* ========================================================  AVG_MAX  ======================================================== */
#define AUX_ADC_B0_AVG_MAX_AVG_MAX_Pos    (0UL)                     /*!< AVG_MAX (Bit 0)                                       */
#define AUX_ADC_B0_AVG_MAX_AVG_MAX_Msk    (0xfffUL)                 /*!< AVG_MAX (Bitfield-Mask: 0xfff)                        */
/* ========================================================  AVG_MIN  ======================================================== */
#define AUX_ADC_B0_AVG_MIN_AVG_MIN_Pos    (0UL)                     /*!< AVG_MIN (Bit 0)                                       */
#define AUX_ADC_B0_AVG_MIN_AVG_MIN_Msk    (0xfffUL)                 /*!< AVG_MIN (Bitfield-Mask: 0xfff)                        */
/* =======================================================  ALRM_CFG  ======================================================== */
#define AUX_ADC_B0_ALRM_CFG_ALRM_TH_Pos   (0UL)                     /*!< ALRM_TH (Bit 0)                                       */
#define AUX_ADC_B0_ALRM_CFG_ALRM_TH_Msk   (0xfffUL)                 /*!< ALRM_TH (Bitfield-Mask: 0xfff)                        */
#define AUX_ADC_B0_ALRM_CFG_ALRM_EN_TH_HIGH_Pos (12UL)              /*!< ALRM_EN_TH_HIGH (Bit 12)                              */
#define AUX_ADC_B0_ALRM_CFG_ALRM_EN_TH_HIGH_Msk (0x1000UL)          /*!< ALRM_EN_TH_HIGH (Bitfield-Mask: 0x01)                 */
#define AUX_ADC_B0_ALRM_CFG_ALRM_EN_TH_LOW_Pos (13UL)               /*!< ALRM_EN_TH_LOW (Bit 13)                               */
#define AUX_ADC_B0_ALRM_CFG_ALRM_EN_TH_LOW_Msk (0x2000UL)           /*!< ALRM_EN_TH_LOW (Bitfield-Mask: 0x01)                  */
#define AUX_ADC_B0_ALRM_CFG_AVG8_ALRM_EN_TH_HIGH_Pos (14UL)         /*!< AVG8_ALRM_EN_TH_HIGH (Bit 14)                         */
#define AUX_ADC_B0_ALRM_CFG_AVG8_ALRM_EN_TH_HIGH_Msk (0x4000UL)     /*!< AVG8_ALRM_EN_TH_HIGH (Bitfield-Mask: 0x01)            */
#define AUX_ADC_B0_ALRM_CFG_AVG8_ALRM_EN_TH_LOW_Pos (15UL)          /*!< AVG8_ALRM_EN_TH_LOW (Bit 15)                          */
#define AUX_ADC_B0_ALRM_CFG_AVG8_ALRM_EN_TH_LOW_Msk (0x8000UL)      /*!< AVG8_ALRM_EN_TH_LOW (Bitfield-Mask: 0x01)             */
/* =======================================================  ALRM_READ  ======================================================= */
#define AUX_ADC_B0_ALRM_READ_ALRM_READ_Pos (0UL)                    /*!< ALRM_READ (Bit 0)                                     */
#define AUX_ADC_B0_ALRM_READ_ALRM_READ_Msk (0xfffUL)                /*!< ALRM_READ (Bitfield-Mask: 0xfff)                      */
/* =========================================================  IRPT  ========================================================== */
#define AUX_ADC_B0_IRPT_AVG_DONE_Pos      (0UL)                     /*!< AVG_DONE (Bit 0)                                      */
#define AUX_ADC_B0_IRPT_AVG_DONE_Msk      (0x1UL)                   /*!< AVG_DONE (Bitfield-Mask: 0x01)                        */
#define AUX_ADC_B0_IRPT_ALRM_Pos          (1UL)                     /*!< ALRM (Bit 1)                                          */
#define AUX_ADC_B0_IRPT_ALRM_Msk          (0x2UL)                   /*!< ALRM (Bitfield-Mask: 0x01)                            */
#define AUX_ADC_B0_IRPT_OVERWRITE_Pos     (2UL)                     /*!< OVERWRITE (Bit 2)                                     */
#define AUX_ADC_B0_IRPT_OVERWRITE_Msk     (0x4UL)                   /*!< OVERWRITE (Bitfield-Mask: 0x01)                       */
#define AUX_ADC_B0_IRPT_RETENTION_FAILURE_Pos (3UL)                 /*!< RETENTION_FAILURE (Bit 3)                             */
#define AUX_ADC_B0_IRPT_RETENTION_FAILURE_Msk (0x8UL)               /*!< RETENTION_FAILURE (Bitfield-Mask: 0x01)               */
/* =======================================================  IRPT_CLR  ======================================================== */
#define AUX_ADC_B0_IRPT_CLR_AVG_DONE_Pos  (0UL)                     /*!< AVG_DONE (Bit 0)                                      */
#define AUX_ADC_B0_IRPT_CLR_AVG_DONE_Msk  (0x1UL)                   /*!< AVG_DONE (Bitfield-Mask: 0x01)                        */
#define AUX_ADC_B0_IRPT_CLR_ALRM_Pos      (1UL)                     /*!< ALRM (Bit 1)                                          */
#define AUX_ADC_B0_IRPT_CLR_ALRM_Msk      (0x2UL)                   /*!< ALRM (Bitfield-Mask: 0x01)                            */
#define AUX_ADC_B0_IRPT_CLR_OVERWRITE_Pos (2UL)                     /*!< OVERWRITE (Bit 2)                                     */
#define AUX_ADC_B0_IRPT_CLR_OVERWRITE_Msk (0x4UL)                   /*!< OVERWRITE (Bitfield-Mask: 0x01)                       */
#define AUX_ADC_B0_IRPT_CLR_RETENTION_FAILURE_Pos (3UL)             /*!< RETENTION_FAILURE (Bit 3)                             */
#define AUX_ADC_B0_IRPT_CLR_RETENTION_FAILURE_Msk (0x8UL)           /*!< RETENTION_FAILURE (Bitfield-Mask: 0x01)               */
/* ========================================================  IRPT_EN  ======================================================== */
#define AUX_ADC_B0_IRPT_EN_AVG_DONE_Pos   (0UL)                     /*!< AVG_DONE (Bit 0)                                      */
#define AUX_ADC_B0_IRPT_EN_AVG_DONE_Msk   (0x1UL)                   /*!< AVG_DONE (Bitfield-Mask: 0x01)                        */
#define AUX_ADC_B0_IRPT_EN_ALRM_Pos       (1UL)                     /*!< ALRM (Bit 1)                                          */
#define AUX_ADC_B0_IRPT_EN_ALRM_Msk       (0x2UL)                   /*!< ALRM (Bitfield-Mask: 0x01)                            */
#define AUX_ADC_B0_IRPT_EN_OVERWRITE_Pos  (2UL)                     /*!< OVERWRITE (Bit 2)                                     */
#define AUX_ADC_B0_IRPT_EN_OVERWRITE_Msk  (0x4UL)                   /*!< OVERWRITE (Bitfield-Mask: 0x01)                       */
#define AUX_ADC_B0_IRPT_EN_RETENTION_FAILURE_Pos (3UL)              /*!< RETENTION_FAILURE (Bit 3)                             */
#define AUX_ADC_B0_IRPT_EN_RETENTION_FAILURE_Msk (0x8UL)            /*!< RETENTION_FAILURE (Bitfield-Mask: 0x01)               */


/* =========================================================================================================================== */
/* ================                                           GDMA                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CMD0_CNT_INC  ====================================================== */
#define GDMA_CMD0_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD0_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD0_BASE_ADDR  ===================================================== */
#define GDMA_CMD0_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD0_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD0_INDEX  ======================================================= */
#define GDMA_CMD0_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD0_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD0_SIZE  ======================================================= */
#define GDMA_CMD0_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD0_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD0_STATUS  ====================================================== */
#define GDMA_CMD0_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD0_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD0_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD0_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD0_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD0_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT0_INDEX  ====================================================== */
#define GDMA_STAT0_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT0_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD1_CNT_INC  ====================================================== */
#define GDMA_CMD1_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD1_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD1_BASE_ADDR  ===================================================== */
#define GDMA_CMD1_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD1_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD1_INDEX  ======================================================= */
#define GDMA_CMD1_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD1_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD1_SIZE  ======================================================= */
#define GDMA_CMD1_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD1_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD1_STATUS  ====================================================== */
#define GDMA_CMD1_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD1_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD1_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD1_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD1_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD1_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT1_INDEX  ====================================================== */
#define GDMA_STAT1_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT1_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD2_CNT_INC  ====================================================== */
#define GDMA_CMD2_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD2_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD2_BASE_ADDR  ===================================================== */
#define GDMA_CMD2_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD2_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD2_INDEX  ======================================================= */
#define GDMA_CMD2_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD2_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD2_SIZE  ======================================================= */
#define GDMA_CMD2_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD2_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD2_STATUS  ====================================================== */
#define GDMA_CMD2_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD2_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD2_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD2_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD2_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD2_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT2_INDEX  ====================================================== */
#define GDMA_STAT2_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT2_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD3_CNT_INC  ====================================================== */
#define GDMA_CMD3_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD3_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD3_BASE_ADDR  ===================================================== */
#define GDMA_CMD3_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD3_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD3_INDEX  ======================================================= */
#define GDMA_CMD3_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD3_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD3_SIZE  ======================================================= */
#define GDMA_CMD3_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD3_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD3_STATUS  ====================================================== */
#define GDMA_CMD3_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD3_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD3_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD3_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD3_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD3_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT3_INDEX  ====================================================== */
#define GDMA_STAT3_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT3_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD4_CNT_INC  ====================================================== */
#define GDMA_CMD4_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD4_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD4_BASE_ADDR  ===================================================== */
#define GDMA_CMD4_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD4_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD4_INDEX  ======================================================= */
#define GDMA_CMD4_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD4_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD4_SIZE  ======================================================= */
#define GDMA_CMD4_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD4_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD4_STATUS  ====================================================== */
#define GDMA_CMD4_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD4_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD4_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD4_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD4_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD4_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT4_INDEX  ====================================================== */
#define GDMA_STAT4_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT4_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD5_CNT_INC  ====================================================== */
#define GDMA_CMD5_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD5_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD5_BASE_ADDR  ===================================================== */
#define GDMA_CMD5_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD5_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD5_INDEX  ======================================================= */
#define GDMA_CMD5_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD5_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD5_SIZE  ======================================================= */
#define GDMA_CMD5_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD5_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD5_STATUS  ====================================================== */
#define GDMA_CMD5_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD5_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD5_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD5_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD5_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD5_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT5_INDEX  ====================================================== */
#define GDMA_STAT5_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT5_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD6_CNT_INC  ====================================================== */
#define GDMA_CMD6_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD6_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD6_BASE_ADDR  ===================================================== */
#define GDMA_CMD6_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD6_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD6_INDEX  ======================================================= */
#define GDMA_CMD6_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD6_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD6_SIZE  ======================================================= */
#define GDMA_CMD6_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD6_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD6_STATUS  ====================================================== */
#define GDMA_CMD6_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD6_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD6_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD6_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD6_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD6_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT6_INDEX  ====================================================== */
#define GDMA_STAT6_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT6_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =====================================================  CMD7_CNT_INC  ====================================================== */
#define GDMA_CMD7_CNT_INC_DATA_Pos        (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD7_CNT_INC_DATA_Msk        (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ====================================================  CMD7_BASE_ADDR  ===================================================== */
#define GDMA_CMD7_BASE_ADDR_DATA_Pos      (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD7_BASE_ADDR_DATA_Msk      (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  CMD7_INDEX  ======================================================= */
#define GDMA_CMD7_INDEX_DATA_Pos          (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD7_INDEX_DATA_Msk          (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  CMD7_SIZE  ======================================================= */
#define GDMA_CMD7_SIZE_DATA_Pos           (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_CMD7_SIZE_DATA_Msk           (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ======================================================  CMD7_STATUS  ====================================================== */
#define GDMA_CMD7_STATUS_CNT_Pos          (0UL)                     /*!< CNT (Bit 0)                                           */
#define GDMA_CMD7_STATUS_CNT_Msk          (0xffUL)                  /*!< CNT (Bitfield-Mask: 0xff)                             */
#define GDMA_CMD7_STATUS_EMPTY_Pos        (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define GDMA_CMD7_STATUS_EMPTY_Msk        (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define GDMA_CMD7_STATUS_FULL_Pos         (9UL)                     /*!< FULL (Bit 9)                                          */
#define GDMA_CMD7_STATUS_FULL_Msk         (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
/* ======================================================  STAT7_INDEX  ====================================================== */
#define GDMA_STAT7_INDEX_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_STAT7_INDEX_DATA_Msk         (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* =======================================================  DMA_CTRL  ======================================================== */
#define GDMA_DMA_CTRL_STOP_Pos            (0UL)                     /*!< STOP (Bit 0)                                          */
#define GDMA_DMA_CTRL_STOP_Msk            (0x1UL)                   /*!< STOP (Bitfield-Mask: 0x01)                            */
#define GDMA_DMA_CTRL_FLUSH_Pos           (1UL)                     /*!< FLUSH (Bit 1)                                         */
#define GDMA_DMA_CTRL_FLUSH_Msk           (0x2UL)                   /*!< FLUSH (Bitfield-Mask: 0x01)                           */
#define GDMA_DMA_CTRL_CLEAR_FIFO_Pos      (2UL)                     /*!< CLEAR_FIFO (Bit 2)                                    */
#define GDMA_DMA_CTRL_CLEAR_FIFO_Msk      (0x4UL)                   /*!< CLEAR_FIFO (Bitfield-Mask: 0x01)                      */
#define GDMA_DMA_CTRL_RESET_MAIN_CTRL_Pos (3UL)                     /*!< RESET_MAIN_CTRL (Bit 3)                               */
#define GDMA_DMA_CTRL_RESET_MAIN_CTRL_Msk (0x8UL)                   /*!< RESET_MAIN_CTRL (Bitfield-Mask: 0x01)                 */
#define GDMA_DMA_CTRL_RESET_WR_Pos        (4UL)                     /*!< RESET_WR (Bit 4)                                      */
#define GDMA_DMA_CTRL_RESET_WR_Msk        (0x10UL)                  /*!< RESET_WR (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CTRL_RESET_WR_BUFF_Pos   (5UL)                     /*!< RESET_WR_BUFF (Bit 5)                                 */
#define GDMA_DMA_CTRL_RESET_WR_BUFF_Msk   (0x20UL)                  /*!< RESET_WR_BUFF (Bitfield-Mask: 0x01)                   */
#define GDMA_DMA_CTRL_RESET_WR_BD_Pos     (6UL)                     /*!< RESET_WR_BD (Bit 6)                                   */
#define GDMA_DMA_CTRL_RESET_WR_BD_Msk     (0x40UL)                  /*!< RESET_WR_BD (Bitfield-Mask: 0x01)                     */
#define GDMA_DMA_CTRL_RESET_RD_Pos        (7UL)                     /*!< RESET_RD (Bit 7)                                      */
#define GDMA_DMA_CTRL_RESET_RD_Msk        (0x80UL)                  /*!< RESET_RD (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CTRL_RESET_RD_BUFF_Pos   (8UL)                     /*!< RESET_RD_BUFF (Bit 8)                                 */
#define GDMA_DMA_CTRL_RESET_RD_BUFF_Msk   (0x100UL)                 /*!< RESET_RD_BUFF (Bitfield-Mask: 0x01)                   */
#define GDMA_DMA_CTRL_RESET_RD_BD_Pos     (9UL)                     /*!< RESET_RD_BD (Bit 9)                                   */
#define GDMA_DMA_CTRL_RESET_RD_BD_Msk     (0x200UL)                 /*!< RESET_RD_BD (Bitfield-Mask: 0x01)                     */
#define GDMA_DMA_CTRL_WRITEBACK_BD_MODE_Pos (10UL)                  /*!< WRITEBACK_BD_MODE (Bit 10)                            */
#define GDMA_DMA_CTRL_WRITEBACK_BD_MODE_Msk (0x400UL)               /*!< WRITEBACK_BD_MODE (Bitfield-Mask: 0x01)               */
/* =====================================================  DMA_ARB_CTRL  ====================================================== */
#define GDMA_DMA_ARB_CTRL_MODE_Pos        (0UL)                     /*!< MODE (Bit 0)                                          */
#define GDMA_DMA_ARB_CTRL_MODE_Msk        (0x3UL)                   /*!< MODE (Bitfield-Mask: 0x03)                            */
#define GDMA_DMA_ARB_CTRL_PRIORITIES_Pos  (4UL)                     /*!< PRIORITIES (Bit 4)                                    */
#define GDMA_DMA_ARB_CTRL_PRIORITIES_Msk  (0xff0UL)                 /*!< PRIORITIES (Bitfield-Mask: 0xff)                      */
/* ===================================================  RD_FIFO_THRESHOLD  =================================================== */
#define GDMA_RD_FIFO_THRESHOLD_DATA_Pos   (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_RD_FIFO_THRESHOLD_DATA_Msk   (0x1ffUL)                 /*!< DATA (Bitfield-Mask: 0x1ff)                           */
/* ===================================================  WR_FIFO_THRESHOLD  =================================================== */
#define GDMA_WR_FIFO_THRESHOLD_DATA_Pos   (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_WR_FIFO_THRESHOLD_DATA_Msk   (0x1ffUL)                 /*!< DATA (Bitfield-Mask: 0x1ff)                           */
/* =============================================  DMA_CHS_DONE_INT_STAT_NO_CLR  ============================================== */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH0_STAT_Pos (0UL)        /*!< CH0_STAT (Bit 0)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH0_STAT_Msk (0x1UL)      /*!< CH0_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH1_STAT_Pos (1UL)        /*!< CH1_STAT (Bit 1)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH1_STAT_Msk (0x2UL)      /*!< CH1_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH2_STAT_Pos (2UL)        /*!< CH2_STAT (Bit 2)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH2_STAT_Msk (0x4UL)      /*!< CH2_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH3_STAT_Pos (3UL)        /*!< CH3_STAT (Bit 3)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH3_STAT_Msk (0x8UL)      /*!< CH3_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH4_STAT_Pos (4UL)        /*!< CH4_STAT (Bit 4)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH4_STAT_Msk (0x10UL)     /*!< CH4_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH5_STAT_Pos (5UL)        /*!< CH5_STAT (Bit 5)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH5_STAT_Msk (0x20UL)     /*!< CH5_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH6_STAT_Pos (6UL)        /*!< CH6_STAT (Bit 6)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH6_STAT_Msk (0x40UL)     /*!< CH6_STAT (Bitfield-Mask: 0x01)                        */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH7_STAT_Pos (7UL)        /*!< CH7_STAT (Bit 7)                                      */
#define GDMA_DMA_CHS_DONE_INT_STAT_NO_CLR_CH7_STAT_Msk (0x80UL)     /*!< CH7_STAT (Bitfield-Mask: 0x01)                        */
/* =================================================  DMA_CH0_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH0_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH0_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH1_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH1_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH1_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH2_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH2_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH2_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH3_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH3_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH3_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH4_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH4_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH4_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH5_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH5_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH5_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH6_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH6_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH6_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =================================================  DMA_CH7_DONE_INT_STAT  ================================================= */
#define GDMA_DMA_CH7_DONE_INT_STAT_STAT_Pos (0UL)                   /*!< STAT (Bit 0)                                          */
#define GDMA_DMA_CH7_DONE_INT_STAT_STAT_Msk (0x1UL)                 /*!< STAT (Bitfield-Mask: 0x01)                            */
/* =====================================================  MAIN_SM_STAT  ====================================================== */
#define GDMA_MAIN_SM_STAT_STAT_DISPATCHER_SM_CS_Pos (20UL)          /*!< STAT_DISPATCHER_SM_CS (Bit 20)                        */
#define GDMA_MAIN_SM_STAT_STAT_DISPATCHER_SM_CS_Msk (0x700000UL)    /*!< STAT_DISPATCHER_SM_CS (Bitfield-Mask: 0x07)           */
#define GDMA_MAIN_SM_STAT_CMD_FETCHR_SM_CS_Pos (16UL)               /*!< CMD_FETCHR_SM_CS (Bit 16)                             */
#define GDMA_MAIN_SM_STAT_CMD_FETCHR_SM_CS_Msk (0x70000UL)          /*!< CMD_FETCHR_SM_CS (Bitfield-Mask: 0x07)                */
#define GDMA_MAIN_SM_STAT_WR_SM_CS_Pos    (14UL)                    /*!< WR_SM_CS (Bit 14)                                     */
#define GDMA_MAIN_SM_STAT_WR_SM_CS_Msk    (0xc000UL)                /*!< WR_SM_CS (Bitfield-Mask: 0x03)                        */
#define GDMA_MAIN_SM_STAT_RD_SM_CS_Pos    (12UL)                    /*!< RD_SM_CS (Bit 12)                                     */
#define GDMA_MAIN_SM_STAT_RD_SM_CS_Msk    (0x3000UL)                /*!< RD_SM_CS (Bitfield-Mask: 0x03)                        */
#define GDMA_MAIN_SM_STAT_RD_CMD_CH_Pos   (4UL)                     /*!< RD_CMD_CH (Bit 4)                                     */
#define GDMA_MAIN_SM_STAT_RD_CMD_CH_Msk   (0xff0UL)                 /*!< RD_CMD_CH (Bitfield-Mask: 0xff)                       */
#define GDMA_MAIN_SM_STAT_MAIN_SM_CS_Pos  (0UL)                     /*!< MAIN_SM_CS (Bit 0)                                    */
#define GDMA_MAIN_SM_STAT_MAIN_SM_CS_Msk  (0x7UL)                   /*!< MAIN_SM_CS (Bitfield-Mask: 0x07)                      */
/* ======================================================  WR_SM_STAT  ======================================================= */
#define GDMA_WR_SM_STAT_CMD_RESP_CNT_Pos  (16UL)                    /*!< CMD_RESP_CNT (Bit 16)                                 */
#define GDMA_WR_SM_STAT_CMD_RESP_CNT_Msk  (0x1f0000UL)              /*!< CMD_RESP_CNT (Bitfield-Mask: 0x1f)                    */
#define GDMA_WR_SM_STAT_BD_CS_Pos         (8UL)                     /*!< BD_CS (Bit 8)                                         */
#define GDMA_WR_SM_STAT_BD_CS_Msk         (0x700UL)                 /*!< BD_CS (Bitfield-Mask: 0x07)                           */
#define GDMA_WR_SM_STAT_BUFF_CS_Pos       (0UL)                     /*!< BUFF_CS (Bit 0)                                       */
#define GDMA_WR_SM_STAT_BUFF_CS_Msk       (0x7UL)                   /*!< BUFF_CS (Bitfield-Mask: 0x07)                         */
/* ======================================================  RD_SM_STAT  ======================================================= */
#define GDMA_RD_SM_STAT_CMD_RESP_CNT_Pos  (16UL)                    /*!< CMD_RESP_CNT (Bit 16)                                 */
#define GDMA_RD_SM_STAT_CMD_RESP_CNT_Msk  (0x1f0000UL)              /*!< CMD_RESP_CNT (Bitfield-Mask: 0x1f)                    */
#define GDMA_RD_SM_STAT_BD_CS_Pos         (8UL)                     /*!< BD_CS (Bit 8)                                         */
#define GDMA_RD_SM_STAT_BD_CS_Msk         (0x700UL)                 /*!< BD_CS (Bitfield-Mask: 0x07)                           */
#define GDMA_RD_SM_STAT_BUFF_CS_Pos       (0UL)                     /*!< BUFF_CS (Bit 0)                                       */
#define GDMA_RD_SM_STAT_BUFF_CS_Msk       (0x7UL)                   /*!< BUFF_CS (Bitfield-Mask: 0x07)                         */
/* ===================================================  CUR_RD_ADDR_STAT  ==================================================== */
#define GDMA_CUR_RD_ADDR_STAT_ADDR_Pos    (0UL)                     /*!< ADDR (Bit 0)                                          */
#define GDMA_CUR_RD_ADDR_STAT_ADDR_Msk    (0xffffffffUL)            /*!< ADDR (Bitfield-Mask: 0xffffffff)                      */
/* ====================================================  CUR_RD_BD_STAT  ===================================================== */
#define GDMA_CUR_RD_BD_STAT_BD_Pos        (0UL)                     /*!< BD (Bit 0)                                            */
#define GDMA_CUR_RD_BD_STAT_BD_Msk        (0xffffffffUL)            /*!< BD (Bitfield-Mask: 0xffffffff)                        */
/* ====================================================  CUR_RD_LEN_STAT  ==================================================== */
#define GDMA_CUR_RD_LEN_STAT_LEN_Pos      (0UL)                     /*!< LEN (Bit 0)                                           */
#define GDMA_CUR_RD_LEN_STAT_LEN_Msk      (0xffffUL)                /*!< LEN (Bitfield-Mask: 0xffff)                           */
/* ===================================================  CUR_WR_ADDR_STAT  ==================================================== */
#define GDMA_CUR_WR_ADDR_STAT_ADDR_Pos    (0UL)                     /*!< ADDR (Bit 0)                                          */
#define GDMA_CUR_WR_ADDR_STAT_ADDR_Msk    (0xffffffffUL)            /*!< ADDR (Bitfield-Mask: 0xffffffff)                      */
/* ====================================================  CUR_WR_BD_STAT  ===================================================== */
#define GDMA_CUR_WR_BD_STAT_BD_Pos        (0UL)                     /*!< BD (Bit 0)                                            */
#define GDMA_CUR_WR_BD_STAT_BD_Msk        (0xffffffffUL)            /*!< BD (Bitfield-Mask: 0xffffffff)                        */
/* ====================================================  CUR_WR_LEN_STAT  ==================================================== */
#define GDMA_CUR_WR_LEN_STAT_LEN_Pos      (0UL)                     /*!< LEN (Bit 0)                                           */
#define GDMA_CUR_WR_LEN_STAT_LEN_Msk      (0xffffUL)                /*!< LEN (Bitfield-Mask: 0xffff)                           */
/* ======================================================  CUR_CMD_IDX  ====================================================== */
#define GDMA_CUR_CMD_IDX_ID_Pos           (0UL)                     /*!< ID (Bit 0)                                            */
#define GDMA_CUR_CMD_IDX_ID_Msk           (0xffUL)                  /*!< ID (Bitfield-Mask: 0xff)                              */
/* ======================================================  ERRORS_STAT  ====================================================== */
#define GDMA_ERRORS_STAT_CMD_FETCHER_Pos  (0UL)                     /*!< CMD_FETCHER (Bit 0)                                   */
#define GDMA_ERRORS_STAT_CMD_FETCHER_Msk  (0x1UL)                   /*!< CMD_FETCHER (Bitfield-Mask: 0x01)                     */
#define GDMA_ERRORS_STAT_RD_BD_Pos        (1UL)                     /*!< RD_BD (Bit 1)                                         */
#define GDMA_ERRORS_STAT_RD_BD_Msk        (0x2UL)                   /*!< RD_BD (Bitfield-Mask: 0x01)                           */
#define GDMA_ERRORS_STAT_RD_BD_SAMP_CNTR_Pos (2UL)                  /*!< RD_BD_SAMP_CNTR (Bit 2)                               */
#define GDMA_ERRORS_STAT_RD_BD_SAMP_CNTR_Msk (0x4UL)                /*!< RD_BD_SAMP_CNTR (Bitfield-Mask: 0x01)                 */
#define GDMA_ERRORS_STAT_RD_BD_ADDR_Pos   (3UL)                     /*!< RD_BD_ADDR (Bit 3)                                    */
#define GDMA_ERRORS_STAT_RD_BD_ADDR_Msk   (0x8UL)                   /*!< RD_BD_ADDR (Bitfield-Mask: 0x01)                      */
#define GDMA_ERRORS_STAT_RD_BD_NEXT_ADDR_Pos (4UL)                  /*!< RD_BD_NEXT_ADDR (Bit 4)                               */
#define GDMA_ERRORS_STAT_RD_BD_NEXT_ADDR_Msk (0x10UL)               /*!< RD_BD_NEXT_ADDR (Bitfield-Mask: 0x01)                 */
#define GDMA_ERRORS_STAT_WR_BD_Pos        (6UL)                     /*!< WR_BD (Bit 6)                                         */
#define GDMA_ERRORS_STAT_WR_BD_Msk        (0x40UL)                  /*!< WR_BD (Bitfield-Mask: 0x01)                           */
#define GDMA_ERRORS_STAT_WR_BD_SAMP_CNTR_Pos (7UL)                  /*!< WR_BD_SAMP_CNTR (Bit 7)                               */
#define GDMA_ERRORS_STAT_WR_BD_SAMP_CNTR_Msk (0x80UL)               /*!< WR_BD_SAMP_CNTR (Bitfield-Mask: 0x01)                 */
#define GDMA_ERRORS_STAT_WR_BD_ADDR_Pos   (8UL)                     /*!< WR_BD_ADDR (Bit 8)                                    */
#define GDMA_ERRORS_STAT_WR_BD_ADDR_Msk   (0x100UL)                 /*!< WR_BD_ADDR (Bitfield-Mask: 0x01)                      */
#define GDMA_ERRORS_STAT_WR_BD_NEXT_ADDR_Pos (9UL)                  /*!< WR_BD_NEXT_ADDR (Bit 9)                               */
#define GDMA_ERRORS_STAT_WR_BD_NEXT_ADDR_Msk (0x200UL)              /*!< WR_BD_NEXT_ADDR (Bitfield-Mask: 0x01)                 */
/* ======================================================  TRANS_CNTR  ======================================================= */
#define GDMA_TRANS_CNTR_DMA_TRANS_CNTR_Pos (0UL)                    /*!< DMA_TRANS_CNTR (Bit 0)                                */
#define GDMA_TRANS_CNTR_DMA_TRANS_CNTR_Msk (0xffUL)                 /*!< DMA_TRANS_CNTR (Bitfield-Mask: 0xff)                  */
/* ===============================================  DMA_CUR_RD_ACUM_LEN_STAT  ================================================ */
#define GDMA_DMA_CUR_RD_ACUM_LEN_STAT_CUR_RD_ACUM_LEN_Pos (0UL)     /*!< CUR_RD_ACUM_LEN (Bit 0)                               */
#define GDMA_DMA_CUR_RD_ACUM_LEN_STAT_CUR_RD_ACUM_LEN_Msk (0xffffffUL) /*!< CUR_RD_ACUM_LEN (Bitfield-Mask: 0xffffff)          */
/* ===============================================  DMA_NEXT_RD_BD_ADDR_STAT  ================================================ */
#define GDMA_DMA_NEXT_RD_BD_ADDR_STAT_NEXT_BD_RD_ADDR_Pos (0UL)     /*!< NEXT_BD_RD_ADDR (Bit 0)                               */
#define GDMA_DMA_NEXT_RD_BD_ADDR_STAT_NEXT_BD_RD_ADDR_Msk (0xffffffffUL) /*!< NEXT_BD_RD_ADDR (Bitfield-Mask: 0xffffffff)      */
/* ================================================  DMA_START_RD_ADDR_STAT  ================================================= */
#define GDMA_DMA_START_RD_ADDR_STAT_START_RD_ADDR_Pos (0UL)         /*!< START_RD_ADDR (Bit 0)                                 */
#define GDMA_DMA_START_RD_ADDR_STAT_START_RD_ADDR_Msk (0xffffffffUL) /*!< START_RD_ADDR (Bitfield-Mask: 0xffffffff)            */
/* ===============================================  DMA_CUR_WR_ACUM_LEN_STAT  ================================================ */
#define GDMA_DMA_CUR_WR_ACUM_LEN_STAT_CUR_WR_ACUM_LEN_Pos (0UL)     /*!< CUR_WR_ACUM_LEN (Bit 0)                               */
#define GDMA_DMA_CUR_WR_ACUM_LEN_STAT_CUR_WR_ACUM_LEN_Msk (0xffffffUL) /*!< CUR_WR_ACUM_LEN (Bitfield-Mask: 0xffffff)          */
/* ===============================================  DMA_NEXT_WR_BD_ADDR_STAT  ================================================ */
#define GDMA_DMA_NEXT_WR_BD_ADDR_STAT_NEXT_BD_WR_ADDR_Pos (0UL)     /*!< NEXT_BD_WR_ADDR (Bit 0)                               */
#define GDMA_DMA_NEXT_WR_BD_ADDR_STAT_NEXT_BD_WR_ADDR_Msk (0xffffffffUL) /*!< NEXT_BD_WR_ADDR (Bitfield-Mask: 0xffffffff)      */
/* ================================================  DMA_START_WR_ADDR_STAT  ================================================= */
#define GDMA_DMA_START_WR_ADDR_STAT_START_WR_ADDR_Pos (0UL)         /*!< START_WR_ADDR (Bit 0)                                 */
#define GDMA_DMA_START_WR_ADDR_STAT_START_WR_ADDR_Msk (0xffffffffUL) /*!< START_WR_ADDR (Bitfield-Mask: 0xffffffff)            */
/* =================================================  DMA_ALIGN_F2AL_AVAIL  ================================================== */
#define GDMA_DMA_ALIGN_F2AL_AVAIL_DATA_Pos (0UL)                    /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_ALIGN_F2AL_AVAIL_DATA_Msk (0x1ffUL)                /*!< DATA (Bitfield-Mask: 0x1ff)                           */
/* =================================================  DMA_ALIGN_AL2F_AVAIL  ================================================== */
#define GDMA_DMA_ALIGN_AL2F_AVAIL_DATA_Pos (0UL)                    /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_ALIGN_AL2F_AVAIL_DATA_Msk (0x1ffUL)                /*!< DATA (Bitfield-Mask: 0x1ff)                           */
/* ==================================================  DMA_RD_BW_CTRL_STAT  ================================================== */
#define GDMA_DMA_RD_BW_CTRL_STAT_COUNTER_Pos (16UL)                 /*!< COUNTER (Bit 16)                                      */
#define GDMA_DMA_RD_BW_CTRL_STAT_COUNTER_Msk (0xffff0000UL)         /*!< COUNTER (Bitfield-Mask: 0xffff)                       */
#define GDMA_DMA_RD_BW_CTRL_STAT_LIMIT_Pos (0UL)                    /*!< LIMIT (Bit 0)                                         */
#define GDMA_DMA_RD_BW_CTRL_STAT_LIMIT_Msk (0xffffUL)               /*!< LIMIT (Bitfield-Mask: 0xffff)                         */
/* ==================================================  DMA_WR_BW_CTRL_STAT  ================================================== */
#define GDMA_DMA_WR_BW_CTRL_STAT_COUNTER_Pos (16UL)                 /*!< COUNTER (Bit 16)                                      */
#define GDMA_DMA_WR_BW_CTRL_STAT_COUNTER_Msk (0xffff0000UL)         /*!< COUNTER (Bitfield-Mask: 0xffff)                       */
#define GDMA_DMA_WR_BW_CTRL_STAT_LIMIT_Pos (0UL)                    /*!< LIMIT (Bit 0)                                         */
#define GDMA_DMA_WR_BW_CTRL_STAT_LIMIT_Msk (0xffffUL)               /*!< LIMIT (Bitfield-Mask: 0xffff)                         */
/* ==================================================  DMA_RD_BW_CTRL_INT  =================================================== */
#define GDMA_DMA_RD_BW_CTRL_INT_WAIT_FOR_FIFO_Pos (0UL)             /*!< WAIT_FOR_FIFO (Bit 0)                                 */
#define GDMA_DMA_RD_BW_CTRL_INT_WAIT_FOR_FIFO_Msk (0x1UL)           /*!< WAIT_FOR_FIFO (Bitfield-Mask: 0x01)                   */
#define GDMA_DMA_RD_BW_CTRL_INT_LIMIT_Pos (1UL)                     /*!< LIMIT (Bit 1)                                         */
#define GDMA_DMA_RD_BW_CTRL_INT_LIMIT_Msk (0x2UL)                   /*!< LIMIT (Bitfield-Mask: 0x01)                           */
/* ==================================================  DMA_WR_BW_CTRL_INT  =================================================== */
#define GDMA_DMA_WR_BW_CTRL_INT_WAIT_FOR_DATA_Pos (0UL)             /*!< WAIT_FOR_DATA (Bit 0)                                 */
#define GDMA_DMA_WR_BW_CTRL_INT_WAIT_FOR_DATA_Msk (0x1UL)           /*!< WAIT_FOR_DATA (Bitfield-Mask: 0x01)                   */
#define GDMA_DMA_WR_BW_CTRL_INT_LIMIT_Pos (1UL)                     /*!< LIMIT (Bit 1)                                         */
#define GDMA_DMA_WR_BW_CTRL_INT_LIMIT_Msk (0x2UL)                   /*!< LIMIT (Bitfield-Mask: 0x01)                           */
/* =================================================  DMA_CMD_RD_ADDR_STAT  ================================================== */
#define GDMA_DMA_CMD_RD_ADDR_STAT_DATA_Pos (0UL)                    /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CMD_RD_ADDR_STAT_DATA_Msk (0xffffffffUL)           /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* =================================================  DMA_CMD_WR_ADDR_STAT  ================================================== */
#define GDMA_DMA_CMD_WR_ADDR_STAT_DATA_Pos (0UL)                    /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CMD_WR_ADDR_STAT_DATA_Msk (0xffffffffUL)           /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* =================================================  DMA_CMD_CMD_LEN_STAT  ================================================== */
#define GDMA_DMA_CMD_CMD_LEN_STAT_CMD_ID_Pos (24UL)                 /*!< CMD_ID (Bit 24)                                       */
#define GDMA_DMA_CMD_CMD_LEN_STAT_CMD_ID_Msk (0xff000000UL)         /*!< CMD_ID (Bitfield-Mask: 0xff)                          */
#define GDMA_DMA_CMD_CMD_LEN_STAT_LENGTH_Pos (0UL)                  /*!< LENGTH (Bit 0)                                        */
#define GDMA_DMA_CMD_CMD_LEN_STAT_LENGTH_Msk (0xffffffUL)           /*!< LENGTH (Bitfield-Mask: 0xffffff)                      */
/* ===================================================  DMA_CMD_CTRL_STAT  =================================================== */
#define GDMA_DMA_CMD_CTRL_STAT_DATA_Pos   (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CMD_CTRL_STAT_DATA_Msk   (0xffffffffUL)            /*!< DATA (Bitfield-Mask: 0xffffffff)                      */
/* ======================================================  DMA_CH0_SEL  ====================================================== */
#define GDMA_DMA_CH0_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH0_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH1_SEL  ====================================================== */
#define GDMA_DMA_CH1_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH1_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH2_SEL  ====================================================== */
#define GDMA_DMA_CH2_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH2_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH3_SEL  ====================================================== */
#define GDMA_DMA_CH3_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH3_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH4_SEL  ====================================================== */
#define GDMA_DMA_CH4_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH4_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH5_SEL  ====================================================== */
#define GDMA_DMA_CH5_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH5_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH6_SEL  ====================================================== */
#define GDMA_DMA_CH6_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH6_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* ======================================================  DMA_CH7_SEL  ====================================================== */
#define GDMA_DMA_CH7_SEL_DATA_Pos         (0UL)                     /*!< DATA (Bit 0)                                          */
#define GDMA_DMA_CH7_SEL_DATA_Msk         (0xfUL)                   /*!< DATA (Bitfield-Mask: 0x0f)                            */
/* =================================================  DMA_ENDLESS_TRANS_EN  ================================================== */
#define GDMA_DMA_ENDLESS_TRANS_EN_ENDLESS_WR_TRANS_EN_Pos (1UL)     /*!< ENDLESS_WR_TRANS_EN (Bit 1)                           */
#define GDMA_DMA_ENDLESS_TRANS_EN_ENDLESS_WR_TRANS_EN_Msk (0x2UL)   /*!< ENDLESS_WR_TRANS_EN (Bitfield-Mask: 0x01)             */
#define GDMA_DMA_ENDLESS_TRANS_EN_ENDLESS_RD_TRANS_EN_Pos (0UL)     /*!< ENDLESS_RD_TRANS_EN (Bit 0)                           */
#define GDMA_DMA_ENDLESS_TRANS_EN_ENDLESS_RD_TRANS_EN_Msk (0x1UL)   /*!< ENDLESS_RD_TRANS_EN (Bitfield-Mask: 0x01)             */
/* =============================================  DMA_ENDLESS_TRANS_START_ADDR  ============================================== */
#define GDMA_DMA_ENDLESS_TRANS_START_ADDR_ENDLESS_TRANS_START_ADDR_Pos (0UL) /*!< ENDLESS_TRANS_START_ADDR (Bit 0)             */
#define GDMA_DMA_ENDLESS_TRANS_START_ADDR_ENDLESS_TRANS_START_ADDR_Msk (0xffffffffUL) /*!< ENDLESS_TRANS_START_ADDR (Bitfield-Mask: 0xffffffff) */
/* ==============================================  DMA_ENDLESS_TRANS_END_ADDR  =============================================== */
#define GDMA_DMA_ENDLESS_TRANS_END_ADDR_ENDLESS_TRANS_END_ADDR_Pos (0UL) /*!< ENDLESS_TRANS_END_ADDR (Bit 0)                   */
#define GDMA_DMA_ENDLESS_TRANS_END_ADDR_ENDLESS_TRANS_END_ADDR_Msk (0xffffffffUL) /*!< ENDLESS_TRANS_END_ADDR (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                         UARTF_CFG                                         ================ */
/* =========================================================================================================================== */

/* =======================================================  OCPM_CFG  ======================================================== */
#define UARTF0_CFG_OCPM_CFG_MOSI_BIG_ENDIAN_Pos (29UL)              /*!< MOSI_BIG_ENDIAN (Bit 29)                              */
#define UARTF0_CFG_OCPM_CFG_MOSI_BIG_ENDIAN_Msk (0x20000000UL)      /*!< MOSI_BIG_ENDIAN (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_OCPM_CFG_MISO_BIG_ENDIAN_Pos (28UL)              /*!< MISO_BIG_ENDIAN (Bit 28)                              */
#define UARTF0_CFG_OCPM_CFG_MISO_BIG_ENDIAN_Msk (0x10000000UL)      /*!< MISO_BIG_ENDIAN (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_OCPM_CFG_OCP_BRST_ALIGN_Pos (24UL)               /*!< OCP_BRST_ALIGN (Bit 24)                               */
#define UARTF0_CFG_OCPM_CFG_OCP_BRST_ALIGN_Msk (0x1000000UL)        /*!< OCP_BRST_ALIGN (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_CFG_RD_FIFO_THRES_Pos (20UL)                /*!< RD_FIFO_THRES (Bit 20)                                */
#define UARTF0_CFG_OCPM_CFG_RD_FIFO_THRES_Msk (0xf00000UL)          /*!< RD_FIFO_THRES (Bitfield-Mask: 0x0f)                   */
#define UARTF0_CFG_OCPM_CFG_THRES_RD_SW_BYPASS_Pos (16UL)           /*!< THRES_RD_SW_BYPASS (Bit 16)                           */
#define UARTF0_CFG_OCPM_CFG_THRES_RD_SW_BYPASS_Msk (0x10000UL)      /*!< THRES_RD_SW_BYPASS (Bitfield-Mask: 0x01)              */
#define UARTF0_CFG_OCPM_CFG_RD_FIFO_THRES_VALUE_Pos (12UL)          /*!< RD_FIFO_THRES_VALUE (Bit 12)                          */
#define UARTF0_CFG_OCPM_CFG_RD_FIFO_THRES_VALUE_Msk (0xf000UL)      /*!< RD_FIFO_THRES_VALUE (Bitfield-Mask: 0x0f)             */
#define UARTF0_CFG_OCPM_CFG_WR_FIFO_THRES_Pos (8UL)                 /*!< WR_FIFO_THRES (Bit 8)                                 */
#define UARTF0_CFG_OCPM_CFG_WR_FIFO_THRES_Msk (0xf00UL)             /*!< WR_FIFO_THRES (Bitfield-Mask: 0x0f)                   */
#define UARTF0_CFG_OCPM_CFG_THRES_WR_SW_BYPASS_Pos (4UL)            /*!< THRES_WR_SW_BYPASS (Bit 4)                            */
#define UARTF0_CFG_OCPM_CFG_THRES_WR_SW_BYPASS_Msk (0x10UL)         /*!< THRES_WR_SW_BYPASS (Bitfield-Mask: 0x01)              */
#define UARTF0_CFG_OCPM_CFG_WR_FIFO_THRES_VALUE_Pos (0UL)           /*!< WR_FIFO_THRES_VALUE (Bit 0)                           */
#define UARTF0_CFG_OCPM_CFG_WR_FIFO_THRES_VALUE_Msk (0xfUL)         /*!< WR_FIFO_THRES_VALUE (Bitfield-Mask: 0x0f)             */
/* =======================================================  OCPM_INIT  ======================================================= */
#define UARTF0_CFG_OCPM_INIT_RESET_RD_BUFF_Pos (24UL)               /*!< RESET_RD_BUFF (Bit 24)                                */
#define UARTF0_CFG_OCPM_INIT_RESET_RD_BUFF_Msk (0x1000000UL)        /*!< RESET_RD_BUFF (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_OCPM_INIT_RESET_WR_BUFF_Pos (16UL)               /*!< RESET_WR_BUFF (Bit 16)                                */
#define UARTF0_CFG_OCPM_INIT_RESET_WR_BUFF_Msk (0x10000UL)          /*!< RESET_WR_BUFF (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_OCPM_INIT_RD_BD_LIST_ADDR_FLUSH_Pos (11UL)       /*!< RD_BD_LIST_ADDR_FLUSH (Bit 11)                        */
#define UARTF0_CFG_OCPM_INIT_RD_BD_LIST_ADDR_FLUSH_Msk (0x800UL)    /*!< RD_BD_LIST_ADDR_FLUSH (Bitfield-Mask: 0x01)           */
#define UARTF0_CFG_OCPM_INIT_RD_BD_LIST_SIZE_FLUSH_Pos (10UL)       /*!< RD_BD_LIST_SIZE_FLUSH (Bit 10)                        */
#define UARTF0_CFG_OCPM_INIT_RD_BD_LIST_SIZE_FLUSH_Msk (0x400UL)    /*!< RD_BD_LIST_SIZE_FLUSH (Bitfield-Mask: 0x01)           */
#define UARTF0_CFG_OCPM_INIT_WR_BD_LIST_ADDR_FLUSH_Pos (9UL)        /*!< WR_BD_LIST_ADDR_FLUSH (Bit 9)                         */
#define UARTF0_CFG_OCPM_INIT_WR_BD_LIST_ADDR_FLUSH_Msk (0x200UL)    /*!< WR_BD_LIST_ADDR_FLUSH (Bitfield-Mask: 0x01)           */
#define UARTF0_CFG_OCPM_INIT_WR_BD_LIST_SIZE_FLUSH_Pos (8UL)        /*!< WR_BD_LIST_SIZE_FLUSH (Bit 8)                         */
#define UARTF0_CFG_OCPM_INIT_WR_BD_LIST_SIZE_FLUSH_Msk (0x100UL)    /*!< WR_BD_LIST_SIZE_FLUSH (Bitfield-Mask: 0x01)           */
#define UARTF0_CFG_OCPM_INIT_MISO_RESET_FLUSH_Pos (1UL)             /*!< MISO_RESET_FLUSH (Bit 1)                              */
#define UARTF0_CFG_OCPM_INIT_MISO_RESET_FLUSH_Msk (0x2UL)           /*!< MISO_RESET_FLUSH (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_OCPM_INIT_MOSI_RESET_FLUSH_Pos (0UL)             /*!< MOSI_RESET_FLUSH (Bit 0)                              */
#define UARTF0_CFG_OCPM_INIT_MOSI_RESET_FLUSH_Msk (0x1UL)           /*!< MOSI_RESET_FLUSH (Bitfield-Mask: 0x01)                */
/* =====================================================  OCPM_RD_ADDR  ====================================================== */
#define UARTF0_CFG_OCPM_RD_ADDR_RD_BUFF_START_ADDR_Pos (0UL)        /*!< RD_BUFF_START_ADDR (Bit 0)                            */
#define UARTF0_CFG_OCPM_RD_ADDR_RD_BUFF_START_ADDR_Msk (0x1fffffffUL) /*!< RD_BUFF_START_ADDR (Bitfield-Mask: 0x1fffffff)      */
/* =====================================================  OCPM_WR_ADDR  ====================================================== */
#define UARTF0_CFG_OCPM_WR_ADDR_WR_BUFF_START_ADDR_Pos (0UL)        /*!< WR_BUFF_START_ADDR (Bit 0)                            */
#define UARTF0_CFG_OCPM_WR_ADDR_WR_BUFF_START_ADDR_Msk (0x1fffffffUL) /*!< WR_BUFF_START_ADDR (Bitfield-Mask: 0x1fffffff)      */
/* =====================================================  OCPM_LEN_CFG  ====================================================== */
#define UARTF0_CFG_OCPM_LEN_CFG_RD_BUFF_LEN_Pos (16UL)              /*!< RD_BUFF_LEN (Bit 16)                                  */
#define UARTF0_CFG_OCPM_LEN_CFG_RD_BUFF_LEN_Msk (0xffff0000UL)      /*!< RD_BUFF_LEN (Bitfield-Mask: 0xffff)                   */
#define UARTF0_CFG_OCPM_LEN_CFG_WR_BUFF_LEN_Pos (0UL)               /*!< WR_BUFF_LEN (Bit 0)                                   */
#define UARTF0_CFG_OCPM_LEN_CFG_WR_BUFF_LEN_Msk (0xffffUL)          /*!< WR_BUFF_LEN (Bitfield-Mask: 0xffff)                   */
/* ======================================================  OCPM_RD_INT  ====================================================== */
#define UARTF0_CFG_OCPM_RD_INT_WR_BD_ADDR_INT_Pos (3UL)             /*!< WR_BD_ADDR_INT (Bit 3)                                */
#define UARTF0_CFG_OCPM_RD_INT_WR_BD_ADDR_INT_Msk (0x8UL)           /*!< WR_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_INT_WR_BD_SIZE_INT_Pos (2UL)             /*!< WR_BD_SIZE_INT (Bit 2)                                */
#define UARTF0_CFG_OCPM_RD_INT_WR_BD_SIZE_INT_Msk (0x4UL)           /*!< WR_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_INT_RD_BD_ADDR_INT_Pos (1UL)             /*!< RD_BD_ADDR_INT (Bit 1)                                */
#define UARTF0_CFG_OCPM_RD_INT_RD_BD_ADDR_INT_Msk (0x2UL)           /*!< RD_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_INT_RD_BD_SIZE_INT_Pos (0UL)             /*!< RD_BD_SIZE_INT (Bit 0)                                */
#define UARTF0_CFG_OCPM_RD_INT_RD_BD_SIZE_INT_Msk (0x1UL)           /*!< RD_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
/* ====================================================  OCPM_RD_CLR_INT  ==================================================== */
#define UARTF0_CFG_OCPM_RD_CLR_INT_WR_BD_ADDR_INT_Pos (3UL)         /*!< WR_BD_ADDR_INT (Bit 3)                                */
#define UARTF0_CFG_OCPM_RD_CLR_INT_WR_BD_ADDR_INT_Msk (0x8UL)       /*!< WR_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_CLR_INT_WR_BD_SIZE_INT_Pos (2UL)         /*!< WR_BD_SIZE_INT (Bit 2)                                */
#define UARTF0_CFG_OCPM_RD_CLR_INT_WR_BD_SIZE_INT_Msk (0x4UL)       /*!< WR_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_CLR_INT_RD_BD_ADDR_INT_Pos (1UL)         /*!< RD_BD_ADDR_INT (Bit 1)                                */
#define UARTF0_CFG_OCPM_RD_CLR_INT_RD_BD_ADDR_INT_Msk (0x2UL)       /*!< RD_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_RD_CLR_INT_RD_BD_SIZE_INT_Pos (0UL)         /*!< RD_BD_SIZE_INT (Bit 0)                                */
#define UARTF0_CFG_OCPM_RD_CLR_INT_RD_BD_SIZE_INT_Msk (0x1UL)       /*!< RD_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
/* =====================================================  OCPM_MASK_INT  ===================================================== */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_WR_BD_ADDR_INT_Pos (3UL)      /*!< MASK_WR_BD_ADDR_INT (Bit 3)                           */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_WR_BD_ADDR_INT_Msk (0x8UL)    /*!< MASK_WR_BD_ADDR_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_WR_BD_SIZE_INT_Pos (2UL)      /*!< MASK_WR_BD_SIZE_INT (Bit 2)                           */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_WR_BD_SIZE_INT_Msk (0x4UL)    /*!< MASK_WR_BD_SIZE_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_RD_BD_ADDR_INT_Pos (1UL)      /*!< MASK_RD_BD_ADDR_INT (Bit 1)                           */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_RD_BD_ADDR_INT_Msk (0x2UL)    /*!< MASK_RD_BD_ADDR_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_RD_BD_SIZE_INT_Pos (0UL)      /*!< MASK_RD_BD_SIZE_INT (Bit 0)                           */
#define UARTF0_CFG_OCPM_MASK_INT_MASK_RD_BD_SIZE_INT_Msk (0x1UL)    /*!< MASK_RD_BD_SIZE_INT (Bitfield-Mask: 0x01)             */
/* ======================================================  OCPM_INT_EN  ====================================================== */
#define UARTF0_CFG_OCPM_INT_EN_WR_BD_ADDR_INT_EN_Pos (3UL)          /*!< WR_BD_ADDR_INT_EN (Bit 3)                             */
#define UARTF0_CFG_OCPM_INT_EN_WR_BD_ADDR_INT_EN_Msk (0x8UL)        /*!< WR_BD_ADDR_INT_EN (Bitfield-Mask: 0x01)               */
#define UARTF0_CFG_OCPM_INT_EN_WR_BD_SIZE_INT_EN_Pos (2UL)          /*!< WR_BD_SIZE_INT_EN (Bit 2)                             */
#define UARTF0_CFG_OCPM_INT_EN_WR_BD_SIZE_INT_EN_Msk (0x4UL)        /*!< WR_BD_SIZE_INT_EN (Bitfield-Mask: 0x01)               */
#define UARTF0_CFG_OCPM_INT_EN_RD_BD_ADDR_INT_EN_Pos (1UL)          /*!< RD_BD_ADDR_INT_EN (Bit 1)                             */
#define UARTF0_CFG_OCPM_INT_EN_RD_BD_ADDR_INT_EN_Msk (0x2UL)        /*!< RD_BD_ADDR_INT_EN (Bitfield-Mask: 0x01)               */
#define UARTF0_CFG_OCPM_INT_EN_RD_BD_SIZE_INT_EN_Pos (0UL)          /*!< RD_BD_SIZE_INT_EN (Bit 0)                             */
#define UARTF0_CFG_OCPM_INT_EN_RD_BD_SIZE_INT_EN_Msk (0x1UL)        /*!< RD_BD_SIZE_INT_EN (Bitfield-Mask: 0x01)               */
/* ===================================================  OCPM_BUFF_ACTIVE  ==================================================== */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_WR_BUFF_CYCLIC_EN_Pos (24UL)    /*!< WR_BUFF_CYCLIC_EN (Bit 24)                            */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_WR_BUFF_CYCLIC_EN_Msk (0x1000000UL) /*!< WR_BUFF_CYCLIC_EN (Bitfield-Mask: 0x01)           */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_RD_BUFF_CYCLIC_EN_Pos (16UL)    /*!< RD_BUFF_CYCLIC_EN (Bit 16)                            */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_RD_BUFF_CYCLIC_EN_Msk (0x10000UL) /*!< RD_BUFF_CYCLIC_EN (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_RD_BUFF_ACTIVE_Pos (8UL)        /*!< RD_BUFF_ACTIVE (Bit 8)                                */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_RD_BUFF_ACTIVE_Msk (0x100UL)    /*!< RD_BUFF_ACTIVE (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_WR_BUFF_ACTIVE_Pos (0UL)        /*!< WR_BUFF_ACTIVE (Bit 0)                                */
#define UARTF0_CFG_OCPM_BUFF_ACTIVE_WR_BUFF_ACTIVE_Msk (0x1UL)      /*!< WR_BUFF_ACTIVE (Bitfield-Mask: 0x01)                  */
/* ====================================================  OCPM_WR_BD_ADDR  ==================================================== */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_WR_BD_ADDR_Pos (0UL)             /*!< WR_BD_ADDR (Bit 0)                                    */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_WR_BD_ADDR_Msk (0xffffffffUL)    /*!< WR_BD_ADDR (Bitfield-Mask: 0xffffffff)                */
/* ====================================================  OCPM_WR_BD_SIZE  ==================================================== */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_WR_BD_SIZE_Pos (0UL)             /*!< WR_BD_SIZE (Bit 0)                                    */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_WR_BD_SIZE_Msk (0xffffUL)        /*!< WR_BD_SIZE (Bitfield-Mask: 0xffff)                    */
/* ====================================================  OCPM_RD_BD_ADDR  ==================================================== */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_RD_BD_ADDR_Pos (0UL)             /*!< RD_BD_ADDR (Bit 0)                                    */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_RD_BD_ADDR_Msk (0xffffffffUL)    /*!< RD_BD_ADDR (Bitfield-Mask: 0xffffffff)                */
/* ====================================================  OCPM_RD_BD_SIZE  ==================================================== */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_RD_BD_SIZE_Pos (0UL)             /*!< RD_BD_SIZE (Bit 0)                                    */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_RD_BD_SIZE_Msk (0xffffUL)        /*!< RD_BD_SIZE (Bitfield-Mask: 0xffff)                    */
/* =================================================  OCPM_WR_BD_ADDR_STATE  ================================================= */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_FULL_Pos (25UL)       /*!< FIFO_FULL (Bit 25)                                    */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                      */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_EMPTY_Pos (24UL)      /*!< FIFO_EMPTY (Bit 24)                                   */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_WR_PTR_Pos (16UL)          /*!< WR_PTR (Bit 16)                                       */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_WR_PTR_Msk (0xf0000UL)     /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_RD_PTR_Pos (8UL)           /*!< RD_PTR (Bit 8)                                        */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_RD_PTR_Msk (0xf00UL)       /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_STATUS_Pos (0UL)      /*!< FIFO_STATUS (Bit 0)                                   */
#define UARTF0_CFG_OCPM_WR_BD_ADDR_STATE_FIFO_STATUS_Msk (0x1fUL)   /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_WR_BD_SIZE_STATE  ================================================= */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_FULL_Pos (25UL)       /*!< FIFO_FULL (Bit 25)                                    */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                      */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_EMPTY_Pos (24UL)      /*!< FIFO_EMPTY (Bit 24)                                   */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_WR_PTR_Pos (16UL)          /*!< WR_PTR (Bit 16)                                       */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_WR_PTR_Msk (0xf0000UL)     /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_RD_PTR_Pos (8UL)           /*!< RD_PTR (Bit 8)                                        */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_RD_PTR_Msk (0xf00UL)       /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_STATUS_Pos (0UL)      /*!< FIFO_STATUS (Bit 0)                                   */
#define UARTF0_CFG_OCPM_WR_BD_SIZE_STATE_FIFO_STATUS_Msk (0x1fUL)   /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_RD_BD_ADDR_STATE  ================================================= */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_FULL_Pos (25UL)       /*!< FIFO_FULL (Bit 25)                                    */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                      */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_EMPTY_Pos (24UL)      /*!< FIFO_EMPTY (Bit 24)                                   */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_WR_PTR_Pos (16UL)          /*!< WR_PTR (Bit 16)                                       */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_WR_PTR_Msk (0xf0000UL)     /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_RD_PTR_Pos (8UL)           /*!< RD_PTR (Bit 8)                                        */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_RD_PTR_Msk (0xf00UL)       /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_STATUS_Pos (0UL)      /*!< FIFO_STATUS (Bit 0)                                   */
#define UARTF0_CFG_OCPM_RD_BD_ADDR_STATE_FIFO_STATUS_Msk (0x1fUL)   /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_RD_BD_SIZE_STATE  ================================================= */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_FULL_Pos (25UL)       /*!< FIFO_FULL (Bit 25)                                    */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                      */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_EMPTY_Pos (24UL)      /*!< FIFO_EMPTY (Bit 24)                                   */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_WR_PTR_Pos (16UL)          /*!< WR_PTR (Bit 16)                                       */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_WR_PTR_Msk (0xf0000UL)     /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_RD_PTR_Pos (8UL)           /*!< RD_PTR (Bit 8)                                        */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_RD_PTR_Msk (0xf00UL)       /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_STATUS_Pos (0UL)      /*!< FIFO_STATUS (Bit 0)                                   */
#define UARTF0_CFG_OCPM_RD_BD_SIZE_STATE_FIFO_STATUS_Msk (0x1fUL)   /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* ===================================================  OCPM_BD_CFG_THRES  =================================================== */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_WR_BD_ADDR_THRES_Pos (24UL)    /*!< WR_BD_ADDR_THRES (Bit 24)                             */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_WR_BD_ADDR_THRES_Msk (0x1f000000UL) /*!< WR_BD_ADDR_THRES (Bitfield-Mask: 0x1f)           */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_WR_BD_SIZE_THRES_Pos (16UL)    /*!< WR_BD_SIZE_THRES (Bit 16)                             */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_WR_BD_SIZE_THRES_Msk (0x1f0000UL) /*!< WR_BD_SIZE_THRES (Bitfield-Mask: 0x1f)             */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_RD_BD_ADDR_THRES_Pos (8UL)     /*!< RD_BD_ADDR_THRES (Bit 8)                              */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_RD_BD_ADDR_THRES_Msk (0x1f00UL) /*!< RD_BD_ADDR_THRES (Bitfield-Mask: 0x1f)               */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_RD_BD_SIZE_THRES_Pos (0UL)     /*!< RD_BD_SIZE_THRES (Bit 0)                              */
#define UARTF0_CFG_OCPM_BD_CFG_THRES_RD_BD_SIZE_THRES_Msk (0x1fUL)  /*!< RD_BD_SIZE_THRES (Bitfield-Mask: 0x1f)                */
/* ==================================================  OCPM_OCP_LEN_STATUS  ================================================== */
#define UARTF0_CFG_OCPM_OCP_LEN_STATUS_OCP_WR_LEN_CNT_Pos (16UL)    /*!< OCP_WR_LEN_CNT (Bit 16)                               */
#define UARTF0_CFG_OCPM_OCP_LEN_STATUS_OCP_WR_LEN_CNT_Msk (0xffff0000UL) /*!< OCP_WR_LEN_CNT (Bitfield-Mask: 0xffff)           */
#define UARTF0_CFG_OCPM_OCP_LEN_STATUS_OCP_RD_LEN_CNT_Pos (0UL)     /*!< OCP_RD_LEN_CNT (Bit 0)                                */
#define UARTF0_CFG_OCPM_OCP_LEN_STATUS_OCP_RD_LEN_CNT_Msk (0xffffUL) /*!< OCP_RD_LEN_CNT (Bitfield-Mask: 0xffff)               */
/* =================================================  OCPM_BUF_FIFO_STATUS  ================================================== */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_WR_PTR_Pos (28UL) /*!< OCPM_MISO_FIFO_WR_PTR (Bit 28)                   */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_WR_PTR_Msk (0x70000000UL) /*!< OCPM_MISO_FIFO_WR_PTR (Bitfield-Mask: 0x07) */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_RD_PTR_Pos (24UL) /*!< OCPM_MISO_FIFO_RD_PTR (Bit 24)                   */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_RD_PTR_Msk (0x7000000UL) /*!< OCPM_MISO_FIFO_RD_PTR (Bitfield-Mask: 0x07) */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_STATUS_Pos (16UL) /*!< OCPM_MISO_FIFO_STATUS (Bit 16)                   */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_STATUS_Msk (0xf0000UL) /*!< OCPM_MISO_FIFO_STATUS (Bitfield-Mask: 0x0f) */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_WR_PTR_Pos (12UL) /*!< OCPM_MOSI_FIFO_WR_PTR (Bit 12)                   */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_WR_PTR_Msk (0x7000UL) /*!< OCPM_MOSI_FIFO_WR_PTR (Bitfield-Mask: 0x07)  */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_RD_PTR_Pos (8UL) /*!< OCPM_MOSI_FIFO_RD_PTR (Bit 8)                     */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_RD_PTR_Msk (0x700UL) /*!< OCPM_MOSI_FIFO_RD_PTR (Bitfield-Mask: 0x07)   */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_STATUS_Pos (0UL) /*!< OCPM_MOSI_FIFO_STATUS (Bit 0)                     */
#define UARTF0_CFG_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_STATUS_Msk (0xfUL) /*!< OCPM_MOSI_FIFO_STATUS (Bitfield-Mask: 0x0f)     */
/* ==========================================================  CFG  ========================================================== */
#define UARTF0_CFG_CFG_BYTE_RESOLUTION_Pos (5UL)                    /*!< BYTE_RESOLUTION (Bit 5)                               */
#define UARTF0_CFG_CFG_BYTE_RESOLUTION_Msk (0x20UL)                 /*!< BYTE_RESOLUTION (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_CFG_UARTF_RX_ENDIAN_Pos (4UL)                    /*!< UARTF_RX_ENDIAN (Bit 4)                               */
#define UARTF0_CFG_CFG_UARTF_RX_ENDIAN_Msk (0x10UL)                 /*!< UARTF_RX_ENDIAN (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_CFG_UARTF_TX_ENDIAN_Pos (3UL)                    /*!< UARTF_TX_ENDIAN (Bit 3)                               */
#define UARTF0_CFG_CFG_UARTF_TX_ENDIAN_Msk (0x8UL)                  /*!< UARTF_TX_ENDIAN (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_CFG_UARTF_FLUSH_Pos    (2UL)                     /*!< UARTF_FLUSH (Bit 2)                                   */
#define UARTF0_CFG_CFG_UARTF_FLUSH_Msk    (0x4UL)                   /*!< UARTF_FLUSH (Bitfield-Mask: 0x01)                     */
#define UARTF0_CFG_CFG_UARTF_HALT_Pos     (1UL)                     /*!< UARTF_HALT (Bit 1)                                    */
#define UARTF0_CFG_CFG_UARTF_HALT_Msk     (0x2UL)                   /*!< UARTF_HALT (Bitfield-Mask: 0x01)                      */
#define UARTF0_CFG_CFG_APB_MUX_CTRL_Pos   (0UL)                     /*!< APB_MUX_CTRL (Bit 0)                                  */
#define UARTF0_CFG_CFG_APB_MUX_CTRL_Msk   (0x1UL)                   /*!< APB_MUX_CTRL (Bitfield-Mask: 0x01)                    */
/* ===================================================  UARTF_RXFIFO_ADDR  =================================================== */
#define UARTF0_CFG_UARTF_RXFIFO_ADDR_RXFIFO_ADDR_Pos (0UL)          /*!< RXFIFO_ADDR (Bit 0)                                   */
#define UARTF0_CFG_UARTF_RXFIFO_ADDR_RXFIFO_ADDR_Msk (0x3ffUL)      /*!< RXFIFO_ADDR (Bitfield-Mask: 0x3ff)                    */
/* ===================================================  UARTF_TXFIFO_ADDR  =================================================== */
#define UARTF0_CFG_UARTF_TXFIFO_ADDR_TXFIFO_ADDR_Pos (0UL)          /*!< TXFIFO_ADDR (Bit 0)                                   */
#define UARTF0_CFG_UARTF_TXFIFO_ADDR_TXFIFO_ADDR_Msk (0x3ffUL)      /*!< TXFIFO_ADDR (Bitfield-Mask: 0x3ff)                    */
/* =====================================================  UARTF_STATUS  ====================================================== */
#define UARTF0_CFG_UARTF_STATUS_UARTF_RXD_Pos (16UL)                /*!< UARTF_RXD (Bit 16)                                    */
#define UARTF0_CFG_UARTF_STATUS_UARTF_RXD_Msk (0x10000UL)           /*!< UARTF_RXD (Bitfield-Mask: 0x01)                       */
#define UARTF0_CFG_UARTF_STATUS_RD_BUFFER_ACTIVE_Pos (12UL)         /*!< RD_BUFFER_ACTIVE (Bit 12)                             */
#define UARTF0_CFG_UARTF_STATUS_RD_BUFFER_ACTIVE_Msk (0x1000UL)     /*!< RD_BUFFER_ACTIVE (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_UARTF_STATUS_WR_BUFFER_ACTIVE_Pos (11UL)         /*!< WR_BUFFER_ACTIVE (Bit 11)                             */
#define UARTF0_CFG_UARTF_STATUS_WR_BUFFER_ACTIVE_Msk (0x800UL)      /*!< WR_BUFFER_ACTIVE (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_UARTF_STATUS_OCPM_ERR_INT_Pos (10UL)             /*!< OCPM_ERR_INT (Bit 10)                                 */
#define UARTF0_CFG_UARTF_STATUS_OCPM_ERR_INT_Msk (0x400UL)          /*!< OCPM_ERR_INT (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_UARTF_STATUS_OVERFLOW_ERR_INT_Pos (9UL)          /*!< OVERFLOW_ERR_INT (Bit 9)                              */
#define UARTF0_CFG_UARTF_STATUS_OVERFLOW_ERR_INT_Msk (0x200UL)      /*!< OVERFLOW_ERR_INT (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_UARTF_STATUS_PARITY_ERR_INT_Pos (8UL)            /*!< PARITY_ERR_INT (Bit 8)                                */
#define UARTF0_CFG_UARTF_STATUS_PARITY_ERR_INT_Msk (0x100UL)        /*!< PARITY_ERR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_UARTF_STATUS_FRAME_ERR_INT_Pos (7UL)             /*!< FRAME_ERR_INT (Bit 7)                                 */
#define UARTF0_CFG_UARTF_STATUS_FRAME_ERR_INT_Msk (0x80UL)          /*!< FRAME_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_UARTF_STATUS_BREAK_ERR_INT_Pos (6UL)             /*!< BREAK_ERR_INT (Bit 6)                                 */
#define UARTF0_CFG_UARTF_STATUS_BREAK_ERR_INT_Msk (0x40UL)          /*!< BREAK_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_UARTF_STATUS_OVERRUN_ERR_INT_Pos (5UL)           /*!< OVERRUN_ERR_INT (Bit 5)                               */
#define UARTF0_CFG_UARTF_STATUS_OVERRUN_ERR_INT_Msk (0x20UL)        /*!< OVERRUN_ERR_INT (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_UARTF_STATUS_MISO_PACKET_CNT_INT_Pos (4UL)       /*!< MISO_PACKET_CNT_INT (Bit 4)                           */
#define UARTF0_CFG_UARTF_STATUS_MISO_PACKET_CNT_INT_Msk (0x10UL)    /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_UARTF_STATUS_MOSI_PACKET_CNT_INT_Pos (3UL)       /*!< MOSI_PACKET_CNT_INT (Bit 3)                           */
#define UARTF0_CFG_UARTF_STATUS_MOSI_PACKET_CNT_INT_Msk (0x8UL)     /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_UARTF_STATUS_OCPM_FLOW_INT_Pos (2UL)             /*!< OCPM_FLOW_INT (Bit 2)                                 */
#define UARTF0_CFG_UARTF_STATUS_OCPM_FLOW_INT_Msk (0x4UL)           /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_UARTF_STATUS_FLOW_INT_Pos (1UL)                  /*!< FLOW_INT (Bit 1)                                      */
#define UARTF0_CFG_UARTF_STATUS_FLOW_INT_Msk (0x2UL)                /*!< FLOW_INT (Bitfield-Mask: 0x01)                        */
#define UARTF0_CFG_UARTF_STATUS_ERR_INT_Pos (0UL)                   /*!< ERR_INT (Bit 0)                                       */
#define UARTF0_CFG_UARTF_STATUS_ERR_INT_Msk (0x1UL)                 /*!< ERR_INT (Bitfield-Mask: 0x01)                         */
/* ==================================================  MOSI_PAC_AT_CNT_INC  ================================================== */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_INC_BD_CNT_INC_Pos (0UL)         /*!< BD_CNT_INC (Bit 0)                                    */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_INC_BD_CNT_INC_Msk (0xffffUL)    /*!< BD_CNT_INC (Bitfield-Mask: 0xffff)                    */
/* ==================================================  MOSI_PAC_AT_CNT_DEC  ================================================== */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_DEC_BD_CNT_DEC_Pos (0UL)         /*!< BD_CNT_DEC (Bit 0)                                    */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_DEC_BD_CNT_DEC_Msk (0xffffUL)    /*!< BD_CNT_DEC (Bitfield-Mask: 0xffff)                    */
/* =================================================  MOSI_PAC_AT_CNT_CTRL  ================================================== */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Pos (0UL)     /*!< BD_CNT_INT_EN (Bit 0)                                 */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Msk (0x1UL)   /*!< BD_CNT_INT_EN (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Pos (1UL)   /*!< BD_CNT_INT_MODE (Bit 1)                               */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Msk (0x6UL) /*!< BD_CNT_INT_MODE (Bitfield-Mask: 0x03)                 */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Pos (3UL)      /*!< BD_CNT_HW_EN (Bit 3)                                  */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Msk (0x8UL)    /*!< BD_CNT_HW_EN (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Pos (4UL)    /*!< BD_CNT_THRS_EN (Bit 4)                                */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Msk (0x10UL) /*!< BD_CNT_THRS_EN (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Pos (16UL) /*!< BD_CNT_THRS_VALUE (Bit 16)                           */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Msk (0xffff0000UL) /*!< BD_CNT_THRS_VALUE (Bitfield-Mask: 0xffff)    */
/* ====================================================  MOSI_PAC_AT_CNT  ==================================================== */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_BD_CNT_Pos (0UL)                 /*!< BD_CNT (Bit 0)                                        */
#define UARTF0_CFG_MOSI_PAC_AT_CNT_BD_CNT_Msk (0xffffUL)            /*!< BD_CNT (Bitfield-Mask: 0xffff)                        */
/* ==================================================  MISO_PAC_AT_CNT_INC  ================================================== */
#define UARTF0_CFG_MISO_PAC_AT_CNT_INC_BD_CNT_INC_Pos (0UL)         /*!< BD_CNT_INC (Bit 0)                                    */
#define UARTF0_CFG_MISO_PAC_AT_CNT_INC_BD_CNT_INC_Msk (0xffffUL)    /*!< BD_CNT_INC (Bitfield-Mask: 0xffff)                    */
/* ==================================================  MISO_PAC_AT_CNT_DEC  ================================================== */
#define UARTF0_CFG_MISO_PAC_AT_CNT_DEC_BD_CNT_DEC_Pos (0UL)         /*!< BD_CNT_DEC (Bit 0)                                    */
#define UARTF0_CFG_MISO_PAC_AT_CNT_DEC_BD_CNT_DEC_Msk (0xffffUL)    /*!< BD_CNT_DEC (Bitfield-Mask: 0xffff)                    */
/* =================================================  MISO_PAC_AT_CNT_CTRL  ================================================== */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Pos (0UL)     /*!< BD_CNT_INT_EN (Bit 0)                                 */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Msk (0x1UL)   /*!< BD_CNT_INT_EN (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Pos (1UL)   /*!< BD_CNT_INT_MODE (Bit 1)                               */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Msk (0x6UL) /*!< BD_CNT_INT_MODE (Bitfield-Mask: 0x03)                 */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Pos (3UL)      /*!< BD_CNT_HW_EN (Bit 3)                                  */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Msk (0x8UL)    /*!< BD_CNT_HW_EN (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Pos (4UL)    /*!< BD_CNT_THRS_EN (Bit 4)                                */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Msk (0x10UL) /*!< BD_CNT_THRS_EN (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Pos (16UL) /*!< BD_CNT_THRS_VALUE (Bit 16)                           */
#define UARTF0_CFG_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Msk (0xffff0000UL) /*!< BD_CNT_THRS_VALUE (Bitfield-Mask: 0xffff)    */
/* ====================================================  MISO_PAC_AT_CNT  ==================================================== */
#define UARTF0_CFG_MISO_PAC_AT_CNT_BD_CNT_Pos (0UL)                 /*!< BD_CNT (Bit 0)                                        */
#define UARTF0_CFG_MISO_PAC_AT_CNT_BD_CNT_Msk (0xffffUL)            /*!< BD_CNT (Bitfield-Mask: 0xffff)                        */
/* =======================================================  FLOW_INT  ======================================================== */
#define UARTF0_CFG_FLOW_INT_UARTINT_Pos   (3UL)                     /*!< UARTINT (Bit 3)                                       */
#define UARTF0_CFG_FLOW_INT_UARTINT_Msk   (0x8UL)                   /*!< UARTINT (Bitfield-Mask: 0x01)                         */
#define UARTF0_CFG_FLOW_INT_MISO_PACKET_CNT_INT_Pos (2UL)           /*!< MISO_PACKET_CNT_INT (Bit 2)                           */
#define UARTF0_CFG_FLOW_INT_MISO_PACKET_CNT_INT_Msk (0x4UL)         /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_FLOW_INT_MOSI_PACKET_CNT_INT_Pos (1UL)           /*!< MOSI_PACKET_CNT_INT (Bit 1)                           */
#define UARTF0_CFG_FLOW_INT_MOSI_PACKET_CNT_INT_Msk (0x2UL)         /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_FLOW_INT_OCPM_FLOW_INT_Pos (0UL)                 /*!< OCPM_FLOW_INT (Bit 0)                                 */
#define UARTF0_CFG_FLOW_INT_OCPM_FLOW_INT_Msk (0x1UL)               /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
/* =====================================================  CLR_FLOW_INT  ====================================================== */
#define UARTF0_CFG_CLR_FLOW_INT_UARTINT_Pos (3UL)                   /*!< UARTINT (Bit 3)                                       */
#define UARTF0_CFG_CLR_FLOW_INT_UARTINT_Msk (0x8UL)                 /*!< UARTINT (Bitfield-Mask: 0x01)                         */
#define UARTF0_CFG_CLR_FLOW_INT_MISO_PACKET_CNT_INT_Pos (2UL)       /*!< MISO_PACKET_CNT_INT (Bit 2)                           */
#define UARTF0_CFG_CLR_FLOW_INT_MISO_PACKET_CNT_INT_Msk (0x4UL)     /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_CLR_FLOW_INT_MOSI_PACKET_CNT_INT_Pos (1UL)       /*!< MOSI_PACKET_CNT_INT (Bit 1)                           */
#define UARTF0_CFG_CLR_FLOW_INT_MOSI_PACKET_CNT_INT_Msk (0x2UL)     /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_CLR_FLOW_INT_OCPM_FLOW_INT_Pos (0UL)             /*!< OCPM_FLOW_INT (Bit 0)                                 */
#define UARTF0_CFG_CLR_FLOW_INT_OCPM_FLOW_INT_Msk (0x1UL)           /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
/* =====================================================  MSK_FLOW_INT  ====================================================== */
#define UARTF0_CFG_MSK_FLOW_INT_UARTINT_Pos (3UL)                   /*!< UARTINT (Bit 3)                                       */
#define UARTF0_CFG_MSK_FLOW_INT_UARTINT_Msk (0x8UL)                 /*!< UARTINT (Bitfield-Mask: 0x01)                         */
#define UARTF0_CFG_MSK_FLOW_INT_MISO_PACKET_CNT_INT_Pos (2UL)       /*!< MISO_PACKET_CNT_INT (Bit 2)                           */
#define UARTF0_CFG_MSK_FLOW_INT_MISO_PACKET_CNT_INT_Msk (0x4UL)     /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_MSK_FLOW_INT_MOSI_PACKET_CNT_INT_Pos (1UL)       /*!< MOSI_PACKET_CNT_INT (Bit 1)                           */
#define UARTF0_CFG_MSK_FLOW_INT_MOSI_PACKET_CNT_INT_Msk (0x2UL)     /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_MSK_FLOW_INT_OCPM_FLOW_INT_Pos (0UL)             /*!< OCPM_FLOW_INT (Bit 0)                                 */
#define UARTF0_CFG_MSK_FLOW_INT_OCPM_FLOW_INT_Msk (0x1UL)           /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
/* ======================================================  EN_FLOW_INT  ====================================================== */
#define UARTF0_CFG_EN_FLOW_INT_UARTINT_Pos (3UL)                    /*!< UARTINT (Bit 3)                                       */
#define UARTF0_CFG_EN_FLOW_INT_UARTINT_Msk (0x8UL)                  /*!< UARTINT (Bitfield-Mask: 0x01)                         */
#define UARTF0_CFG_EN_FLOW_INT_MISO_PACKET_CNT_INT_Pos (2UL)        /*!< MISO_PACKET_CNT_INT (Bit 2)                           */
#define UARTF0_CFG_EN_FLOW_INT_MISO_PACKET_CNT_INT_Msk (0x4UL)      /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_EN_FLOW_INT_MOSI_PACKET_CNT_INT_Pos (1UL)        /*!< MOSI_PACKET_CNT_INT (Bit 1)                           */
#define UARTF0_CFG_EN_FLOW_INT_MOSI_PACKET_CNT_INT_Msk (0x2UL)      /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define UARTF0_CFG_EN_FLOW_INT_OCPM_FLOW_INT_Pos (0UL)              /*!< OCPM_FLOW_INT (Bit 0)                                 */
#define UARTF0_CFG_EN_FLOW_INT_OCPM_FLOW_INT_Msk (0x1UL)            /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
/* ========================================================  ERR_INT  ======================================================== */
#define UARTF0_CFG_ERR_INT_OCPM_ERR_INT_Pos (5UL)                   /*!< OCPM_ERR_INT (Bit 5)                                  */
#define UARTF0_CFG_ERR_INT_OCPM_ERR_INT_Msk (0x20UL)                /*!< OCPM_ERR_INT (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_ERR_INT_OVERFLOW_ERR_INT_Pos (4UL)               /*!< OVERFLOW_ERR_INT (Bit 4)                              */
#define UARTF0_CFG_ERR_INT_OVERFLOW_ERR_INT_Msk (0x10UL)            /*!< OVERFLOW_ERR_INT (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_ERR_INT_PARITY_ERR_INT_Pos (3UL)                 /*!< PARITY_ERR_INT (Bit 3)                                */
#define UARTF0_CFG_ERR_INT_PARITY_ERR_INT_Msk (0x8UL)               /*!< PARITY_ERR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_ERR_INT_FRAME_ERR_INT_Pos (2UL)                  /*!< FRAME_ERR_INT (Bit 2)                                 */
#define UARTF0_CFG_ERR_INT_FRAME_ERR_INT_Msk (0x4UL)                /*!< FRAME_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_ERR_INT_BREAK_ERR_INT_Pos (1UL)                  /*!< BREAK_ERR_INT (Bit 1)                                 */
#define UARTF0_CFG_ERR_INT_BREAK_ERR_INT_Msk (0x2UL)                /*!< BREAK_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_ERR_INT_OVERRUN_ERR_INT_Pos (0UL)                /*!< OVERRUN_ERR_INT (Bit 0)                               */
#define UARTF0_CFG_ERR_INT_OVERRUN_ERR_INT_Msk (0x1UL)              /*!< OVERRUN_ERR_INT (Bitfield-Mask: 0x01)                 */
/* ======================================================  CLR_ERR_INT  ====================================================== */
#define UARTF0_CFG_CLR_ERR_INT_OCPM_ERR_INT_Pos (5UL)               /*!< OCPM_ERR_INT (Bit 5)                                  */
#define UARTF0_CFG_CLR_ERR_INT_OCPM_ERR_INT_Msk (0x20UL)            /*!< OCPM_ERR_INT (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_CLR_ERR_INT_OVERFLOW_ERR_INT_Pos (4UL)           /*!< OVERFLOW_ERR_INT (Bit 4)                              */
#define UARTF0_CFG_CLR_ERR_INT_OVERFLOW_ERR_INT_Msk (0x10UL)        /*!< OVERFLOW_ERR_INT (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_CLR_ERR_INT_PARITY_ERR_INT_Pos (3UL)             /*!< PARITY_ERR_INT (Bit 3)                                */
#define UARTF0_CFG_CLR_ERR_INT_PARITY_ERR_INT_Msk (0x8UL)           /*!< PARITY_ERR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_CLR_ERR_INT_FRAME_ERR_INT_Pos (2UL)              /*!< FRAME_ERR_INT (Bit 2)                                 */
#define UARTF0_CFG_CLR_ERR_INT_FRAME_ERR_INT_Msk (0x4UL)            /*!< FRAME_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_CLR_ERR_INT_BREAK_ERR_INT_Pos (1UL)              /*!< BREAK_ERR_INT (Bit 1)                                 */
#define UARTF0_CFG_CLR_ERR_INT_BREAK_ERR_INT_Msk (0x2UL)            /*!< BREAK_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_CLR_ERR_INT_OVERRUN_ERR_INT_Pos (0UL)            /*!< OVERRUN_ERR_INT (Bit 0)                               */
#define UARTF0_CFG_CLR_ERR_INT_OVERRUN_ERR_INT_Msk (0x1UL)          /*!< OVERRUN_ERR_INT (Bitfield-Mask: 0x01)                 */
/* ======================================================  MSK_ERR_INT  ====================================================== */
#define UARTF0_CFG_MSK_ERR_INT_OCPM_ERR_INT_Pos (5UL)               /*!< OCPM_ERR_INT (Bit 5)                                  */
#define UARTF0_CFG_MSK_ERR_INT_OCPM_ERR_INT_Msk (0x20UL)            /*!< OCPM_ERR_INT (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_MSK_ERR_INT_OVERFLOW_ERR_INT_Pos (4UL)           /*!< OVERFLOW_ERR_INT (Bit 4)                              */
#define UARTF0_CFG_MSK_ERR_INT_OVERFLOW_ERR_INT_Msk (0x10UL)        /*!< OVERFLOW_ERR_INT (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_MSK_ERR_INT_PARITY_ERR_INT_Pos (3UL)             /*!< PARITY_ERR_INT (Bit 3)                                */
#define UARTF0_CFG_MSK_ERR_INT_PARITY_ERR_INT_Msk (0x8UL)           /*!< PARITY_ERR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_MSK_ERR_INT_FRAME_ERR_INT_Pos (2UL)              /*!< FRAME_ERR_INT (Bit 2)                                 */
#define UARTF0_CFG_MSK_ERR_INT_FRAME_ERR_INT_Msk (0x4UL)            /*!< FRAME_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_MSK_ERR_INT_BREAK_ERR_INT_Pos (1UL)              /*!< BREAK_ERR_INT (Bit 1)                                 */
#define UARTF0_CFG_MSK_ERR_INT_BREAK_ERR_INT_Msk (0x2UL)            /*!< BREAK_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_MSK_ERR_INT_OVERRUN_ERR_INT_Pos (0UL)            /*!< OVERRUN_ERR_INT (Bit 0)                               */
#define UARTF0_CFG_MSK_ERR_INT_OVERRUN_ERR_INT_Msk (0x1UL)          /*!< OVERRUN_ERR_INT (Bitfield-Mask: 0x01)                 */
/* ======================================================  EN_ERR_INT  ======================================================= */
#define UARTF0_CFG_EN_ERR_INT_OCPM_ERR_INT_Pos (5UL)                /*!< OCPM_ERR_INT (Bit 5)                                  */
#define UARTF0_CFG_EN_ERR_INT_OCPM_ERR_INT_Msk (0x20UL)             /*!< OCPM_ERR_INT (Bitfield-Mask: 0x01)                    */
#define UARTF0_CFG_EN_ERR_INT_OVERFLOW_ERR_INT_Pos (4UL)            /*!< OVERFLOW_ERR_INT (Bit 4)                              */
#define UARTF0_CFG_EN_ERR_INT_OVERFLOW_ERR_INT_Msk (0x10UL)         /*!< OVERFLOW_ERR_INT (Bitfield-Mask: 0x01)                */
#define UARTF0_CFG_EN_ERR_INT_PARITY_ERR_INT_Pos (3UL)              /*!< PARITY_ERR_INT (Bit 3)                                */
#define UARTF0_CFG_EN_ERR_INT_PARITY_ERR_INT_Msk (0x8UL)            /*!< PARITY_ERR_INT (Bitfield-Mask: 0x01)                  */
#define UARTF0_CFG_EN_ERR_INT_FRAME_ERR_INT_Pos (2UL)               /*!< FRAME_ERR_INT (Bit 2)                                 */
#define UARTF0_CFG_EN_ERR_INT_FRAME_ERR_INT_Msk (0x4UL)             /*!< FRAME_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_EN_ERR_INT_BREAK_ERR_INT_Pos (1UL)               /*!< BREAK_ERR_INT (Bit 1)                                 */
#define UARTF0_CFG_EN_ERR_INT_BREAK_ERR_INT_Msk (0x2UL)             /*!< BREAK_ERR_INT (Bitfield-Mask: 0x01)                   */
#define UARTF0_CFG_EN_ERR_INT_OVERRUN_ERR_INT_Pos (0UL)             /*!< OVERRUN_ERR_INT (Bit 0)                               */
#define UARTF0_CFG_EN_ERR_INT_OVERRUN_ERR_INT_Msk (0x1UL)           /*!< OVERRUN_ERR_INT (Bitfield-Mask: 0x01)                 */
/* =======================================================  UBUS_CTRL  ======================================================= */
#define UARTF0_CFG_UBUS_CTRL_UA1_STABLE_MODE_Pos (3UL)              /*!< UA1_STABLE_MODE (Bit 3)                               */
#define UARTF0_CFG_UBUS_CTRL_UA1_STABLE_MODE_Msk (0x8UL)            /*!< UA1_STABLE_MODE (Bitfield-Mask: 0x01)                 */
#define UARTF0_CFG_UBUS_CTRL_RTS_SEL_Pos  (2UL)                     /*!< RTS_SEL (Bit 2)                                       */
#define UARTF0_CFG_UBUS_CTRL_RTS_SEL_Msk  (0x4UL)                   /*!< RTS_SEL (Bitfield-Mask: 0x01)                         */
#define UARTF0_CFG_UBUS_CTRL_TX_INV_Pos   (1UL)                     /*!< TX_INV (Bit 1)                                        */
#define UARTF0_CFG_UBUS_CTRL_TX_INV_Msk   (0x2UL)                   /*!< TX_INV (Bitfield-Mask: 0x01)                          */
#define UARTF0_CFG_UBUS_CTRL_RX_INV_Pos   (0UL)                     /*!< RX_INV (Bit 0)                                        */
#define UARTF0_CFG_UBUS_CTRL_RX_INV_Msk   (0x1UL)                   /*!< RX_INV (Bitfield-Mask: 0x01)                          */
/* ====================================================  UBUS_RX_TX_SEL  ===================================================== */
#define UARTF0_CFG_UBUS_RX_TX_SEL_RX_N_TX_Pos (0UL)                 /*!< RX_N_TX (Bit 0)                                       */
#define UARTF0_CFG_UBUS_RX_TX_SEL_RX_N_TX_Msk (0x1UL)               /*!< RX_N_TX (Bitfield-Mask: 0x01)                         */
/* ====================================================  UART_8PIN_MODE  ===================================================== */
#define UARTF0_CFG_UART_8PIN_MODE_MODE_DCE_N_Pos (0UL)              /*!< MODE_DCE_N (Bit 0)                                    */
#define UARTF0_CFG_UART_8PIN_MODE_MODE_DCE_N_Msk (0x1UL)            /*!< MODE_DCE_N (Bitfield-Mask: 0x01)                      */


/* =========================================================================================================================== */
/* ================                                           UART                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  DR  =========================================================== */
#define UARTF0_DR_DATA_Pos                (0UL)                     /*!< DATA (Bit 0)                                          */
#define UARTF0_DR_DATA_Msk                (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
#define UARTF0_DR_FE_Pos                  (8UL)                     /*!< FE (Bit 8)                                            */
#define UARTF0_DR_FE_Msk                  (0x100UL)                 /*!< FE (Bitfield-Mask: 0x01)                              */
#define UARTF0_DR_PE_Pos                  (9UL)                     /*!< PE (Bit 9)                                            */
#define UARTF0_DR_PE_Msk                  (0x200UL)                 /*!< PE (Bitfield-Mask: 0x01)                              */
#define UARTF0_DR_BE_Pos                  (10UL)                    /*!< BE (Bit 10)                                           */
#define UARTF0_DR_BE_Msk                  (0x400UL)                 /*!< BE (Bitfield-Mask: 0x01)                              */
#define UARTF0_DR_OE_Pos                  (11UL)                    /*!< OE (Bit 11)                                           */
#define UARTF0_DR_OE_Msk                  (0x800UL)                 /*!< OE (Bitfield-Mask: 0x01)                              */
/* ==========================================================  RSR  ========================================================== */
#define UARTF0_RSR_FE_Pos                 (0UL)                     /*!< FE (Bit 0)                                            */
#define UARTF0_RSR_FE_Msk                 (0x1UL)                   /*!< FE (Bitfield-Mask: 0x01)                              */
#define UARTF0_RSR_PE_Pos                 (1UL)                     /*!< PE (Bit 1)                                            */
#define UARTF0_RSR_PE_Msk                 (0x2UL)                   /*!< PE (Bitfield-Mask: 0x01)                              */
#define UARTF0_RSR_BE_Pos                 (2UL)                     /*!< BE (Bit 2)                                            */
#define UARTF0_RSR_BE_Msk                 (0x4UL)                   /*!< BE (Bitfield-Mask: 0x01)                              */
#define UARTF0_RSR_OE_Pos                 (3UL)                     /*!< OE (Bit 3)                                            */
#define UARTF0_RSR_OE_Msk                 (0x8UL)                   /*!< OE (Bitfield-Mask: 0x01)                              */
/* ==========================================================  ECR  ========================================================== */
#define UARTF0_ECR_CLEAR_ALL_Pos          (0UL)                     /*!< CLEAR_ALL (Bit 0)                                     */
#define UARTF0_ECR_CLEAR_ALL_Msk          (0xffUL)                  /*!< CLEAR_ALL (Bitfield-Mask: 0xff)                       */
/* ==========================================================  FR  =========================================================== */
#define UARTF0_FR_CTS_Pos                 (0UL)                     /*!< CTS (Bit 0)                                           */
#define UARTF0_FR_CTS_Msk                 (0x1UL)                   /*!< CTS (Bitfield-Mask: 0x01)                             */
#define UARTF0_FR_DSR_Pos                 (1UL)                     /*!< DSR (Bit 1)                                           */
#define UARTF0_FR_DSR_Msk                 (0x2UL)                   /*!< DSR (Bitfield-Mask: 0x01)                             */
#define UARTF0_FR_DCD_Pos                 (2UL)                     /*!< DCD (Bit 2)                                           */
#define UARTF0_FR_DCD_Msk                 (0x4UL)                   /*!< DCD (Bitfield-Mask: 0x01)                             */
#define UARTF0_FR_BUSY_Pos                (3UL)                     /*!< BUSY (Bit 3)                                          */
#define UARTF0_FR_BUSY_Msk                (0x8UL)                   /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define UARTF0_FR_RXFE_Pos                (4UL)                     /*!< RXFE (Bit 4)                                          */
#define UARTF0_FR_RXFE_Msk                (0x10UL)                  /*!< RXFE (Bitfield-Mask: 0x01)                            */
#define UARTF0_FR_TXFF_Pos                (5UL)                     /*!< TXFF (Bit 5)                                          */
#define UARTF0_FR_TXFF_Msk                (0x20UL)                  /*!< TXFF (Bitfield-Mask: 0x01)                            */
#define UARTF0_FR_RXFF_Pos                (6UL)                     /*!< RXFF (Bit 6)                                          */
#define UARTF0_FR_RXFF_Msk                (0x40UL)                  /*!< RXFF (Bitfield-Mask: 0x01)                            */
#define UARTF0_FR_TXFE_Pos                (7UL)                     /*!< TXFE (Bit 7)                                          */
#define UARTF0_FR_TXFE_Msk                (0x80UL)                  /*!< TXFE (Bitfield-Mask: 0x01)                            */
#define UARTF0_FR_RI_Pos                  (8UL)                     /*!< RI (Bit 8)                                            */
#define UARTF0_FR_RI_Msk                  (0x100UL)                 /*!< RI (Bitfield-Mask: 0x01)                              */
/* =========================================================  ILPR  ========================================================== */
#define UARTF0_ILPR_ILPDVSR_Pos           (0UL)                     /*!< ILPDVSR (Bit 0)                                       */
#define UARTF0_ILPR_ILPDVSR_Msk           (0xffUL)                  /*!< ILPDVSR (Bitfield-Mask: 0xff)                         */
/* =========================================================  IBRD  ========================================================== */
#define UARTF0_IBRD_BAUD_DIVINT_Pos       (0UL)                     /*!< BAUD_DIVINT (Bit 0)                                   */
#define UARTF0_IBRD_BAUD_DIVINT_Msk       (0xffffUL)                /*!< BAUD_DIVINT (Bitfield-Mask: 0xffff)                   */
/* =========================================================  FBRD  ========================================================== */
#define UARTF0_FBRD_BAUD_DIVFRAC_Pos      (0UL)                     /*!< BAUD_DIVFRAC (Bit 0)                                  */
#define UARTF0_FBRD_BAUD_DIVFRAC_Msk      (0x3fUL)                  /*!< BAUD_DIVFRAC (Bitfield-Mask: 0x3f)                    */
/* =========================================================  LCR_H  ========================================================= */
#define UARTF0_LCR_H_BRK_Pos              (0UL)                     /*!< BRK (Bit 0)                                           */
#define UARTF0_LCR_H_BRK_Msk              (0x1UL)                   /*!< BRK (Bitfield-Mask: 0x01)                             */
#define UARTF0_LCR_H_PEN_Pos              (1UL)                     /*!< PEN (Bit 1)                                           */
#define UARTF0_LCR_H_PEN_Msk              (0x2UL)                   /*!< PEN (Bitfield-Mask: 0x01)                             */
#define UARTF0_LCR_H_EPS_Pos              (2UL)                     /*!< EPS (Bit 2)                                           */
#define UARTF0_LCR_H_EPS_Msk              (0x4UL)                   /*!< EPS (Bitfield-Mask: 0x01)                             */
#define UARTF0_LCR_H_STP2_Pos             (3UL)                     /*!< STP2 (Bit 3)                                          */
#define UARTF0_LCR_H_STP2_Msk             (0x8UL)                   /*!< STP2 (Bitfield-Mask: 0x01)                            */
#define UARTF0_LCR_H_FEN_Pos              (4UL)                     /*!< FEN (Bit 4)                                           */
#define UARTF0_LCR_H_FEN_Msk              (0x10UL)                  /*!< FEN (Bitfield-Mask: 0x01)                             */
#define UARTF0_LCR_H_WLEN_Pos             (5UL)                     /*!< WLEN (Bit 5)                                          */
#define UARTF0_LCR_H_WLEN_Msk             (0x60UL)                  /*!< WLEN (Bitfield-Mask: 0x03)                            */
#define UARTF0_LCR_H_SPS_Pos              (7UL)                     /*!< SPS (Bit 7)                                           */
#define UARTF0_LCR_H_SPS_Msk              (0x80UL)                  /*!< SPS (Bitfield-Mask: 0x01)                             */
/* ==========================================================  CR  =========================================================== */
#define UARTF0_CR_UARTEN_Pos              (0UL)                     /*!< UARTEN (Bit 0)                                        */
#define UARTF0_CR_UARTEN_Msk              (0x1UL)                   /*!< UARTEN (Bitfield-Mask: 0x01)                          */
#define UARTF0_CR_SIREN_Pos               (1UL)                     /*!< SIREN (Bit 1)                                         */
#define UARTF0_CR_SIREN_Msk               (0x2UL)                   /*!< SIREN (Bitfield-Mask: 0x01)                           */
#define UARTF0_CR_SIRLP_Pos               (2UL)                     /*!< SIRLP (Bit 2)                                         */
#define UARTF0_CR_SIRLP_Msk               (0x4UL)                   /*!< SIRLP (Bitfield-Mask: 0x01)                           */
#define UARTF0_CR_RSRVD_Pos               (3UL)                     /*!< RSRVD (Bit 3)                                         */
#define UARTF0_CR_RSRVD_Msk               (0x78UL)                  /*!< RSRVD (Bitfield-Mask: 0x0f)                           */
#define UARTF0_CR_LBE_Pos                 (7UL)                     /*!< LBE (Bit 7)                                           */
#define UARTF0_CR_LBE_Msk                 (0x80UL)                  /*!< LBE (Bitfield-Mask: 0x01)                             */
#define UARTF0_CR_TXE_Pos                 (8UL)                     /*!< TXE (Bit 8)                                           */
#define UARTF0_CR_TXE_Msk                 (0x100UL)                 /*!< TXE (Bitfield-Mask: 0x01)                             */
#define UARTF0_CR_RXE_Pos                 (9UL)                     /*!< RXE (Bit 9)                                           */
#define UARTF0_CR_RXE_Msk                 (0x200UL)                 /*!< RXE (Bitfield-Mask: 0x01)                             */
#define UARTF0_CR_DTR_Pos                 (10UL)                    /*!< DTR (Bit 10)                                          */
#define UARTF0_CR_DTR_Msk                 (0x400UL)                 /*!< DTR (Bitfield-Mask: 0x01)                             */
#define UARTF0_CR_RTS_Pos                 (11UL)                    /*!< RTS (Bit 11)                                          */
#define UARTF0_CR_RTS_Msk                 (0x800UL)                 /*!< RTS (Bitfield-Mask: 0x01)                             */
#define UARTF0_CR_OUT1_Pos                (12UL)                    /*!< OUT1 (Bit 12)                                         */
#define UARTF0_CR_OUT1_Msk                (0x1000UL)                /*!< OUT1 (Bitfield-Mask: 0x01)                            */
#define UARTF0_CR_OUT2_Pos                (13UL)                    /*!< OUT2 (Bit 13)                                         */
#define UARTF0_CR_OUT2_Msk                (0x2000UL)                /*!< OUT2 (Bitfield-Mask: 0x01)                            */
#define UARTF0_CR_RTSEN_Pos               (14UL)                    /*!< RTSEN (Bit 14)                                        */
#define UARTF0_CR_RTSEN_Msk               (0x4000UL)                /*!< RTSEN (Bitfield-Mask: 0x01)                           */
#define UARTF0_CR_CTSEN_Pos               (15UL)                    /*!< CTSEN (Bit 15)                                        */
#define UARTF0_CR_CTSEN_Msk               (0x8000UL)                /*!< CTSEN (Bitfield-Mask: 0x01)                           */
/* =========================================================  IFLS  ========================================================== */
#define UARTF0_IFLS_TXIFLSEL_Pos          (0UL)                     /*!< TXIFLSEL (Bit 0)                                      */
#define UARTF0_IFLS_TXIFLSEL_Msk          (0xfUL)                   /*!< TXIFLSEL (Bitfield-Mask: 0x0f)                        */
#define UARTF0_IFLS_RXIFLSEL_Pos          (4UL)                     /*!< RXIFLSEL (Bit 4)                                      */
#define UARTF0_IFLS_RXIFLSEL_Msk          (0xf0UL)                  /*!< RXIFLSEL (Bitfield-Mask: 0x0f)                        */
/* =========================================================  IMSC  ========================================================== */
#define UARTF0_IMSC_RIMIM_Pos             (0UL)                     /*!< RIMIM (Bit 0)                                         */
#define UARTF0_IMSC_RIMIM_Msk             (0x1UL)                   /*!< RIMIM (Bitfield-Mask: 0x01)                           */
#define UARTF0_IMSC_CTSMIM_Pos            (1UL)                     /*!< CTSMIM (Bit 1)                                        */
#define UARTF0_IMSC_CTSMIM_Msk            (0x2UL)                   /*!< CTSMIM (Bitfield-Mask: 0x01)                          */
#define UARTF0_IMSC_DCDMIM_Pos            (2UL)                     /*!< DCDMIM (Bit 2)                                        */
#define UARTF0_IMSC_DCDMIM_Msk            (0x4UL)                   /*!< DCDMIM (Bitfield-Mask: 0x01)                          */
#define UARTF0_IMSC_DSRMIM_Pos            (3UL)                     /*!< DSRMIM (Bit 3)                                        */
#define UARTF0_IMSC_DSRMIM_Msk            (0x8UL)                   /*!< DSRMIM (Bitfield-Mask: 0x01)                          */
#define UARTF0_IMSC_RXIM_Pos              (4UL)                     /*!< RXIM (Bit 4)                                          */
#define UARTF0_IMSC_RXIM_Msk              (0x10UL)                  /*!< RXIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_TXIM_Pos              (5UL)                     /*!< TXIM (Bit 5)                                          */
#define UARTF0_IMSC_TXIM_Msk              (0x20UL)                  /*!< TXIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_RTIM_Pos              (6UL)                     /*!< RTIM (Bit 6)                                          */
#define UARTF0_IMSC_RTIM_Msk              (0x40UL)                  /*!< RTIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_FEIM_Pos              (7UL)                     /*!< FEIM (Bit 7)                                          */
#define UARTF0_IMSC_FEIM_Msk              (0x80UL)                  /*!< FEIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_PEIM_Pos              (8UL)                     /*!< PEIM (Bit 8)                                          */
#define UARTF0_IMSC_PEIM_Msk              (0x100UL)                 /*!< PEIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_BEIM_Pos              (9UL)                     /*!< BEIM (Bit 9)                                          */
#define UARTF0_IMSC_BEIM_Msk              (0x200UL)                 /*!< BEIM (Bitfield-Mask: 0x01)                            */
#define UARTF0_IMSC_OEIM_Pos              (10UL)                    /*!< OEIM (Bit 10)                                         */
#define UARTF0_IMSC_OEIM_Msk              (0x400UL)                 /*!< OEIM (Bitfield-Mask: 0x01)                            */
/* ==========================================================  RIS  ========================================================== */
#define UARTF0_RIS_RIRMIS_Pos             (0UL)                     /*!< RIRMIS (Bit 0)                                        */
#define UARTF0_RIS_RIRMIS_Msk             (0x1UL)                   /*!< RIRMIS (Bitfield-Mask: 0x01)                          */
#define UARTF0_RIS_CTSRMIS_Pos            (1UL)                     /*!< CTSRMIS (Bit 1)                                       */
#define UARTF0_RIS_CTSRMIS_Msk            (0x2UL)                   /*!< CTSRMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_RIS_DCDRMIS_Pos            (2UL)                     /*!< DCDRMIS (Bit 2)                                       */
#define UARTF0_RIS_DCDRMIS_Msk            (0x4UL)                   /*!< DCDRMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_RIS_DSRRMIS_Pos            (3UL)                     /*!< DSRRMIS (Bit 3)                                       */
#define UARTF0_RIS_DSRRMIS_Msk            (0x8UL)                   /*!< DSRRMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_RIS_RXRIS_Pos              (4UL)                     /*!< RXRIS (Bit 4)                                         */
#define UARTF0_RIS_RXRIS_Msk              (0x10UL)                  /*!< RXRIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_TXRIS_Pos              (5UL)                     /*!< TXRIS (Bit 5)                                         */
#define UARTF0_RIS_TXRIS_Msk              (0x20UL)                  /*!< TXRIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_RTRIS_Pos              (6UL)                     /*!< RTRIS (Bit 6)                                         */
#define UARTF0_RIS_RTRIS_Msk              (0x40UL)                  /*!< RTRIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_FERIS_Pos              (7UL)                     /*!< FERIS (Bit 7)                                         */
#define UARTF0_RIS_FERIS_Msk              (0x80UL)                  /*!< FERIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_PERIS_Pos              (8UL)                     /*!< PERIS (Bit 8)                                         */
#define UARTF0_RIS_PERIS_Msk              (0x100UL)                 /*!< PERIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_BERIS_Pos              (9UL)                     /*!< BERIS (Bit 9)                                         */
#define UARTF0_RIS_BERIS_Msk              (0x200UL)                 /*!< BERIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_RIS_OERIS_Pos              (10UL)                    /*!< OERIS (Bit 10)                                        */
#define UARTF0_RIS_OERIS_Msk              (0x400UL)                 /*!< OERIS (Bitfield-Mask: 0x01)                           */
/* ==========================================================  MIS  ========================================================== */
#define UARTF0_MIS_RIMMIS_Pos             (0UL)                     /*!< RIMMIS (Bit 0)                                        */
#define UARTF0_MIS_RIMMIS_Msk             (0x1UL)                   /*!< RIMMIS (Bitfield-Mask: 0x01)                          */
#define UARTF0_MIS_CTSMMIS_Pos            (1UL)                     /*!< CTSMMIS (Bit 1)                                       */
#define UARTF0_MIS_CTSMMIS_Msk            (0x2UL)                   /*!< CTSMMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_MIS_DCDMMIS_Pos            (2UL)                     /*!< DCDMMIS (Bit 2)                                       */
#define UARTF0_MIS_DCDMMIS_Msk            (0x4UL)                   /*!< DCDMMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_MIS_DSRMMIS_Pos            (3UL)                     /*!< DSRMMIS (Bit 3)                                       */
#define UARTF0_MIS_DSRMMIS_Msk            (0x8UL)                   /*!< DSRMMIS (Bitfield-Mask: 0x01)                         */
#define UARTF0_MIS_RXMIS_Pos              (4UL)                     /*!< RXMIS (Bit 4)                                         */
#define UARTF0_MIS_RXMIS_Msk              (0x10UL)                  /*!< RXMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_TXMIS_Pos              (5UL)                     /*!< TXMIS (Bit 5)                                         */
#define UARTF0_MIS_TXMIS_Msk              (0x20UL)                  /*!< TXMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_RTMIS_Pos              (6UL)                     /*!< RTMIS (Bit 6)                                         */
#define UARTF0_MIS_RTMIS_Msk              (0x40UL)                  /*!< RTMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_FEMIS_Pos              (7UL)                     /*!< FEMIS (Bit 7)                                         */
#define UARTF0_MIS_FEMIS_Msk              (0x80UL)                  /*!< FEMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_PEMIS_Pos              (8UL)                     /*!< PEMIS (Bit 8)                                         */
#define UARTF0_MIS_PEMIS_Msk              (0x100UL)                 /*!< PEMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_BEMIS_Pos              (9UL)                     /*!< BEMIS (Bit 9)                                         */
#define UARTF0_MIS_BEMIS_Msk              (0x200UL)                 /*!< BEMIS (Bitfield-Mask: 0x01)                           */
#define UARTF0_MIS_OEMIS_Pos              (10UL)                    /*!< OEMIS (Bit 10)                                        */
#define UARTF0_MIS_OEMIS_Msk              (0x400UL)                 /*!< OEMIS (Bitfield-Mask: 0x01)                           */
/* ==========================================================  ICR  ========================================================== */
#define UARTF0_ICR_RIMIC_Pos              (0UL)                     /*!< RIMIC (Bit 0)                                         */
#define UARTF0_ICR_RIMIC_Msk              (0x1UL)                   /*!< RIMIC (Bitfield-Mask: 0x01)                           */
#define UARTF0_ICR_CTSMIC_Pos             (1UL)                     /*!< CTSMIC (Bit 1)                                        */
#define UARTF0_ICR_CTSMIC_Msk             (0x2UL)                   /*!< CTSMIC (Bitfield-Mask: 0x01)                          */
#define UARTF0_ICR_DCDMIC_Pos             (2UL)                     /*!< DCDMIC (Bit 2)                                        */
#define UARTF0_ICR_DCDMIC_Msk             (0x4UL)                   /*!< DCDMIC (Bitfield-Mask: 0x01)                          */
#define UARTF0_ICR_DSRMIC_Pos             (3UL)                     /*!< DSRMIC (Bit 3)                                        */
#define UARTF0_ICR_DSRMIC_Msk             (0x8UL)                   /*!< DSRMIC (Bitfield-Mask: 0x01)                          */
#define UARTF0_ICR_RXIC_Pos               (4UL)                     /*!< RXIC (Bit 4)                                          */
#define UARTF0_ICR_RXIC_Msk               (0x10UL)                  /*!< RXIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_TXIC_Pos               (5UL)                     /*!< TXIC (Bit 5)                                          */
#define UARTF0_ICR_TXIC_Msk               (0x20UL)                  /*!< TXIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_RTIC_Pos               (6UL)                     /*!< RTIC (Bit 6)                                          */
#define UARTF0_ICR_RTIC_Msk               (0x40UL)                  /*!< RTIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_FEIC_Pos               (7UL)                     /*!< FEIC (Bit 7)                                          */
#define UARTF0_ICR_FEIC_Msk               (0x80UL)                  /*!< FEIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_PEIC_Pos               (8UL)                     /*!< PEIC (Bit 8)                                          */
#define UARTF0_ICR_PEIC_Msk               (0x100UL)                 /*!< PEIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_BEIC_Pos               (9UL)                     /*!< BEIC (Bit 9)                                          */
#define UARTF0_ICR_BEIC_Msk               (0x200UL)                 /*!< BEIC (Bitfield-Mask: 0x01)                            */
#define UARTF0_ICR_OEIC_Pos               (10UL)                    /*!< OEIC (Bit 10)                                         */
#define UARTF0_ICR_OEIC_Msk               (0x400UL)                 /*!< OEIC (Bitfield-Mask: 0x01)                            */


/* =========================================================================================================================== */
/* ================                                         SPI_SLAVE                                         ================ */
/* =========================================================================================================================== */

/* ==========================================================  CFG  ========================================================== */
#define SPI_SLAVE_CFG_CHAR_EN_Pos         (31UL)                    /*!< CHAR_EN (Bit 31)                                      */
#define SPI_SLAVE_CFG_CHAR_EN_Msk         (0x80000000UL)            /*!< CHAR_EN (Bitfield-Mask: 0x01)                         */
#define SPI_SLAVE_CFG_FLUSH_LINE_DRIVER_Pos (28UL)                  /*!< FLUSH_LINE_DRIVER (Bit 28)                            */
#define SPI_SLAVE_CFG_FLUSH_LINE_DRIVER_Msk (0x10000000UL)          /*!< FLUSH_LINE_DRIVER (Bitfield-Mask: 0x01)               */
#define SPI_SLAVE_CFG_MISO_IDLE_VALUE_Pos (24UL)                    /*!< MISO_IDLE_VALUE (Bit 24)                              */
#define SPI_SLAVE_CFG_MISO_IDLE_VALUE_Msk (0x1000000UL)             /*!< MISO_IDLE_VALUE (Bitfield-Mask: 0x01)                 */
#define SPI_SLAVE_CFG_SS_ACTIVE_HIGH_Pos  (23UL)                    /*!< SS_ACTIVE_HIGH (Bit 23)                               */
#define SPI_SLAVE_CFG_SS_ACTIVE_HIGH_Msk  (0x800000UL)              /*!< SS_ACTIVE_HIGH (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_CFG_SS_BOTH_EDGE_INT_EN_Pos (16UL)                /*!< SS_BOTH_EDGE_INT_EN (Bit 16)                          */
#define SPI_SLAVE_CFG_SS_BOTH_EDGE_INT_EN_Msk (0x10000UL)           /*!< SS_BOTH_EDGE_INT_EN (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_CFG_CPHA_Pos            (10UL)                    /*!< CPHA (Bit 10)                                         */
#define SPI_SLAVE_CFG_CPHA_Msk            (0x400UL)                 /*!< CPHA (Bitfield-Mask: 0x01)                            */
#define SPI_SLAVE_CFG_CPOL_Pos            (9UL)                     /*!< CPOL (Bit 9)                                          */
#define SPI_SLAVE_CFG_CPOL_Msk            (0x200UL)                 /*!< CPOL (Bitfield-Mask: 0x01)                            */
#define SPI_SLAVE_CFG_REVERSAL_Pos        (8UL)                     /*!< REVERSAL (Bit 8)                                      */
#define SPI_SLAVE_CFG_REVERSAL_Msk        (0x100UL)                 /*!< REVERSAL (Bitfield-Mask: 0x01)                        */
#define SPI_SLAVE_CFG_ENDIAN_SWITCH_Pos   (7UL)                     /*!< ENDIAN_SWITCH (Bit 7)                                 */
#define SPI_SLAVE_CFG_ENDIAN_SWITCH_Msk   (0x80UL)                  /*!< ENDIAN_SWITCH (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_CFG_INFINITE_Pos        (6UL)                     /*!< INFINITE (Bit 6)                                      */
#define SPI_SLAVE_CFG_INFINITE_Msk        (0x40UL)                  /*!< INFINITE (Bitfield-Mask: 0x01)                        */
#define SPI_SLAVE_CFG_WORD_SIZE_Pos       (0UL)                     /*!< WORD_SIZE (Bit 0)                                     */
#define SPI_SLAVE_CFG_WORD_SIZE_Msk       (0x3fUL)                  /*!< WORD_SIZE (Bitfield-Mask: 0x3f)                       */
/* ======================================================  CFG_PACKET  ======================================================= */
#define SPI_SLAVE_CFG_PACKET_MULTI_PACKET_SIZE_Pos (16UL)           /*!< MULTI_PACKET_SIZE (Bit 16)                            */
#define SPI_SLAVE_CFG_PACKET_MULTI_PACKET_SIZE_Msk (0xffff0000UL)   /*!< MULTI_PACKET_SIZE (Bitfield-Mask: 0xffff)             */
#define SPI_SLAVE_CFG_PACKET_PACKET_SIZE_Pos (0UL)                  /*!< PACKET_SIZE (Bit 0)                                   */
#define SPI_SLAVE_CFG_PACKET_PACKET_SIZE_Msk (0xffffUL)             /*!< PACKET_SIZE (Bitfield-Mask: 0xffff)                   */
/* =========================================================  SRDY  ========================================================== */
#define SPI_SLAVE_SRDY_SPI_SS_IN_HCLK_MUXED_Pos (31UL)              /*!< SPI_SS_IN_HCLK_MUXED (Bit 31)                         */
#define SPI_SLAVE_SRDY_SPI_SS_IN_HCLK_MUXED_Msk (0x80000000UL)      /*!< SPI_SS_IN_HCLK_MUXED (Bitfield-Mask: 0x01)            */
#define SPI_SLAVE_SRDY_SPI_SW_BYPASS_SRDY_Pos (2UL)                 /*!< SPI_SW_BYPASS_SRDY (Bit 2)                            */
#define SPI_SLAVE_SRDY_SPI_SW_BYPASS_SRDY_Msk (0x4UL)               /*!< SPI_SW_BYPASS_SRDY (Bitfield-Mask: 0x01)              */
#define SPI_SLAVE_SRDY_SPI_SW_SRDY_IDLE_Pos (1UL)                   /*!< SPI_SW_SRDY_IDLE (Bit 1)                              */
#define SPI_SLAVE_SRDY_SPI_SW_SRDY_IDLE_Msk (0x2UL)                 /*!< SPI_SW_SRDY_IDLE (Bitfield-Mask: 0x01)                */
#define SPI_SLAVE_SRDY_SPI_SW_SRDY_VALUE_Pos (0UL)                  /*!< SPI_SW_SRDY_VALUE (Bit 0)                             */
#define SPI_SLAVE_SRDY_SPI_SW_SRDY_VALUE_Msk (0x1UL)                /*!< SPI_SW_SRDY_VALUE (Bitfield-Mask: 0x01)               */
/* ========================================================  RD_INT  ========================================================= */
#define SPI_SLAVE_RD_INT_MULTI_PACKET_COMPLETE_INT_Pos (7UL)        /*!< MULTI_PACKET_COMPLETE_INT (Bit 7)                     */
#define SPI_SLAVE_RD_INT_MULTI_PACKET_COMPLETE_INT_Msk (0x80UL)     /*!< MULTI_PACKET_COMPLETE_INT (Bitfield-Mask: 0x01)       */
#define SPI_SLAVE_RD_INT_MISO_PACKET_CNT_INT_Pos (6UL)              /*!< MISO_PACKET_CNT_INT (Bit 6)                           */
#define SPI_SLAVE_RD_INT_MISO_PACKET_CNT_INT_Msk (0x40UL)           /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_RD_INT_MOSI_PACKET_CNT_INT_Pos (5UL)              /*!< MOSI_PACKET_CNT_INT (Bit 5)                           */
#define SPI_SLAVE_RD_INT_MOSI_PACKET_CNT_INT_Msk (0x20UL)           /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_RD_INT_OCPM_FLOW_INT_Pos (1UL)                    /*!< OCPM_FLOW_INT (Bit 1)                                 */
#define SPI_SLAVE_RD_INT_OCPM_FLOW_INT_Msk (0x2UL)                  /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_RD_INT_MASTER_READY_INT_Pos (0UL)                 /*!< MASTER_READY_INT (Bit 0)                              */
#define SPI_SLAVE_RD_INT_MASTER_READY_INT_Msk (0x1UL)               /*!< MASTER_READY_INT (Bitfield-Mask: 0x01)                */
/* ======================================================  RD_CLR_INT  ======================================================= */
#define SPI_SLAVE_RD_CLR_INT_MULTI_PACKET_COMPLETE_INT_Pos (7UL)    /*!< MULTI_PACKET_COMPLETE_INT (Bit 7)                     */
#define SPI_SLAVE_RD_CLR_INT_MULTI_PACKET_COMPLETE_INT_Msk (0x80UL) /*!< MULTI_PACKET_COMPLETE_INT (Bitfield-Mask: 0x01)       */
#define SPI_SLAVE_RD_CLR_INT_MISO_PACKET_CNT_INT_Pos (6UL)          /*!< MISO_PACKET_CNT_INT (Bit 6)                           */
#define SPI_SLAVE_RD_CLR_INT_MISO_PACKET_CNT_INT_Msk (0x40UL)       /*!< MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_RD_CLR_INT_MOSI_PACKET_CNT_INT_Pos (5UL)          /*!< MOSI_PACKET_CNT_INT (Bit 5)                           */
#define SPI_SLAVE_RD_CLR_INT_MOSI_PACKET_CNT_INT_Msk (0x20UL)       /*!< MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_RD_CLR_INT_OCPM_FLOW_INT_Pos (1UL)                /*!< OCPM_FLOW_INT (Bit 1)                                 */
#define SPI_SLAVE_RD_CLR_INT_OCPM_FLOW_INT_Msk (0x2UL)              /*!< OCPM_FLOW_INT (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_RD_CLR_INT_MASTER_READY_INT_Pos (0UL)             /*!< MASTER_READY_INT (Bit 0)                              */
#define SPI_SLAVE_RD_CLR_INT_MASTER_READY_INT_Msk (0x1UL)           /*!< MASTER_READY_INT (Bitfield-Mask: 0x01)                */
/* =======================================================  MASK_INT  ======================================================== */
#define SPI_SLAVE_MASK_INT_MASK_MULTI_PACKET_COMPLETE_INT_Pos (7UL) /*!< MASK_MULTI_PACKET_COMPLETE_INT (Bit 7)                */
#define SPI_SLAVE_MASK_INT_MASK_MULTI_PACKET_COMPLETE_INT_Msk (0x80UL) /*!< MASK_MULTI_PACKET_COMPLETE_INT (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_MASK_INT_MASK_MISO_PACKET_CNT_INT_Pos (6UL)       /*!< MASK_MISO_PACKET_CNT_INT (Bit 6)                      */
#define SPI_SLAVE_MASK_INT_MASK_MISO_PACKET_CNT_INT_Msk (0x40UL)    /*!< MASK_MISO_PACKET_CNT_INT (Bitfield-Mask: 0x01)        */
#define SPI_SLAVE_MASK_INT_MASK_MOSI_PACKET_CNT_INT_Pos (5UL)       /*!< MASK_MOSI_PACKET_CNT_INT (Bit 5)                      */
#define SPI_SLAVE_MASK_INT_MASK_MOSI_PACKET_CNT_INT_Msk (0x20UL)    /*!< MASK_MOSI_PACKET_CNT_INT (Bitfield-Mask: 0x01)        */
#define SPI_SLAVE_MASK_INT_MASK_MASTER_READY_INT_Pos (0UL)          /*!< MASK_MASTER_READY_INT (Bit 0)                         */
#define SPI_SLAVE_MASK_INT_MASK_MASTER_READY_INT_Msk (0x1UL)        /*!< MASK_MASTER_READY_INT (Bitfield-Mask: 0x01)           */
/* ========================================================  INT_EN  ========================================================= */
#define SPI_SLAVE_INT_EN_MULTI_PACKET_COMPLETE_INT_EN_Pos (7UL)     /*!< MULTI_PACKET_COMPLETE_INT_EN (Bit 7)                  */
#define SPI_SLAVE_INT_EN_MULTI_PACKET_COMPLETE_INT_EN_Msk (0x80UL)  /*!< MULTI_PACKET_COMPLETE_INT_EN (Bitfield-Mask: 0x01)    */
#define SPI_SLAVE_INT_EN_MASTER_READY_INT_EN_Pos (0UL)              /*!< MASTER_READY_INT_EN (Bit 0)                           */
#define SPI_SLAVE_INT_EN_MASTER_READY_INT_EN_Msk (0x1UL)            /*!< MASTER_READY_INT_EN (Bitfield-Mask: 0x01)             */
/* ==================================================  MOSI_PAC_AT_CNT_INC  ================================================== */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_INC_BD_CNT_INC_Pos (0UL)          /*!< BD_CNT_INC (Bit 0)                                    */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_INC_BD_CNT_INC_Msk (0xffUL)       /*!< BD_CNT_INC (Bitfield-Mask: 0xff)                      */
/* ==================================================  MOSI_PAC_AT_CNT_DEC  ================================================== */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_DEC_BD_CNT_DEC_Pos (0UL)          /*!< BD_CNT_DEC (Bit 0)                                    */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_DEC_BD_CNT_DEC_Msk (0xffUL)       /*!< BD_CNT_DEC (Bitfield-Mask: 0xff)                      */
/* =================================================  MOSI_PAC_AT_CNT_CTRL  ================================================== */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Pos (0UL)      /*!< BD_CNT_INT_EN (Bit 0)                                 */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Msk (0x1UL)    /*!< BD_CNT_INT_EN (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Pos (1UL)    /*!< BD_CNT_INT_MODE (Bit 1)                               */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Msk (0x6UL)  /*!< BD_CNT_INT_MODE (Bitfield-Mask: 0x03)                 */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Pos (3UL)       /*!< BD_CNT_HW_EN (Bit 3)                                  */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Msk (0x8UL)     /*!< BD_CNT_HW_EN (Bitfield-Mask: 0x01)                    */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Pos (4UL)     /*!< BD_CNT_THRS_EN (Bit 4)                                */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Msk (0x10UL)  /*!< BD_CNT_THRS_EN (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Pos (16UL) /*!< BD_CNT_THRS_VALUE (Bit 16)                            */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Msk (0xff0000UL) /*!< BD_CNT_THRS_VALUE (Bitfield-Mask: 0xff)         */
/* ====================================================  MOSI_PAC_AT_CNT  ==================================================== */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_BD_CNT_Pos (0UL)                  /*!< BD_CNT (Bit 0)                                        */
#define SPI_SLAVE_MOSI_PAC_AT_CNT_BD_CNT_Msk (0xffUL)               /*!< BD_CNT (Bitfield-Mask: 0xff)                          */
/* ==================================================  MISO_PAC_AT_CNT_INC  ================================================== */
#define SPI_SLAVE_MISO_PAC_AT_CNT_INC_BD_CNT_INC_Pos (0UL)          /*!< BD_CNT_INC (Bit 0)                                    */
#define SPI_SLAVE_MISO_PAC_AT_CNT_INC_BD_CNT_INC_Msk (0xffUL)       /*!< BD_CNT_INC (Bitfield-Mask: 0xff)                      */
/* ==================================================  MISO_PAC_AT_CNT_DEC  ================================================== */
#define SPI_SLAVE_MISO_PAC_AT_CNT_DEC_BD_CNT_DEC_Pos (0UL)          /*!< BD_CNT_DEC (Bit 0)                                    */
#define SPI_SLAVE_MISO_PAC_AT_CNT_DEC_BD_CNT_DEC_Msk (0xffUL)       /*!< BD_CNT_DEC (Bitfield-Mask: 0xff)                      */
/* =================================================  MISO_PAC_AT_CNT_CTRL  ================================================== */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Pos (0UL)      /*!< BD_CNT_INT_EN (Bit 0)                                 */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_EN_Msk (0x1UL)    /*!< BD_CNT_INT_EN (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Pos (1UL)    /*!< BD_CNT_INT_MODE (Bit 1)                               */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_INT_MODE_Msk (0x6UL)  /*!< BD_CNT_INT_MODE (Bitfield-Mask: 0x03)                 */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Pos (3UL)       /*!< BD_CNT_HW_EN (Bit 3)                                  */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_HW_EN_Msk (0x8UL)     /*!< BD_CNT_HW_EN (Bitfield-Mask: 0x01)                    */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Pos (4UL)     /*!< BD_CNT_THRS_EN (Bit 4)                                */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_EN_Msk (0x10UL)  /*!< BD_CNT_THRS_EN (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Pos (16UL) /*!< BD_CNT_THRS_VALUE (Bit 16)                            */
#define SPI_SLAVE_MISO_PAC_AT_CNT_CTRL_BD_CNT_THRS_VALUE_Msk (0xff0000UL) /*!< BD_CNT_THRS_VALUE (Bitfield-Mask: 0xff)         */
/* ====================================================  MISO_PAC_AT_CNT  ==================================================== */
#define SPI_SLAVE_MISO_PAC_AT_CNT_BD_CNT_Pos (0UL)                  /*!< BD_CNT (Bit 0)                                        */
#define SPI_SLAVE_MISO_PAC_AT_CNT_BD_CNT_Msk (0xffUL)               /*!< BD_CNT (Bitfield-Mask: 0xff)                          */
/* ==================================================  MULTI_PACKET_STATUS  ================================================== */
#define SPI_SLAVE_MULTI_PACKET_STATUS_PACKET_COUNTER_MOSI_Pos (16UL) /*!< PACKET_COUNTER_MOSI (Bit 16)                         */
#define SPI_SLAVE_MULTI_PACKET_STATUS_PACKET_COUNTER_MOSI_Msk (0xffff0000UL) /*!< PACKET_COUNTER_MOSI (Bitfield-Mask: 0xffff)  */
#define SPI_SLAVE_MULTI_PACKET_STATUS_PACKET_COUNTER_MISO_Pos (0UL) /*!< PACKET_COUNTER_MISO (Bit 0)                           */
#define SPI_SLAVE_MULTI_PACKET_STATUS_PACKET_COUNTER_MISO_Msk (0xffffUL) /*!< PACKET_COUNTER_MISO (Bitfield-Mask: 0xffff)      */
/* =======================================================  OCPM_CFG  ======================================================== */
#define SPI_SLAVE_OCPM_CFG_MOSI_BIG_ENDIAN_Pos (29UL)               /*!< MOSI_BIG_ENDIAN (Bit 29)                              */
#define SPI_SLAVE_OCPM_CFG_MOSI_BIG_ENDIAN_Msk (0x20000000UL)       /*!< MOSI_BIG_ENDIAN (Bitfield-Mask: 0x01)                 */
#define SPI_SLAVE_OCPM_CFG_MISO_BIG_ENDIAN_Pos (28UL)               /*!< MISO_BIG_ENDIAN (Bit 28)                              */
#define SPI_SLAVE_OCPM_CFG_MISO_BIG_ENDIAN_Msk (0x10000000UL)       /*!< MISO_BIG_ENDIAN (Bitfield-Mask: 0x01)                 */
#define SPI_SLAVE_OCPM_CFG_OCP_BRST_ALIGN_Pos (24UL)                /*!< OCP_BRST_ALIGN (Bit 24)                               */
#define SPI_SLAVE_OCPM_CFG_OCP_BRST_ALIGN_Msk (0x1000000UL)         /*!< OCP_BRST_ALIGN (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_CFG_RD_FIFO_THRES_Pos (20UL)                 /*!< RD_FIFO_THRES (Bit 20)                                */
#define SPI_SLAVE_OCPM_CFG_RD_FIFO_THRES_Msk (0xf00000UL)           /*!< RD_FIFO_THRES (Bitfield-Mask: 0x0f)                   */
#define SPI_SLAVE_OCPM_CFG_THRES_RD_SW_BYPASS_Pos (16UL)            /*!< THRES_RD_SW_BYPASS (Bit 16)                           */
#define SPI_SLAVE_OCPM_CFG_THRES_RD_SW_BYPASS_Msk (0x10000UL)       /*!< THRES_RD_SW_BYPASS (Bitfield-Mask: 0x01)              */
#define SPI_SLAVE_OCPM_CFG_RD_FIFO_THRES_VALUE_Pos (12UL)           /*!< RD_FIFO_THRES_VALUE (Bit 12)                          */
#define SPI_SLAVE_OCPM_CFG_RD_FIFO_THRES_VALUE_Msk (0xf000UL)       /*!< RD_FIFO_THRES_VALUE (Bitfield-Mask: 0x0f)             */
#define SPI_SLAVE_OCPM_CFG_WR_FIFO_THRES_Pos (8UL)                  /*!< WR_FIFO_THRES (Bit 8)                                 */
#define SPI_SLAVE_OCPM_CFG_WR_FIFO_THRES_Msk (0xf00UL)              /*!< WR_FIFO_THRES (Bitfield-Mask: 0x0f)                   */
#define SPI_SLAVE_OCPM_CFG_THRES_WR_SW_BYPASS_Pos (4UL)             /*!< THRES_WR_SW_BYPASS (Bit 4)                            */
#define SPI_SLAVE_OCPM_CFG_THRES_WR_SW_BYPASS_Msk (0x10UL)          /*!< THRES_WR_SW_BYPASS (Bitfield-Mask: 0x01)              */
#define SPI_SLAVE_OCPM_CFG_WR_FIFO_THRES_VALUE_Pos (0UL)            /*!< WR_FIFO_THRES_VALUE (Bit 0)                           */
#define SPI_SLAVE_OCPM_CFG_WR_FIFO_THRES_VALUE_Msk (0xfUL)          /*!< WR_FIFO_THRES_VALUE (Bitfield-Mask: 0x0f)             */
/* =======================================================  OCPM_INIT  ======================================================= */
#define SPI_SLAVE_OCPM_INIT_RESET_RD_BUFF_Pos (24UL)                /*!< RESET_RD_BUFF (Bit 24)                                */
#define SPI_SLAVE_OCPM_INIT_RESET_RD_BUFF_Msk (0x1000000UL)         /*!< RESET_RD_BUFF (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_OCPM_INIT_RESET_WR_BUFF_Pos (16UL)                /*!< RESET_WR_BUFF (Bit 16)                                */
#define SPI_SLAVE_OCPM_INIT_RESET_WR_BUFF_Msk (0x10000UL)           /*!< RESET_WR_BUFF (Bitfield-Mask: 0x01)                   */
#define SPI_SLAVE_OCPM_INIT_RD_BD_LIST_ADDR_FLUSH_Pos (11UL)        /*!< RD_BD_LIST_ADDR_FLUSH (Bit 11)                        */
#define SPI_SLAVE_OCPM_INIT_RD_BD_LIST_ADDR_FLUSH_Msk (0x800UL)     /*!< RD_BD_LIST_ADDR_FLUSH (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_INIT_RD_BD_LIST_SIZE_FLUSH_Pos (10UL)        /*!< RD_BD_LIST_SIZE_FLUSH (Bit 10)                        */
#define SPI_SLAVE_OCPM_INIT_RD_BD_LIST_SIZE_FLUSH_Msk (0x400UL)     /*!< RD_BD_LIST_SIZE_FLUSH (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_INIT_WR_BD_LIST_ADDR_FLUSH_Pos (9UL)         /*!< WR_BD_LIST_ADDR_FLUSH (Bit 9)                         */
#define SPI_SLAVE_OCPM_INIT_WR_BD_LIST_ADDR_FLUSH_Msk (0x200UL)     /*!< WR_BD_LIST_ADDR_FLUSH (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_INIT_WR_BD_LIST_SIZE_FLUSH_Pos (8UL)         /*!< WR_BD_LIST_SIZE_FLUSH (Bit 8)                         */
#define SPI_SLAVE_OCPM_INIT_WR_BD_LIST_SIZE_FLUSH_Msk (0x100UL)     /*!< WR_BD_LIST_SIZE_FLUSH (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_INIT_MISO_RESET_FLUSH_Pos (1UL)              /*!< MISO_RESET_FLUSH (Bit 1)                              */
#define SPI_SLAVE_OCPM_INIT_MISO_RESET_FLUSH_Msk (0x2UL)            /*!< MISO_RESET_FLUSH (Bitfield-Mask: 0x01)                */
#define SPI_SLAVE_OCPM_INIT_MOSI_RESET_FLUSH_Pos (0UL)              /*!< MOSI_RESET_FLUSH (Bit 0)                              */
#define SPI_SLAVE_OCPM_INIT_MOSI_RESET_FLUSH_Msk (0x1UL)            /*!< MOSI_RESET_FLUSH (Bitfield-Mask: 0x01)                */
/* =====================================================  OCPM_RD_ADDR  ====================================================== */
#define SPI_SLAVE_OCPM_RD_ADDR_RD_BUFF_START_ADDR_Pos (0UL)         /*!< RD_BUFF_START_ADDR (Bit 0)                            */
#define SPI_SLAVE_OCPM_RD_ADDR_RD_BUFF_START_ADDR_Msk (0x1fffffffUL) /*!< RD_BUFF_START_ADDR (Bitfield-Mask: 0x1fffffff)       */
/* =====================================================  OCPM_WR_ADDR  ====================================================== */
#define SPI_SLAVE_OCPM_WR_ADDR_WR_BUFF_START_ADDR_Pos (0UL)         /*!< WR_BUFF_START_ADDR (Bit 0)                            */
#define SPI_SLAVE_OCPM_WR_ADDR_WR_BUFF_START_ADDR_Msk (0x1fffffffUL) /*!< WR_BUFF_START_ADDR (Bitfield-Mask: 0x1fffffff)       */
/* =====================================================  OCPM_LEN_CFG  ====================================================== */
#define SPI_SLAVE_OCPM_LEN_CFG_RD_BUFF_LEN_Pos (16UL)               /*!< RD_BUFF_LEN (Bit 16)                                  */
#define SPI_SLAVE_OCPM_LEN_CFG_RD_BUFF_LEN_Msk (0xffff0000UL)       /*!< RD_BUFF_LEN (Bitfield-Mask: 0xffff)                   */
#define SPI_SLAVE_OCPM_LEN_CFG_WR_BUFF_LEN_Pos (0UL)                /*!< WR_BUFF_LEN (Bit 0)                                   */
#define SPI_SLAVE_OCPM_LEN_CFG_WR_BUFF_LEN_Msk (0xffffUL)           /*!< WR_BUFF_LEN (Bitfield-Mask: 0xffff)                   */
/* ======================================================  OCPM_RD_INT  ====================================================== */
#define SPI_SLAVE_OCPM_RD_INT_WR_BD_ADDR_INT_Pos (3UL)              /*!< WR_BD_ADDR_INT (Bit 3)                                */
#define SPI_SLAVE_OCPM_RD_INT_WR_BD_ADDR_INT_Msk (0x8UL)            /*!< WR_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_INT_WR_BD_SIZE_INT_Pos (2UL)              /*!< WR_BD_SIZE_INT (Bit 2)                                */
#define SPI_SLAVE_OCPM_RD_INT_WR_BD_SIZE_INT_Msk (0x4UL)            /*!< WR_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_INT_RD_BD_ADDR_INT_Pos (1UL)              /*!< RD_BD_ADDR_INT (Bit 1)                                */
#define SPI_SLAVE_OCPM_RD_INT_RD_BD_ADDR_INT_Msk (0x2UL)            /*!< RD_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_INT_RD_BD_SIZE_INT_Pos (0UL)              /*!< RD_BD_SIZE_INT (Bit 0)                                */
#define SPI_SLAVE_OCPM_RD_INT_RD_BD_SIZE_INT_Msk (0x1UL)            /*!< RD_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
/* ====================================================  OCPM_RD_CLR_INT  ==================================================== */
#define SPI_SLAVE_OCPM_RD_CLR_INT_WR_BD_ADDR_INT_Pos (3UL)          /*!< WR_BD_ADDR_INT (Bit 3)                                */
#define SPI_SLAVE_OCPM_RD_CLR_INT_WR_BD_ADDR_INT_Msk (0x8UL)        /*!< WR_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_CLR_INT_WR_BD_SIZE_INT_Pos (2UL)          /*!< WR_BD_SIZE_INT (Bit 2)                                */
#define SPI_SLAVE_OCPM_RD_CLR_INT_WR_BD_SIZE_INT_Msk (0x4UL)        /*!< WR_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_CLR_INT_RD_BD_ADDR_INT_Pos (1UL)          /*!< RD_BD_ADDR_INT (Bit 1)                                */
#define SPI_SLAVE_OCPM_RD_CLR_INT_RD_BD_ADDR_INT_Msk (0x2UL)        /*!< RD_BD_ADDR_INT (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_RD_CLR_INT_RD_BD_SIZE_INT_Pos (0UL)          /*!< RD_BD_SIZE_INT (Bit 0)                                */
#define SPI_SLAVE_OCPM_RD_CLR_INT_RD_BD_SIZE_INT_Msk (0x1UL)        /*!< RD_BD_SIZE_INT (Bitfield-Mask: 0x01)                  */
/* =====================================================  OCPM_MASK_INT  ===================================================== */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_WR_BD_ADDR_INT_Pos (3UL)       /*!< MASK_WR_BD_ADDR_INT (Bit 3)                           */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_WR_BD_ADDR_INT_Msk (0x8UL)     /*!< MASK_WR_BD_ADDR_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_WR_BD_SIZE_INT_Pos (2UL)       /*!< MASK_WR_BD_SIZE_INT (Bit 2)                           */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_WR_BD_SIZE_INT_Msk (0x4UL)     /*!< MASK_WR_BD_SIZE_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_RD_BD_ADDR_INT_Pos (1UL)       /*!< MASK_RD_BD_ADDR_INT (Bit 1)                           */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_RD_BD_ADDR_INT_Msk (0x2UL)     /*!< MASK_RD_BD_ADDR_INT (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_RD_BD_SIZE_INT_Pos (0UL)       /*!< MASK_RD_BD_SIZE_INT (Bit 0)                           */
#define SPI_SLAVE_OCPM_MASK_INT_MASK_RD_BD_SIZE_INT_Msk (0x1UL)     /*!< MASK_RD_BD_SIZE_INT (Bitfield-Mask: 0x01)             */
/* ======================================================  OCPM_INT_EN  ====================================================== */
#define SPI_SLAVE_OCPM_INT_EN_WR_BD_ADDR_INT_EN_Pos (3UL)           /*!< WR_BD_ADDR_INT_EN (Bit 3)                             */
#define SPI_SLAVE_OCPM_INT_EN_WR_BD_ADDR_INT_EN_Msk (0x8UL)         /*!< WR_BD_ADDR_INT_EN (Bitfield-Mask: 0x01)               */
#define SPI_SLAVE_OCPM_INT_EN_WR_BD_SIZE_INT_EN_Pos (2UL)           /*!< WR_BD_SIZE_INT_EN (Bit 2)                             */
#define SPI_SLAVE_OCPM_INT_EN_WR_BD_SIZE_INT_EN_Msk (0x4UL)         /*!< WR_BD_SIZE_INT_EN (Bitfield-Mask: 0x01)               */
#define SPI_SLAVE_OCPM_INT_EN_RD_BD_ADDR_INT_EN_Pos (1UL)           /*!< RD_BD_ADDR_INT_EN (Bit 1)                             */
#define SPI_SLAVE_OCPM_INT_EN_RD_BD_ADDR_INT_EN_Msk (0x2UL)         /*!< RD_BD_ADDR_INT_EN (Bitfield-Mask: 0x01)               */
#define SPI_SLAVE_OCPM_INT_EN_RD_BD_SIZE_INT_EN_Pos (0UL)           /*!< RD_BD_SIZE_INT_EN (Bit 0)                             */
#define SPI_SLAVE_OCPM_INT_EN_RD_BD_SIZE_INT_EN_Msk (0x1UL)         /*!< RD_BD_SIZE_INT_EN (Bitfield-Mask: 0x01)               */
/* ===================================================  OCPM_BUFF_ACTIVE  ==================================================== */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_WR_BUFF_CYCLIC_EN_Pos (24UL)     /*!< WR_BUFF_CYCLIC_EN (Bit 24)                            */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_WR_BUFF_CYCLIC_EN_Msk (0x1000000UL) /*!< WR_BUFF_CYCLIC_EN (Bitfield-Mask: 0x01)            */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_RD_BUFF_CYCLIC_EN_Pos (16UL)     /*!< RD_BUFF_CYCLIC_EN (Bit 16)                            */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_RD_BUFF_CYCLIC_EN_Msk (0x10000UL) /*!< RD_BUFF_CYCLIC_EN (Bitfield-Mask: 0x01)              */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_RD_BUFF_ACTIVE_Pos (8UL)         /*!< RD_BUFF_ACTIVE (Bit 8)                                */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_RD_BUFF_ACTIVE_Msk (0x100UL)     /*!< RD_BUFF_ACTIVE (Bitfield-Mask: 0x01)                  */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_WR_BUFF_ACTIVE_Pos (0UL)         /*!< WR_BUFF_ACTIVE (Bit 0)                                */
#define SPI_SLAVE_OCPM_BUFF_ACTIVE_WR_BUFF_ACTIVE_Msk (0x1UL)       /*!< WR_BUFF_ACTIVE (Bitfield-Mask: 0x01)                  */
/* ====================================================  OCPM_WR_BD_ADDR  ==================================================== */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_WR_BD_ADDR_Pos (0UL)              /*!< WR_BD_ADDR (Bit 0)                                    */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_WR_BD_ADDR_Msk (0xffffffffUL)     /*!< WR_BD_ADDR (Bitfield-Mask: 0xffffffff)                */
/* ====================================================  OCPM_WR_BD_SIZE  ==================================================== */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_WR_BD_SIZE_Pos (0UL)              /*!< WR_BD_SIZE (Bit 0)                                    */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_WR_BD_SIZE_Msk (0xffffUL)         /*!< WR_BD_SIZE (Bitfield-Mask: 0xffff)                    */
/* ====================================================  OCPM_RD_BD_ADDR  ==================================================== */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_RD_BD_ADDR_Pos (0UL)              /*!< RD_BD_ADDR (Bit 0)                                    */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_RD_BD_ADDR_Msk (0xffffffffUL)     /*!< RD_BD_ADDR (Bitfield-Mask: 0xffffffff)                */
/* ====================================================  OCPM_RD_BD_SIZE  ==================================================== */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_RD_BD_SIZE_Pos (0UL)              /*!< RD_BD_SIZE (Bit 0)                                    */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_RD_BD_SIZE_Msk (0xffffUL)         /*!< RD_BD_SIZE (Bitfield-Mask: 0xffff)                    */
/* =================================================  OCPM_WR_BD_ADDR_STATE  ================================================= */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_FULL_Pos (25UL)        /*!< FIFO_FULL (Bit 25)                                    */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                       */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_EMPTY_Pos (24UL)       /*!< FIFO_EMPTY (Bit 24)                                   */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                     */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_WR_PTR_Pos (16UL)           /*!< WR_PTR (Bit 16)                                       */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_WR_PTR_Msk (0xf0000UL)      /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_RD_PTR_Pos (8UL)            /*!< RD_PTR (Bit 8)                                        */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_RD_PTR_Msk (0xf00UL)        /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_STATUS_Pos (0UL)       /*!< FIFO_STATUS (Bit 0)                                   */
#define SPI_SLAVE_OCPM_WR_BD_ADDR_STATE_FIFO_STATUS_Msk (0x1fUL)    /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_WR_BD_SIZE_STATE  ================================================= */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_FULL_Pos (25UL)        /*!< FIFO_FULL (Bit 25)                                    */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                       */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_EMPTY_Pos (24UL)       /*!< FIFO_EMPTY (Bit 24)                                   */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                     */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_WR_PTR_Pos (16UL)           /*!< WR_PTR (Bit 16)                                       */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_WR_PTR_Msk (0xf0000UL)      /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_RD_PTR_Pos (8UL)            /*!< RD_PTR (Bit 8)                                        */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_RD_PTR_Msk (0xf00UL)        /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_STATUS_Pos (0UL)       /*!< FIFO_STATUS (Bit 0)                                   */
#define SPI_SLAVE_OCPM_WR_BD_SIZE_STATE_FIFO_STATUS_Msk (0x1fUL)    /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_RD_BD_ADDR_STATE  ================================================= */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_FULL_Pos (25UL)        /*!< FIFO_FULL (Bit 25)                                    */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                       */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_EMPTY_Pos (24UL)       /*!< FIFO_EMPTY (Bit 24)                                   */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                     */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_WR_PTR_Pos (16UL)           /*!< WR_PTR (Bit 16)                                       */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_WR_PTR_Msk (0xf0000UL)      /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_RD_PTR_Pos (8UL)            /*!< RD_PTR (Bit 8)                                        */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_RD_PTR_Msk (0xf00UL)        /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_STATUS_Pos (0UL)       /*!< FIFO_STATUS (Bit 0)                                   */
#define SPI_SLAVE_OCPM_RD_BD_ADDR_STATE_FIFO_STATUS_Msk (0x1fUL)    /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* =================================================  OCPM_RD_BD_SIZE_STATE  ================================================= */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_FULL_Pos (25UL)        /*!< FIFO_FULL (Bit 25)                                    */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_FULL_Msk (0x2000000UL) /*!< FIFO_FULL (Bitfield-Mask: 0x01)                       */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_EMPTY_Pos (24UL)       /*!< FIFO_EMPTY (Bit 24)                                   */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_EMPTY_Msk (0x1000000UL) /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                     */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_WR_PTR_Pos (16UL)           /*!< WR_PTR (Bit 16)                                       */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_WR_PTR_Msk (0xf0000UL)      /*!< WR_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_RD_PTR_Pos (8UL)            /*!< RD_PTR (Bit 8)                                        */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_RD_PTR_Msk (0xf00UL)        /*!< RD_PTR (Bitfield-Mask: 0x0f)                          */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_STATUS_Pos (0UL)       /*!< FIFO_STATUS (Bit 0)                                   */
#define SPI_SLAVE_OCPM_RD_BD_SIZE_STATE_FIFO_STATUS_Msk (0x1fUL)    /*!< FIFO_STATUS (Bitfield-Mask: 0x1f)                     */
/* ===================================================  OCPM_BD_CFG_THRES  =================================================== */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_WR_BD_ADDR_THRES_Pos (24UL)     /*!< WR_BD_ADDR_THRES (Bit 24)                             */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_WR_BD_ADDR_THRES_Msk (0x1f000000UL) /*!< WR_BD_ADDR_THRES (Bitfield-Mask: 0x1f)            */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_WR_BD_SIZE_THRES_Pos (16UL)     /*!< WR_BD_SIZE_THRES (Bit 16)                             */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_WR_BD_SIZE_THRES_Msk (0x1f0000UL) /*!< WR_BD_SIZE_THRES (Bitfield-Mask: 0x1f)              */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_RD_BD_ADDR_THRES_Pos (8UL)      /*!< RD_BD_ADDR_THRES (Bit 8)                              */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_RD_BD_ADDR_THRES_Msk (0x1f00UL) /*!< RD_BD_ADDR_THRES (Bitfield-Mask: 0x1f)                */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_RD_BD_SIZE_THRES_Pos (0UL)      /*!< RD_BD_SIZE_THRES (Bit 0)                              */
#define SPI_SLAVE_OCPM_BD_CFG_THRES_RD_BD_SIZE_THRES_Msk (0x1fUL)   /*!< RD_BD_SIZE_THRES (Bitfield-Mask: 0x1f)                */
/* ==================================================  OCPM_OCP_LEN_STATUS  ================================================== */
#define SPI_SLAVE_OCPM_OCP_LEN_STATUS_OCP_WR_LEN_CNT_Pos (16UL)     /*!< OCP_WR_LEN_CNT (Bit 16)                               */
#define SPI_SLAVE_OCPM_OCP_LEN_STATUS_OCP_WR_LEN_CNT_Msk (0xffff0000UL) /*!< OCP_WR_LEN_CNT (Bitfield-Mask: 0xffff)            */
#define SPI_SLAVE_OCPM_OCP_LEN_STATUS_OCP_RD_LEN_CNT_Pos (0UL)      /*!< OCP_RD_LEN_CNT (Bit 0)                                */
#define SPI_SLAVE_OCPM_OCP_LEN_STATUS_OCP_RD_LEN_CNT_Msk (0xffffUL) /*!< OCP_RD_LEN_CNT (Bitfield-Mask: 0xffff)                */
/* =================================================  OCPM_BUF_FIFO_STATUS  ================================================== */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_WR_PTR_Pos (28UL) /*!< OCPM_MISO_FIFO_WR_PTR (Bit 28)                    */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_WR_PTR_Msk (0x70000000UL) /*!< OCPM_MISO_FIFO_WR_PTR (Bitfield-Mask: 0x07) */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_RD_PTR_Pos (24UL) /*!< OCPM_MISO_FIFO_RD_PTR (Bit 24)                    */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_RD_PTR_Msk (0x7000000UL) /*!< OCPM_MISO_FIFO_RD_PTR (Bitfield-Mask: 0x07) */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_STATUS_Pos (16UL) /*!< OCPM_MISO_FIFO_STATUS (Bit 16)                    */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MISO_FIFO_STATUS_Msk (0xf0000UL) /*!< OCPM_MISO_FIFO_STATUS (Bitfield-Mask: 0x0f)  */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_WR_PTR_Pos (12UL) /*!< OCPM_MOSI_FIFO_WR_PTR (Bit 12)                    */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_WR_PTR_Msk (0x7000UL) /*!< OCPM_MOSI_FIFO_WR_PTR (Bitfield-Mask: 0x07)   */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_RD_PTR_Pos (8UL) /*!< OCPM_MOSI_FIFO_RD_PTR (Bit 8)                      */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_RD_PTR_Msk (0x700UL) /*!< OCPM_MOSI_FIFO_RD_PTR (Bitfield-Mask: 0x07)    */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_STATUS_Pos (0UL) /*!< OCPM_MOSI_FIFO_STATUS (Bit 0)                      */
#define SPI_SLAVE_OCPM_BUF_FIFO_STATUS_OCPM_MOSI_FIFO_STATUS_Msk (0xfUL) /*!< OCPM_MOSI_FIFO_STATUS (Bitfield-Mask: 0x0f)      */
/* ====================================================  OCPM_RD_ERR_INT  ==================================================== */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MISO_BUFFER_OVERFLOW_Pos (11UL) /*!< OCPM_MISO_BUFFER_OVERFLOW (Bit 11)                 */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MISO_BUFFER_OVERFLOW_Msk (0x800UL) /*!< OCPM_MISO_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MISO_BUFFER_UNDERFLOW_Pos (10UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW (Bit 10)               */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MISO_BUFFER_UNDERFLOW_Msk (0x400UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MOSI_BUFFER_OVERFLOW_Pos (9UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW (Bit 9)                   */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MOSI_BUFFER_OVERFLOW_Msk (0x200UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MOSI_BUFFER_UNDERFLOW_Pos (8UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW (Bit 8)                 */
#define SPI_SLAVE_OCPM_RD_ERR_INT_OCPM_MOSI_BUFFER_UNDERFLOW_Msk (0x100UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_ADDR_OVERFLOW_Pos (7UL)     /*!< RD_BD_ADDR_OVERFLOW (Bit 7)                           */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_ADDR_OVERFLOW_Msk (0x80UL)  /*!< RD_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_ADDR_UNDERFLOW_Pos (6UL)    /*!< RD_BD_ADDR_UNDERFLOW (Bit 6)                          */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_ADDR_UNDERFLOW_Msk (0x40UL) /*!< RD_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01)            */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_SIZE_OVERFLOW_Pos (5UL)     /*!< RD_BD_SIZE_OVERFLOW (Bit 5)                           */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_SIZE_OVERFLOW_Msk (0x20UL)  /*!< RD_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_SIZE_UNDERFLOW_Pos (4UL)    /*!< RD_BD_SIZE_UNDERFLOW (Bit 4)                          */
#define SPI_SLAVE_OCPM_RD_ERR_INT_RD_BD_SIZE_UNDERFLOW_Msk (0x10UL) /*!< RD_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01)            */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_ADDR_OVERFLOW_Pos (3UL)     /*!< WR_BD_ADDR_OVERFLOW (Bit 3)                           */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_ADDR_OVERFLOW_Msk (0x8UL)   /*!< WR_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_ADDR_UNDERFLOW_Pos (2UL)    /*!< WR_BD_ADDR_UNDERFLOW (Bit 2)                          */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_ADDR_UNDERFLOW_Msk (0x4UL)  /*!< WR_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01)            */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_SIZE_OVERFLOW_Pos (1UL)     /*!< WR_BD_SIZE_OVERFLOW (Bit 1)                           */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_SIZE_OVERFLOW_Msk (0x2UL)   /*!< WR_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)             */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_SIZE_UNDERFLOW_Pos (0UL)    /*!< WR_BD_SIZE_UNDERFLOW (Bit 0)                          */
#define SPI_SLAVE_OCPM_RD_ERR_INT_WR_BD_SIZE_UNDERFLOW_Msk (0x1UL)  /*!< WR_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01)            */
/* ==================================================  OCPM_RD_CLR_ERR_INT  ================================================== */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MISO_BUFFER_OVERFLOW_Pos (11UL) /*!< OCPM_MISO_BUFFER_OVERFLOW (Bit 11)             */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MISO_BUFFER_OVERFLOW_Msk (0x800UL) /*!< OCPM_MISO_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MISO_BUFFER_UNDERFLOW_Pos (10UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW (Bit 10)           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MISO_BUFFER_UNDERFLOW_Msk (0x400UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MOSI_BUFFER_OVERFLOW_Pos (9UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW (Bit 9)               */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MOSI_BUFFER_OVERFLOW_Msk (0x200UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MOSI_BUFFER_UNDERFLOW_Pos (8UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW (Bit 8)             */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_OCPM_MOSI_BUFFER_UNDERFLOW_Msk (0x100UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_ADDR_OVERFLOW_Pos (7UL) /*!< RD_BD_ADDR_OVERFLOW (Bit 7)                           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_ADDR_OVERFLOW_Msk (0x80UL) /*!< RD_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)          */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_ADDR_UNDERFLOW_Pos (6UL) /*!< RD_BD_ADDR_UNDERFLOW (Bit 6)                         */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_ADDR_UNDERFLOW_Msk (0x40UL) /*!< RD_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01)        */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_SIZE_OVERFLOW_Pos (5UL) /*!< RD_BD_SIZE_OVERFLOW (Bit 5)                           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_SIZE_OVERFLOW_Msk (0x20UL) /*!< RD_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)          */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_SIZE_UNDERFLOW_Pos (4UL) /*!< RD_BD_SIZE_UNDERFLOW (Bit 4)                         */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_RD_BD_SIZE_UNDERFLOW_Msk (0x10UL) /*!< RD_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01)        */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_ADDR_OVERFLOW_Pos (3UL) /*!< WR_BD_ADDR_OVERFLOW (Bit 3)                           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_ADDR_OVERFLOW_Msk (0x8UL) /*!< WR_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_ADDR_UNDERFLOW_Pos (2UL) /*!< WR_BD_ADDR_UNDERFLOW (Bit 2)                         */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_ADDR_UNDERFLOW_Msk (0x4UL) /*!< WR_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01)         */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_SIZE_OVERFLOW_Pos (1UL) /*!< WR_BD_SIZE_OVERFLOW (Bit 1)                           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_SIZE_OVERFLOW_Msk (0x2UL) /*!< WR_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)           */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_SIZE_UNDERFLOW_Pos (0UL) /*!< WR_BD_SIZE_UNDERFLOW (Bit 0)                         */
#define SPI_SLAVE_OCPM_RD_CLR_ERR_INT_WR_BD_SIZE_UNDERFLOW_Msk (0x1UL) /*!< WR_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01)         */
/* ===================================================  OCPM_MASK_ERR_INT  =================================================== */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MISO_BUFFER_OVERFLOW_Pos (11UL) /*!< MASK_OCPM_MISO_BUFFER_OVERFLOW (Bit 11)     */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MISO_BUFFER_OVERFLOW_Msk (0x800UL) /*!< MASK_OCPM_MISO_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MISO_BUFFER_UNDERFLOW_Pos (10UL) /*!< MASK_OCPM_MISO_BUFFER_UNDERFLOW (Bit 10)   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MISO_BUFFER_UNDERFLOW_Msk (0x400UL) /*!< MASK_OCPM_MISO_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MOSI_BUFFER_OVERFLOW_Pos (9UL) /*!< MASK_OCPM_MOSI_BUFFER_OVERFLOW (Bit 9)       */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MOSI_BUFFER_OVERFLOW_Msk (0x200UL) /*!< MASK_OCPM_MOSI_BUFFER_OVERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MOSI_BUFFER_UNDERFLOW_Pos (8UL) /*!< MASK_OCPM_MOSI_BUFFER_UNDERFLOW (Bit 8)     */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_OCPM_MOSI_BUFFER_UNDERFLOW_Msk (0x100UL) /*!< MASK_OCPM_MOSI_BUFFER_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_ADDR_OVERFLOW_Pos (7UL) /*!< MASK_RD_BD_ADDR_OVERFLOW (Bit 7)                   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_ADDR_OVERFLOW_Msk (0x80UL) /*!< MASK_RD_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)  */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_ADDR_UNDERFLOW_Pos (6UL) /*!< MASK_RD_BD_ADDR_UNDERFLOW (Bit 6)                 */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_ADDR_UNDERFLOW_Msk (0x40UL) /*!< MASK_RD_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_SIZE_OVERFLOW_Pos (5UL) /*!< MASK_RD_BD_SIZE_OVERFLOW (Bit 5)                   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_SIZE_OVERFLOW_Msk (0x20UL) /*!< MASK_RD_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)  */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_SIZE_UNDERFLOW_Pos (4UL) /*!< MASK_RD_BD_SIZE_UNDERFLOW (Bit 4)                 */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_RD_BD_SIZE_UNDERFLOW_Msk (0x10UL) /*!< MASK_RD_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_ADDR_OVERFLOW_Pos (3UL) /*!< MASK_WR_BD_ADDR_OVERFLOW (Bit 3)                   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_ADDR_OVERFLOW_Msk (0x8UL) /*!< MASK_WR_BD_ADDR_OVERFLOW (Bitfield-Mask: 0x01)   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_ADDR_UNDERFLOW_Pos (2UL) /*!< MASK_WR_BD_ADDR_UNDERFLOW (Bit 2)                 */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_ADDR_UNDERFLOW_Msk (0x4UL) /*!< MASK_WR_BD_ADDR_UNDERFLOW (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_SIZE_OVERFLOW_Pos (1UL) /*!< MASK_WR_BD_SIZE_OVERFLOW (Bit 1)                   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_SIZE_OVERFLOW_Msk (0x2UL) /*!< MASK_WR_BD_SIZE_OVERFLOW (Bitfield-Mask: 0x01)   */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_SIZE_UNDERFLOW_Pos (0UL) /*!< MASK_WR_BD_SIZE_UNDERFLOW (Bit 0)                 */
#define SPI_SLAVE_OCPM_MASK_ERR_INT_MASK_WR_BD_SIZE_UNDERFLOW_Msk (0x1UL) /*!< MASK_WR_BD_SIZE_UNDERFLOW (Bitfield-Mask: 0x01) */
/* ====================================================  OCPM_ERR_INT_EN  ==================================================== */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN_Pos (11UL) /*!< OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN (Bit 11) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN_Msk (0x800UL) /*!< OCPM_MISO_BUFFER_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN_Pos (10UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN (Bit 10) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN_Msk (0x400UL) /*!< OCPM_MISO_BUFFER_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN_Pos (9UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN (Bit 9) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN_Msk (0x200UL) /*!< OCPM_MOSI_BUFFER_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN_Pos (8UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN (Bit 8) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN_Msk (0x100UL) /*!< OCPM_MOSI_BUFFER_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_ADDR_OVERFLOW_ERR_INT_EN_Pos (7UL) /*!< RD_BD_ADDR_OVERFLOW_ERR_INT_EN (Bit 7)         */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_ADDR_OVERFLOW_ERR_INT_EN_Msk (0x80UL) /*!< RD_BD_ADDR_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_ADDR_UNDERFLOW_ERR_INT_EN_Pos (6UL) /*!< RD_BD_ADDR_UNDERFLOW_ERR_INT_EN (Bit 6)       */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_ADDR_UNDERFLOW_ERR_INT_EN_Msk (0x40UL) /*!< RD_BD_ADDR_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_SIZE_OVERFLOW_ERR_INT_EN_Pos (5UL) /*!< RD_BD_SIZE_OVERFLOW_ERR_INT_EN (Bit 5)         */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_SIZE_OVERFLOW_ERR_INT_EN_Msk (0x20UL) /*!< RD_BD_SIZE_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_SIZE_UNDERFLOW_ERR_INT_EN_Pos (4UL) /*!< RD_BD_SIZE_UNDERFLOW_ERR_INT_EN (Bit 4)       */
#define SPI_SLAVE_OCPM_ERR_INT_EN_RD_BD_SIZE_UNDERFLOW_ERR_INT_EN_Msk (0x10UL) /*!< RD_BD_SIZE_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_ADDR_OVERFLOW_ERR_INT_EN_Pos (3UL) /*!< WR_BD_ADDR_OVERFLOW_ERR_INT_EN (Bit 3)         */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_ADDR_OVERFLOW_ERR_INT_EN_Msk (0x8UL) /*!< WR_BD_ADDR_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_ADDR_UNDERFLOW_ERR_INT_EN_Pos (2UL) /*!< WR_BD_ADDR_UNDERFLOW_ERR_INT_EN (Bit 2)       */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_ADDR_UNDERFLOW_ERR_INT_EN_Msk (0x4UL) /*!< WR_BD_ADDR_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_SIZE_OVERFLOW_ERR_INT_EN_Pos (1UL) /*!< WR_BD_SIZE_OVERFLOW_ERR_INT_EN (Bit 1)         */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_SIZE_OVERFLOW_ERR_INT_EN_Msk (0x2UL) /*!< WR_BD_SIZE_OVERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_SIZE_UNDERFLOW_ERR_INT_EN_Pos (0UL) /*!< WR_BD_SIZE_UNDERFLOW_ERR_INT_EN (Bit 0)       */
#define SPI_SLAVE_OCPM_ERR_INT_EN_WR_BD_SIZE_UNDERFLOW_ERR_INT_EN_Msk (0x1UL) /*!< WR_BD_SIZE_UNDERFLOW_ERR_INT_EN (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         I2C_CTRL                                          ================ */
/* =========================================================================================================================== */

/* =======================================================  CMD_FIFO  ======================================================== */
#define I2C0_CTRL_CMD_FIFO_ADDRESS_Pos    (8UL)                     /*!< ADDRESS (Bit 8)                                       */
#define I2C0_CTRL_CMD_FIFO_ADDRESS_Msk    (0xffffff00UL)            /*!< ADDRESS (Bitfield-Mask: 0xffffff)                     */
#define I2C0_CTRL_CMD_FIFO_RW_Pos         (7UL)                     /*!< RW (Bit 7)                                            */
#define I2C0_CTRL_CMD_FIFO_RW_Msk         (0x80UL)                  /*!< RW (Bitfield-Mask: 0x01)                              */
#define I2C0_CTRL_CMD_FIFO_EN_INT_DONE_Pos (6UL)                    /*!< EN_INT_DONE (Bit 6)                                   */
#define I2C0_CTRL_CMD_FIFO_EN_INT_DONE_Msk (0x40UL)                 /*!< EN_INT_DONE (Bitfield-Mask: 0x01)                     */
#define I2C0_CTRL_CMD_FIFO_COMMAND_Pos    (0UL)                     /*!< COMMAND (Bit 0)                                       */
#define I2C0_CTRL_CMD_FIFO_COMMAND_Msk    (0x3fUL)                  /*!< COMMAND (Bitfield-Mask: 0x3f)                         */
/* ======================================================  WDATA_FIFO  ======================================================= */
#define I2C0_CTRL_WDATA_FIFO_WDATA_Pos    (0UL)                     /*!< WDATA (Bit 0)                                         */
#define I2C0_CTRL_WDATA_FIFO_WDATA_Msk    (0xffffffffUL)            /*!< WDATA (Bitfield-Mask: 0xffffffff)                     */
/* ======================================================  RDATA_FIFO  ======================================================= */
#define I2C0_CTRL_RDATA_FIFO_RDATA_Pos    (0UL)                     /*!< RDATA (Bit 0)                                         */
#define I2C0_CTRL_RDATA_FIFO_RDATA_Msk    (0xffffffffUL)            /*!< RDATA (Bitfield-Mask: 0xffffffff)                     */
/* ====================================================  CMD_FIFO_STATUS  ==================================================== */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_FIFO_FULL_Pos (31UL)          /*!< CMD_FIFO_FULL (Bit 31)                                */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_FIFO_FULL_Msk (0x80000000UL)  /*!< CMD_FIFO_FULL (Bitfield-Mask: 0x01)                   */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_STATUS_Pos (16UL)             /*!< CMD_STATUS (Bit 16)                                   */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_STATUS_Msk (0x1f0000UL)       /*!< CMD_STATUS (Bitfield-Mask: 0x1f)                      */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_RP_Pos (8UL)                  /*!< CMD_RP (Bit 8)                                        */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_RP_Msk (0xf00UL)              /*!< CMD_RP (Bitfield-Mask: 0x0f)                          */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_WP_Pos (0UL)                  /*!< CMD_WP (Bit 0)                                        */
#define I2C0_CTRL_CMD_FIFO_STATUS_CMD_WP_Msk (0xfUL)                /*!< CMD_WP (Bitfield-Mask: 0x0f)                          */
/* ===================================================  WDATA_FIFO_STATUS  =================================================== */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_FIFO_EMPTY_Pos (31UL)     /*!< WDATA_FIFO_EMPTY (Bit 31)                             */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_FIFO_EMPTY_Msk (0x80000000UL) /*!< WDATA_FIFO_EMPTY (Bitfield-Mask: 0x01)            */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_STATUS_Pos (16UL)         /*!< WDATA_STATUS (Bit 16)                                 */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_STATUS_Msk (0x7f0000UL)   /*!< WDATA_STATUS (Bitfield-Mask: 0x7f)                    */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_RP_Pos (8UL)              /*!< WDATA_RP (Bit 8)                                      */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_RP_Msk (0x3f00UL)         /*!< WDATA_RP (Bitfield-Mask: 0x3f)                        */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_WP_Pos (0UL)              /*!< WDATA_WP (Bit 0)                                      */
#define I2C0_CTRL_WDATA_FIFO_STATUS_WDATA_WP_Msk (0x3fUL)           /*!< WDATA_WP (Bitfield-Mask: 0x3f)                        */
/* ===================================================  RDATA_FIFO_STATUS  =================================================== */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_FIFO_FULL_Pos (31UL)      /*!< RDATA_FIFO_FULL (Bit 31)                              */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_FIFO_FULL_Msk (0x80000000UL) /*!< RDATA_FIFO_FULL (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_STATUS_Pos (16UL)         /*!< RDATA_STATUS (Bit 16)                                 */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_STATUS_Msk (0x7f0000UL)   /*!< RDATA_STATUS (Bitfield-Mask: 0x7f)                    */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_RP_Pos (8UL)              /*!< RDATA_RP (Bit 8)                                      */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_RP_Msk (0x3f00UL)         /*!< RDATA_RP (Bitfield-Mask: 0x3f)                        */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_WP_Pos (0UL)              /*!< RDATA_WP (Bit 0)                                      */
#define I2C0_CTRL_RDATA_FIFO_STATUS_RDATA_WP_Msk (0x3fUL)           /*!< RDATA_WP (Bitfield-Mask: 0x3f)                        */
/* =====================================================  LAST_EXE_CMD  ====================================================== */
#define I2C0_CTRL_LAST_EXE_CMD_ADDRESS_Pos (8UL)                    /*!< ADDRESS (Bit 8)                                       */
#define I2C0_CTRL_LAST_EXE_CMD_ADDRESS_Msk (0xffffff00UL)           /*!< ADDRESS (Bitfield-Mask: 0xffffff)                     */
#define I2C0_CTRL_LAST_EXE_CMD_RW_Pos     (7UL)                     /*!< RW (Bit 7)                                            */
#define I2C0_CTRL_LAST_EXE_CMD_RW_Msk     (0x80UL)                  /*!< RW (Bitfield-Mask: 0x01)                              */
#define I2C0_CTRL_LAST_EXE_CMD_EN_INT_DONE_Pos (6UL)                /*!< EN_INT_DONE (Bit 6)                                   */
#define I2C0_CTRL_LAST_EXE_CMD_EN_INT_DONE_Msk (0x40UL)             /*!< EN_INT_DONE (Bitfield-Mask: 0x01)                     */
#define I2C0_CTRL_LAST_EXE_CMD_COMMAND_Pos (0UL)                    /*!< COMMAND (Bit 0)                                       */
#define I2C0_CTRL_LAST_EXE_CMD_COMMAND_Msk (0x3fUL)                 /*!< COMMAND (Bitfield-Mask: 0x3f)                         */
/* =====================================================  MAIN_CTRL_CFG  ===================================================== */
#define I2C0_CTRL_MAIN_CTRL_CFG_BASIC_I2C_Pos (31UL)                /*!< BASIC_I2C (Bit 31)                                    */
#define I2C0_CTRL_MAIN_CTRL_CFG_BASIC_I2C_Msk (0x80000000UL)        /*!< BASIC_I2C (Bitfield-Mask: 0x01)                       */
#define I2C0_CTRL_MAIN_CTRL_CFG_WP_Pos    (30UL)                    /*!< WP (Bit 30)                                           */
#define I2C0_CTRL_MAIN_CTRL_CFG_WP_Msk    (0x40000000UL)            /*!< WP (Bitfield-Mask: 0x01)                              */
#define I2C0_CTRL_MAIN_CTRL_CFG_DRIVE_SDA_HIGH_EN_Pos (29UL)        /*!< DRIVE_SDA_HIGH_EN (Bit 29)                            */
#define I2C0_CTRL_MAIN_CTRL_CFG_DRIVE_SDA_HIGH_EN_Msk (0x20000000UL) /*!< DRIVE_SDA_HIGH_EN (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_MAIN_CTRL_CFG_DRIVE_SCL_HIGH_EN_Pos (28UL)        /*!< DRIVE_SCL_HIGH_EN (Bit 28)                            */
#define I2C0_CTRL_MAIN_CTRL_CFG_DRIVE_SCL_HIGH_EN_Msk (0x10000000UL) /*!< DRIVE_SCL_HIGH_EN (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_MAIN_CTRL_CFG_SCL_STRETCH_EN_Pos (24UL)           /*!< SCL_STRETCH_EN (Bit 24)                               */
#define I2C0_CTRL_MAIN_CTRL_CFG_SCL_STRETCH_EN_Msk (0x1000000UL)    /*!< SCL_STRETCH_EN (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_MAIN_CTRL_CFG_ENABLE_MULTI_MASTER_Pos (16UL)      /*!< ENABLE_MULTI_MASTER (Bit 16)                          */
#define I2C0_CTRL_MAIN_CTRL_CFG_ENABLE_MULTI_MASTER_Msk (0x10000UL) /*!< ENABLE_MULTI_MASTER (Bitfield-Mask: 0x01)             */
#define I2C0_CTRL_MAIN_CTRL_CFG_ENDIAN_SWAP_EN_Pos (14UL)           /*!< ENDIAN_SWAP_EN (Bit 14)                               */
#define I2C0_CTRL_MAIN_CTRL_CFG_ENDIAN_SWAP_EN_Msk (0x4000UL)       /*!< ENDIAN_SWAP_EN (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_MAIN_CTRL_CFG_I2C_IO_SEL_Pos (13UL)               /*!< I2C_IO_SEL (Bit 13)                                   */
#define I2C0_CTRL_MAIN_CTRL_CFG_I2C_IO_SEL_Msk (0x2000UL)           /*!< I2C_IO_SEL (Bitfield-Mask: 0x01)                      */
#define I2C0_CTRL_MAIN_CTRL_CFG_ADD_LEN_Pos (11UL)                  /*!< ADD_LEN (Bit 11)                                      */
#define I2C0_CTRL_MAIN_CTRL_CFG_ADD_LEN_Msk (0x1800UL)              /*!< ADD_LEN (Bitfield-Mask: 0x03)                         */
#define I2C0_CTRL_MAIN_CTRL_CFG_TEN_BIT_DEVICE_SEL_Pos (10UL)       /*!< TEN_BIT_DEVICE_SEL (Bit 10)                           */
#define I2C0_CTRL_MAIN_CTRL_CFG_TEN_BIT_DEVICE_SEL_Msk (0x400UL)    /*!< TEN_BIT_DEVICE_SEL (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_MAIN_CTRL_CFG_DEVICE_SEL_Pos (0UL)                /*!< DEVICE_SEL (Bit 0)                                    */
#define I2C0_CTRL_MAIN_CTRL_CFG_DEVICE_SEL_Msk (0x3ffUL)            /*!< DEVICE_SEL (Bitfield-Mask: 0x3ff)                     */
/* =====================================================  COUNTER1_CFG  ====================================================== */
#define I2C0_CTRL_COUNTER1_CFG_COUNT_RECOVERY_Pos (16UL)            /*!< COUNT_RECOVERY (Bit 16)                               */
#define I2C0_CTRL_COUNTER1_CFG_COUNT_RECOVERY_Msk (0xffff0000UL)    /*!< COUNT_RECOVERY (Bitfield-Mask: 0xffff)                */
#define I2C0_CTRL_COUNTER1_CFG_COUNT_DIVIDE_Pos (0UL)               /*!< COUNT_DIVIDE (Bit 0)                                  */
#define I2C0_CTRL_COUNTER1_CFG_COUNT_DIVIDE_Msk (0xffffUL)          /*!< COUNT_DIVIDE (Bitfield-Mask: 0xffff)                  */
/* =====================================================  COUNTER2_CFG  ====================================================== */
#define I2C0_CTRL_COUNTER2_CFG_COUNT_R2T_Pos (16UL)                 /*!< COUNT_R2T (Bit 16)                                    */
#define I2C0_CTRL_COUNTER2_CFG_COUNT_R2T_Msk (0xffff0000UL)         /*!< COUNT_R2T (Bitfield-Mask: 0xffff)                     */
#define I2C0_CTRL_COUNTER2_CFG_COUNT_T2R_Pos (0UL)                  /*!< COUNT_T2R (Bit 0)                                     */
#define I2C0_CTRL_COUNTER2_CFG_COUNT_T2R_Msk (0xffffUL)             /*!< COUNT_T2R (Bitfield-Mask: 0xffff)                     */
/* =====================================================  COUNTER3_CFG  ====================================================== */
#define I2C0_CTRL_COUNTER3_CFG_COUNT_START_SETUP_Pos (16UL)         /*!< COUNT_START_SETUP (Bit 16)                            */
#define I2C0_CTRL_COUNTER3_CFG_COUNT_START_SETUP_Msk (0xffff0000UL) /*!< COUNT_START_SETUP (Bitfield-Mask: 0xffff)             */
#define I2C0_CTRL_COUNTER3_CFG_COUNT_START_HOLD_Pos (0UL)           /*!< COUNT_START_HOLD (Bit 0)                              */
#define I2C0_CTRL_COUNTER3_CFG_COUNT_START_HOLD_Msk (0xffffUL)      /*!< COUNT_START_HOLD (Bitfield-Mask: 0xffff)              */
/* =====================================================  COUNTER4_CFG  ====================================================== */
#define I2C0_CTRL_COUNTER4_CFG_DUTY_CYCLE_Pos (16UL)                /*!< DUTY_CYCLE (Bit 16)                                   */
#define I2C0_CTRL_COUNTER4_CFG_DUTY_CYCLE_Msk (0xffff0000UL)        /*!< DUTY_CYCLE (Bitfield-Mask: 0xffff)                    */
#define I2C0_CTRL_COUNTER4_CFG_COUNT_STOP_SETUP_Pos (0UL)           /*!< COUNT_STOP_SETUP (Bit 0)                              */
#define I2C0_CTRL_COUNTER4_CFG_COUNT_STOP_SETUP_Msk (0xffffUL)      /*!< COUNT_STOP_SETUP (Bitfield-Mask: 0xffff)              */
/* =======================================================  FLUSH_CFG  ======================================================= */
#define I2C0_CTRL_FLUSH_CFG_SM_RESET_Pos  (24UL)                    /*!< SM_RESET (Bit 24)                                     */
#define I2C0_CTRL_FLUSH_CFG_SM_RESET_Msk  (0x1000000UL)             /*!< SM_RESET (Bitfield-Mask: 0x01)                        */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_CMD_Pos (16UL)                    /*!< FLUSH_CMD (Bit 16)                                    */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_CMD_Msk (0x10000UL)               /*!< FLUSH_CMD (Bitfield-Mask: 0x01)                       */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_WDATA_Pos (8UL)                   /*!< FLUSH_WDATA (Bit 8)                                   */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_WDATA_Msk (0x100UL)               /*!< FLUSH_WDATA (Bitfield-Mask: 0x01)                     */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_RDATA_Pos (0UL)                   /*!< FLUSH_RDATA (Bit 0)                                   */
#define I2C0_CTRL_FLUSH_CFG_FLUSH_RDATA_Msk (0x1UL)                 /*!< FLUSH_RDATA (Bitfield-Mask: 0x01)                     */
/* =====================================================  INTERRUPT_CFG  ===================================================== */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVERFLOW_Pos (31UL)           /*!< M_CMD_OVERFLOW (Bit 31)                               */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVERFLOW_Msk (0x80000000UL)   /*!< M_CMD_OVERFLOW (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_INTERRUPT_CFG_M_WDATA_OVERFLOW_Pos (30UL)         /*!< M_WDATA_OVERFLOW (Bit 30)                             */
#define I2C0_CTRL_INTERRUPT_CFG_M_WDATA_OVERFLOW_Msk (0x40000000UL) /*!< M_WDATA_OVERFLOW (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_CFG_M_RDATA_UNDERFLOW_Pos (29UL)        /*!< M_RDATA_UNDERFLOW (Bit 29)                            */
#define I2C0_CTRL_INTERRUPT_CFG_M_RDATA_UNDERFLOW_Msk (0x20000000UL) /*!< M_RDATA_UNDERFLOW (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_INTERRUPT_CFG_M_NACK_ERR_Pos (28UL)               /*!< M_NACK_ERR (Bit 28)                                   */
#define I2C0_CTRL_INTERRUPT_CFG_M_NACK_ERR_Msk (0x10000000UL)       /*!< M_NACK_ERR (Bitfield-Mask: 0x01)                      */
#define I2C0_CTRL_INTERRUPT_CFG_M_DONE_Pos (27UL)                   /*!< M_DONE (Bit 27)                                       */
#define I2C0_CTRL_INTERRUPT_CFG_M_DONE_Msk (0x8000000UL)            /*!< M_DONE (Bitfield-Mask: 0x01)                          */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_Pos (26UL)                    /*!< M_CMD (Bit 26)                                        */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_Msk (0x4000000UL)             /*!< M_CMD (Bitfield-Mask: 0x01)                           */
#define I2C0_CTRL_INTERRUPT_CFG_M_WDATA_Pos (25UL)                  /*!< M_WDATA (Bit 25)                                      */
#define I2C0_CTRL_INTERRUPT_CFG_M_WDATA_Msk (0x2000000UL)           /*!< M_WDATA (Bitfield-Mask: 0x01)                         */
#define I2C0_CTRL_INTERRUPT_CFG_M_RDATA_Pos (24UL)                  /*!< M_RDATA (Bit 24)                                      */
#define I2C0_CTRL_INTERRUPT_CFG_M_RDATA_Msk (0x1000000UL)           /*!< M_RDATA (Bitfield-Mask: 0x01)                         */
#define I2C0_CTRL_INTERRUPT_CFG_M_DATA_OVER_NO_CMD_Pos (23UL)       /*!< M_DATA_OVER_NO_CMD (Bit 23)                           */
#define I2C0_CTRL_INTERRUPT_CFG_M_DATA_OVER_NO_CMD_Msk (0x800000UL) /*!< M_DATA_OVER_NO_CMD (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_INTERRUPT_CFG_M_DATA_UNDER_NO_CMD_Pos (22UL)      /*!< M_DATA_UNDER_NO_CMD (Bit 22)                          */
#define I2C0_CTRL_INTERRUPT_CFG_M_DATA_UNDER_NO_CMD_Msk (0x400000UL) /*!< M_DATA_UNDER_NO_CMD (Bitfield-Mask: 0x01)            */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVER_NO_WDATA_Pos (21UL)      /*!< M_CMD_OVER_NO_WDATA (Bit 21)                          */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVER_NO_WDATA_Msk (0x200000UL) /*!< M_CMD_OVER_NO_WDATA (Bitfield-Mask: 0x01)            */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVER_NO_SPACE_RDATA_Pos (20UL) /*!< M_CMD_OVER_NO_SPACE_RDATA (Bit 20)                   */
#define I2C0_CTRL_INTERRUPT_CFG_M_CMD_OVER_NO_SPACE_RDATA_Msk (0x100000UL) /*!< M_CMD_OVER_NO_SPACE_RDATA (Bitfield-Mask: 0x01) */
#define I2C0_CTRL_INTERRUPT_CFG_CMD_S_INT_Pos (15UL)                /*!< CMD_S_INT (Bit 15)                                    */
#define I2C0_CTRL_INTERRUPT_CFG_CMD_S_INT_Msk (0xf8000UL)           /*!< CMD_S_INT (Bitfield-Mask: 0x1f)                       */
#define I2C0_CTRL_INTERRUPT_CFG_WDATA_S_INT_Pos (8UL)               /*!< WDATA_S_INT (Bit 8)                                   */
#define I2C0_CTRL_INTERRUPT_CFG_WDATA_S_INT_Msk (0x7f00UL)          /*!< WDATA_S_INT (Bitfield-Mask: 0x7f)                     */
#define I2C0_CTRL_INTERRUPT_CFG_M_LINE_ABORT_Pos (7UL)              /*!< M_LINE_ABORT (Bit 7)                                  */
#define I2C0_CTRL_INTERRUPT_CFG_M_LINE_ABORT_Msk (0x80UL)           /*!< M_LINE_ABORT (Bitfield-Mask: 0x01)                    */
#define I2C0_CTRL_INTERRUPT_CFG_RDATA_S_INT_Pos (0UL)               /*!< RDATA_S_INT (Bit 0)                                   */
#define I2C0_CTRL_INTERRUPT_CFG_RDATA_S_INT_Msk (0x7fUL)            /*!< RDATA_S_INT (Bitfield-Mask: 0x7f)                     */
/* ===================================================  INTERRUPT_STATUS  ==================================================== */
#define I2C0_CTRL_INTERRUPT_STATUS_LINE_ABORT_C_INT_Pos (12UL)      /*!< LINE_ABORT_C_INT (Bit 12)                             */
#define I2C0_CTRL_INTERRUPT_STATUS_LINE_ABORT_C_INT_Msk (0x1000UL)  /*!< LINE_ABORT_C_INT (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_STATUS_DATA_OVER_NO_CMD_C_INT_Pos (11UL) /*!< DATA_OVER_NO_CMD_C_INT (Bit 11)                      */
#define I2C0_CTRL_INTERRUPT_STATUS_DATA_OVER_NO_CMD_C_INT_Msk (0x800UL) /*!< DATA_OVER_NO_CMD_C_INT (Bitfield-Mask: 0x01)      */
#define I2C0_CTRL_INTERRUPT_STATUS_DATA_UNDER_NO_CMD_C_INT_Pos (10UL) /*!< DATA_UNDER_NO_CMD_C_INT (Bit 10)                    */
#define I2C0_CTRL_INTERRUPT_STATUS_DATA_UNDER_NO_CMD_C_INT_Msk (0x400UL) /*!< DATA_UNDER_NO_CMD_C_INT (Bitfield-Mask: 0x01)    */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_NO_WDATA_C_INT_Pos (9UL) /*!< CMD_OVER_NO_WDATA_C_INT (Bit 9)                      */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_NO_WDATA_C_INT_Msk (0x200UL) /*!< CMD_OVER_NO_WDATA_C_INT (Bitfield-Mask: 0x01)    */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_NO_SPACE_RDATA_C_INT_Pos (8UL) /*!< CMD_OVER_NO_SPACE_RDATA_C_INT (Bit 8)          */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_NO_SPACE_RDATA_C_INT_Msk (0x100UL) /*!< CMD_OVER_NO_SPACE_RDATA_C_INT (Bitfield-Mask: 0x01) */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_C_INT_Pos (7UL)         /*!< CMD_OVER_C_INT (Bit 7)                                */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_OVER_C_INT_Msk (0x80UL)      /*!< CMD_OVER_C_INT (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_INTERRUPT_STATUS_WDATA_OVER_C_INT_Pos (6UL)       /*!< WDATA_OVER_C_INT (Bit 6)                              */
#define I2C0_CTRL_INTERRUPT_STATUS_WDATA_OVER_C_INT_Msk (0x40UL)    /*!< WDATA_OVER_C_INT (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_STATUS_RDATA_UNDER_C_INT_Pos (5UL)      /*!< RDATA_UNDER_C_INT (Bit 5)                             */
#define I2C0_CTRL_INTERRUPT_STATUS_RDATA_UNDER_C_INT_Msk (0x20UL)   /*!< RDATA_UNDER_C_INT (Bitfield-Mask: 0x01)               */
#define I2C0_CTRL_INTERRUPT_STATUS_NACK_ERR_C_INT_Pos (4UL)         /*!< NACK_ERR_C_INT (Bit 4)                                */
#define I2C0_CTRL_INTERRUPT_STATUS_NACK_ERR_C_INT_Msk (0x10UL)      /*!< NACK_ERR_C_INT (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_INTERRUPT_STATUS_DONE_C_INT_Pos (3UL)             /*!< DONE_C_INT (Bit 3)                                    */
#define I2C0_CTRL_INTERRUPT_STATUS_DONE_C_INT_Msk (0x8UL)           /*!< DONE_C_INT (Bitfield-Mask: 0x01)                      */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_STATUS_C_INT_Pos (2UL)       /*!< CMD_STATUS_C_INT (Bit 2)                              */
#define I2C0_CTRL_INTERRUPT_STATUS_CMD_STATUS_C_INT_Msk (0x4UL)     /*!< CMD_STATUS_C_INT (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_STATUS_WDATA_STATUS_C_INT_Pos (1UL)     /*!< WDATA_STATUS_C_INT (Bit 1)                            */
#define I2C0_CTRL_INTERRUPT_STATUS_WDATA_STATUS_C_INT_Msk (0x2UL)   /*!< WDATA_STATUS_C_INT (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_INTERRUPT_STATUS_RDATA_STATUS_C_INT_Pos (0UL)     /*!< RDATA_STATUS_C_INT (Bit 0)                            */
#define I2C0_CTRL_INTERRUPT_STATUS_RDATA_STATUS_C_INT_Msk (0x1UL)   /*!< RDATA_STATUS_C_INT (Bitfield-Mask: 0x01)              */
/* ==================================================  INTERRUPT_STATUS_RC  ================================================== */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_LINE_ABORT_C_INT_Pos (12UL)   /*!< LINE_ABORT_C_INT (Bit 12)                             */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_LINE_ABORT_C_INT_Msk (0x1000UL) /*!< LINE_ABORT_C_INT (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DATA_OVER_NO_CMD_C_INT_Pos (11UL) /*!< DATA_OVER_NO_CMD_C_INT (Bit 11)                   */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DATA_OVER_NO_CMD_C_INT_Msk (0x800UL) /*!< DATA_OVER_NO_CMD_C_INT (Bitfield-Mask: 0x01)   */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DATA_UNDER_NO_CMD_C_INT_Pos (10UL) /*!< DATA_UNDER_NO_CMD_C_INT (Bit 10)                 */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DATA_UNDER_NO_CMD_C_INT_Msk (0x400UL) /*!< DATA_UNDER_NO_CMD_C_INT (Bitfield-Mask: 0x01) */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_NO_WDATA_C_INT_Pos (9UL) /*!< CMD_OVER_NO_WDATA_C_INT (Bit 9)                   */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_NO_WDATA_C_INT_Msk (0x200UL) /*!< CMD_OVER_NO_WDATA_C_INT (Bitfield-Mask: 0x01) */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_NO_SPACE_RDATA_C_INT_Pos (8UL) /*!< CMD_OVER_NO_SPACE_RDATA_C_INT (Bit 8)       */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_NO_SPACE_RDATA_C_INT_Msk (0x100UL) /*!< CMD_OVER_NO_SPACE_RDATA_C_INT (Bitfield-Mask: 0x01) */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_C_INT_Pos (7UL)      /*!< CMD_OVER_C_INT (Bit 7)                                */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_OVER_C_INT_Msk (0x80UL)   /*!< CMD_OVER_C_INT (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_WDATA_OVER_C_INT_Pos (6UL)    /*!< WDATA_OVER_C_INT (Bit 6)                              */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_WDATA_OVER_C_INT_Msk (0x40UL) /*!< WDATA_OVER_C_INT (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_RDATA_UNDER_C_INT_Pos (5UL)   /*!< RDATA_UNDER_C_INT (Bit 5)                             */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_RDATA_UNDER_C_INT_Msk (0x20UL) /*!< RDATA_UNDER_C_INT (Bitfield-Mask: 0x01)              */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_NACK_ERR_C_INT_Pos (4UL)      /*!< NACK_ERR_C_INT (Bit 4)                                */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_NACK_ERR_C_INT_Msk (0x10UL)   /*!< NACK_ERR_C_INT (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DONE_C_INT_Pos (3UL)          /*!< DONE_C_INT (Bit 3)                                    */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_DONE_C_INT_Msk (0x8UL)        /*!< DONE_C_INT (Bitfield-Mask: 0x01)                      */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_STATUS_C_INT_Pos (2UL)    /*!< CMD_STATUS_C_INT (Bit 2)                              */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_CMD_STATUS_C_INT_Msk (0x4UL)  /*!< CMD_STATUS_C_INT (Bitfield-Mask: 0x01)                */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_WDATA_STATUS_C_INT_Pos (1UL)  /*!< WDATA_STATUS_C_INT (Bit 1)                            */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_WDATA_STATUS_C_INT_Msk (0x2UL) /*!< WDATA_STATUS_C_INT (Bitfield-Mask: 0x01)             */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_RDATA_STATUS_C_INT_Pos (0UL)  /*!< RDATA_STATUS_C_INT (Bit 0)                            */
#define I2C0_CTRL_INTERRUPT_STATUS_RC_RDATA_STATUS_C_INT_Msk (0x1UL) /*!< RDATA_STATUS_C_INT (Bitfield-Mask: 0x01)             */
/* =====================================================  CURRENT_STATE  ===================================================== */
#define I2C0_CTRL_CURRENT_STATE_I2C_IDLE_STATE_Pos (31UL)           /*!< I2C_IDLE_STATE (Bit 31)                               */
#define I2C0_CTRL_CURRENT_STATE_I2C_IDLE_STATE_Msk (0x80000000UL)   /*!< I2C_IDLE_STATE (Bitfield-Mask: 0x01)                  */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_LENGTH_Pos (24UL)       /*!< CURRENT_CMD_LENGTH (Bit 24)                           */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_LENGTH_Msk (0x3f000000UL) /*!< CURRENT_CMD_LENGTH (Bitfield-Mask: 0x3f)            */
#define I2C0_CTRL_CURRENT_STATE_MAIN_CTL_STATE_Pos (16UL)           /*!< MAIN_CTL_STATE (Bit 16)                               */
#define I2C0_CTRL_CURRENT_STATE_MAIN_CTL_STATE_Msk (0x1f0000UL)     /*!< MAIN_CTL_STATE (Bitfield-Mask: 0x1f)                  */
#define I2C0_CTRL_CURRENT_STATE_WRITE_COND_Pos (14UL)               /*!< WRITE_COND (Bit 14)                                   */
#define I2C0_CTRL_CURRENT_STATE_WRITE_COND_Msk (0x4000UL)           /*!< WRITE_COND (Bitfield-Mask: 0x01)                      */
#define I2C0_CTRL_CURRENT_STATE_READ_COND_Pos (13UL)                /*!< READ_COND (Bit 13)                                    */
#define I2C0_CTRL_CURRENT_STATE_READ_COND_Msk (0x2000UL)            /*!< READ_COND (Bitfield-Mask: 0x01)                       */
#define I2C0_CTRL_CURRENT_STATE_RESTART_Pos (12UL)                  /*!< RESTART (Bit 12)                                      */
#define I2C0_CTRL_CURRENT_STATE_RESTART_Msk (0x1000UL)              /*!< RESTART (Bitfield-Mask: 0x01)                         */
#define I2C0_CTRL_CURRENT_STATE_T_COUNT_Pos (8UL)                   /*!< T_COUNT (Bit 8)                                       */
#define I2C0_CTRL_CURRENT_STATE_T_COUNT_Msk (0xf00UL)               /*!< T_COUNT (Bitfield-Mask: 0x0f)                         */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_EN_INT_DONE_Pos (7UL)   /*!< CURRENT_CMD_EN_INT_DONE (Bit 7)                       */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_EN_INT_DONE_Msk (0x80UL) /*!< CURRENT_CMD_EN_INT_DONE (Bitfield-Mask: 0x01)        */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_R_W_Pos (6UL)           /*!< CURRENT_CMD_R_W (Bit 6)                               */
#define I2C0_CTRL_CURRENT_STATE_CURRENT_CMD_R_W_Msk (0x40UL)        /*!< CURRENT_CMD_R_W (Bitfield-Mask: 0x01)                 */
#define I2C0_CTRL_CURRENT_STATE_COUNT_EN_Pos (5UL)                  /*!< COUNT_EN (Bit 5)                                      */
#define I2C0_CTRL_CURRENT_STATE_COUNT_EN_Msk (0x20UL)               /*!< COUNT_EN (Bitfield-Mask: 0x01)                        */
#define I2C0_CTRL_CURRENT_STATE_LINE_DRIVER_STATE_Pos (0UL)         /*!< LINE_DRIVER_STATE (Bit 0)                             */
#define I2C0_CTRL_CURRENT_STATE_LINE_DRIVER_STATE_Msk (0x1fUL)      /*!< LINE_DRIVER_STATE (Bitfield-Mask: 0x1f)               */
/* =======================================================  READY_CFG  ======================================================= */
#define I2C0_CTRL_READY_CFG_WDATA_TRS_READY_Pos (8UL)               /*!< WDATA_TRS_READY (Bit 8)                               */
#define I2C0_CTRL_READY_CFG_WDATA_TRS_READY_Msk (0x7f00UL)          /*!< WDATA_TRS_READY (Bitfield-Mask: 0x7f)                 */
#define I2C0_CTRL_READY_CFG_RDATA_TRS_READY_Pos (0UL)               /*!< RDATA_TRS_READY (Bit 0)                               */
#define I2C0_CTRL_READY_CFG_RDATA_TRS_READY_Msk (0x7fUL)            /*!< RDATA_TRS_READY (Bitfield-Mask: 0x7f)                 */


/* =========================================================================================================================== */
/* ================                                        SPI_MASTER                                         ================ */
/* =========================================================================================================================== */

/* =======================================================  CMD_FIFO  ======================================================== */
#define SPI_MASTER0_CMD_FIFO_LEN_Pos      (16UL)                    /*!< LEN (Bit 16)                                          */
#define SPI_MASTER0_CMD_FIFO_LEN_Msk      (0xffff0000UL)            /*!< LEN (Bitfield-Mask: 0xffff)                           */
#define SPI_MASTER0_CMD_FIFO_FULL_DUPLEX_Pos (15UL)                 /*!< FULL_DUPLEX (Bit 15)                                  */
#define SPI_MASTER0_CMD_FIFO_FULL_DUPLEX_Msk (0x8000UL)             /*!< FULL_DUPLEX (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_CMD_FIFO_BASIC_CS_KEEP_LOW_Pos (14UL)           /*!< BASIC_CS_KEEP_LOW (Bit 14)                            */
#define SPI_MASTER0_CMD_FIFO_BASIC_CS_KEEP_LOW_Msk (0x4000UL)       /*!< BASIC_CS_KEEP_LOW (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_CMD_FIFO_ADDRESS_SIZE_Pos (8UL)                 /*!< ADDRESS_SIZE (Bit 8)                                  */
#define SPI_MASTER0_CMD_FIFO_ADDRESS_SIZE_Msk (0x3f00UL)            /*!< ADDRESS_SIZE (Bitfield-Mask: 0x3f)                    */
#define SPI_MASTER0_CMD_FIFO_CMD_LEN_Pos  (4UL)                     /*!< CMD_LEN (Bit 4)                                       */
#define SPI_MASTER0_CMD_FIFO_CMD_LEN_Msk  (0xf0UL)                  /*!< CMD_LEN (Bitfield-Mask: 0x0f)                         */
#define SPI_MASTER0_CMD_FIFO_EN_INT_DONE_Pos (3UL)                  /*!< EN_INT_DONE (Bit 3)                                   */
#define SPI_MASTER0_CMD_FIFO_EN_INT_DONE_Msk (0x8UL)                /*!< EN_INT_DONE (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_CMD_FIFO_SLAVE_SELECT_Pos (1UL)                 /*!< SLAVE_SELECT (Bit 1)                                  */
#define SPI_MASTER0_CMD_FIFO_SLAVE_SELECT_Msk (0x6UL)               /*!< SLAVE_SELECT (Bitfield-Mask: 0x03)                    */
#define SPI_MASTER0_CMD_FIFO_READ_EN_Pos  (0UL)                     /*!< READ_EN (Bit 0)                                       */
#define SPI_MASTER0_CMD_FIFO_READ_EN_Msk  (0x1UL)                   /*!< READ_EN (Bitfield-Mask: 0x01)                         */
/* ======================================================  WDATA_FIFO  ======================================================= */
#define SPI_MASTER0_WDATA_FIFO_WDATA_Pos  (0UL)                     /*!< WDATA (Bit 0)                                         */
#define SPI_MASTER0_WDATA_FIFO_WDATA_Msk  (0xffffffffUL)            /*!< WDATA (Bitfield-Mask: 0xffffffff)                     */
/* ====================================================  CMD_FIFO_STATUS  ==================================================== */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_STATUS_Pos (16UL)           /*!< CMD_STATUS (Bit 16)                                   */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_STATUS_Msk (0xf0000UL)      /*!< CMD_STATUS (Bitfield-Mask: 0x0f)                      */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_RP_Pos (8UL)                /*!< CMD_RP (Bit 8)                                        */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_RP_Msk (0x700UL)            /*!< CMD_RP (Bitfield-Mask: 0x07)                          */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_WP_Pos (0UL)                /*!< CMD_WP (Bit 0)                                        */
#define SPI_MASTER0_CMD_FIFO_STATUS_CMD_WP_Msk (0x7UL)              /*!< CMD_WP (Bitfield-Mask: 0x07)                          */
/* ===================================================  WDATA_FIFO_STATUS  =================================================== */
#define SPI_MASTER0_WDATA_FIFO_STATUS_FULL_DUPLEX_Pos (31UL)        /*!< FULL_DUPLEX (Bit 31)                                  */
#define SPI_MASTER0_WDATA_FIFO_STATUS_FULL_DUPLEX_Msk (0x80000000UL) /*!< FULL_DUPLEX (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_WDATA_FIFO_STATUS_READ_EN_Pos (24UL)            /*!< READ_EN (Bit 24)                                      */
#define SPI_MASTER0_WDATA_FIFO_STATUS_READ_EN_Msk (0x1000000UL)     /*!< READ_EN (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_STATUS_Pos (16UL)       /*!< WDATA_STATUS (Bit 16)                                 */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_STATUS_Msk (0xff0000UL) /*!< WDATA_STATUS (Bitfield-Mask: 0xff)                    */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_RP_Pos (8UL)            /*!< WDATA_RP (Bit 8)                                      */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_RP_Msk (0xff00UL)       /*!< WDATA_RP (Bitfield-Mask: 0xff)                        */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_WP_Pos (0UL)            /*!< WDATA_WP (Bit 0)                                      */
#define SPI_MASTER0_WDATA_FIFO_STATUS_WDATA_WP_Msk (0xffUL)         /*!< WDATA_WP (Bitfield-Mask: 0xff)                        */
/* =====================================================  LAST_EXE_CMD  ====================================================== */
#define SPI_MASTER0_LAST_EXE_CMD_LEN_Pos  (16UL)                    /*!< LEN (Bit 16)                                          */
#define SPI_MASTER0_LAST_EXE_CMD_LEN_Msk  (0xffff0000UL)            /*!< LEN (Bitfield-Mask: 0xffff)                           */
#define SPI_MASTER0_LAST_EXE_CMD_FULL_DUPLEX_Pos (15UL)             /*!< FULL_DUPLEX (Bit 15)                                  */
#define SPI_MASTER0_LAST_EXE_CMD_FULL_DUPLEX_Msk (0x8000UL)         /*!< FULL_DUPLEX (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_LAST_EXE_CMD_BASIC_CS_KEEP_LOW_Pos (14UL)       /*!< BASIC_CS_KEEP_LOW (Bit 14)                            */
#define SPI_MASTER0_LAST_EXE_CMD_BASIC_CS_KEEP_LOW_Msk (0x4000UL)   /*!< BASIC_CS_KEEP_LOW (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_LAST_EXE_CMD_ADDRESS_SIZE_Pos (8UL)             /*!< ADDRESS_SIZE (Bit 8)                                  */
#define SPI_MASTER0_LAST_EXE_CMD_ADDRESS_SIZE_Msk (0x3f00UL)        /*!< ADDRESS_SIZE (Bitfield-Mask: 0x3f)                    */
#define SPI_MASTER0_LAST_EXE_CMD_CMD_LEN_Pos (4UL)                  /*!< CMD_LEN (Bit 4)                                       */
#define SPI_MASTER0_LAST_EXE_CMD_CMD_LEN_Msk (0xf0UL)               /*!< CMD_LEN (Bitfield-Mask: 0x0f)                         */
#define SPI_MASTER0_LAST_EXE_CMD_EN_INT_DONE_Pos (3UL)              /*!< EN_INT_DONE (Bit 3)                                   */
#define SPI_MASTER0_LAST_EXE_CMD_EN_INT_DONE_Msk (0x8UL)            /*!< EN_INT_DONE (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_LAST_EXE_CMD_SLAVE_SELECT_Pos (1UL)             /*!< SLAVE_SELECT (Bit 1)                                  */
#define SPI_MASTER0_LAST_EXE_CMD_SLAVE_SELECT_Msk (0x6UL)           /*!< SLAVE_SELECT (Bitfield-Mask: 0x03)                    */
#define SPI_MASTER0_LAST_EXE_CMD_READ_EN_Pos (0UL)                  /*!< READ_EN (Bit 0)                                       */
#define SPI_MASTER0_LAST_EXE_CMD_READ_EN_Msk (0x1UL)                /*!< READ_EN (Bitfield-Mask: 0x01)                         */
/* ========================================================  CS1_CFG  ======================================================== */
#define SPI_MASTER0_CS1_CFG_COUNT_DIVIDE_CS1_Pos (16UL)             /*!< COUNT_DIVIDE_CS1 (Bit 16)                             */
#define SPI_MASTER0_CS1_CFG_COUNT_DIVIDE_CS1_Msk (0xffff0000UL)     /*!< COUNT_DIVIDE_CS1 (Bitfield-Mask: 0xffff)              */
#define SPI_MASTER0_CS1_CFG_THREE_WIRE_EN_CS1_Pos (15UL)            /*!< THREE_WIRE_EN_CS1 (Bit 15)                            */
#define SPI_MASTER0_CS1_CFG_THREE_WIRE_EN_CS1_Msk (0x8000UL)        /*!< THREE_WIRE_EN_CS1 (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_CS1_CFG_ENABLE_PERIODS_CS1_Pos (14UL)           /*!< ENABLE_PERIODS_CS1 (Bit 14)                           */
#define SPI_MASTER0_CS1_CFG_ENABLE_PERIODS_CS1_Msk (0x4000UL)       /*!< ENABLE_PERIODS_CS1 (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_CS1_CFG_NOP_CS1_Pos   (13UL)                    /*!< NOP_CS1 (Bit 13)                                      */
#define SPI_MASTER0_CS1_CFG_NOP_CS1_Msk   (0x2000UL)                /*!< NOP_CS1 (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_CS1_CFG_CD_EN_CS1_Pos (12UL)                    /*!< CD_EN_CS1 (Bit 12)                                    */
#define SPI_MASTER0_CS1_CFG_CD_EN_CS1_Msk (0x1000UL)                /*!< CD_EN_CS1 (Bitfield-Mask: 0x01)                       */
#define SPI_MASTER0_CS1_CFG_CS_KEEP_LOW_CS1_Pos (11UL)              /*!< CS_KEEP_LOW_CS1 (Bit 11)                              */
#define SPI_MASTER0_CS1_CFG_CS_KEEP_LOW_CS1_Msk (0x800UL)           /*!< CS_KEEP_LOW_CS1 (Bitfield-Mask: 0x01)                 */
#define SPI_MASTER0_CS1_CFG_ENDIAN_CS1_Pos (10UL)                   /*!< ENDIAN_CS1 (Bit 10)                                   */
#define SPI_MASTER0_CS1_CFG_ENDIAN_CS1_Msk (0x400UL)                /*!< ENDIAN_CS1 (Bitfield-Mask: 0x01)                      */
#define SPI_MASTER0_CS1_CFG_REVERSAL_CS1_Pos (9UL)                  /*!< REVERSAL_CS1 (Bit 9)                                  */
#define SPI_MASTER0_CS1_CFG_REVERSAL_CS1_Msk (0x200UL)              /*!< REVERSAL_CS1 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS1_CFG_INFINITE_CS1_Pos (8UL)                  /*!< INFINITE_CS1 (Bit 8)                                  */
#define SPI_MASTER0_CS1_CFG_INFINITE_CS1_Msk (0x100UL)              /*!< INFINITE_CS1 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS1_CFG_WS_CS1_Pos    (2UL)                     /*!< WS_CS1 (Bit 2)                                        */
#define SPI_MASTER0_CS1_CFG_WS_CS1_Msk    (0xfcUL)                  /*!< WS_CS1 (Bitfield-Mask: 0x3f)                          */
#define SPI_MASTER0_CS1_CFG_CPHA_CS1_Pos  (1UL)                     /*!< CPHA_CS1 (Bit 1)                                      */
#define SPI_MASTER0_CS1_CFG_CPHA_CS1_Msk  (0x2UL)                   /*!< CPHA_CS1 (Bitfield-Mask: 0x01)                        */
#define SPI_MASTER0_CS1_CFG_CPOL_CS1_Pos  (0UL)                     /*!< CPOL_CS1 (Bit 0)                                      */
#define SPI_MASTER0_CS1_CFG_CPOL_CS1_Msk  (0x1UL)                   /*!< CPOL_CS1 (Bitfield-Mask: 0x01)                        */
/* ========================================================  CS2_CFG  ======================================================== */
#define SPI_MASTER0_CS2_CFG_COUNT_DIVIDE_CS2_Pos (16UL)             /*!< COUNT_DIVIDE_CS2 (Bit 16)                             */
#define SPI_MASTER0_CS2_CFG_COUNT_DIVIDE_CS2_Msk (0xffff0000UL)     /*!< COUNT_DIVIDE_CS2 (Bitfield-Mask: 0xffff)              */
#define SPI_MASTER0_CS2_CFG_THREE_WIRE_EN_CS2_Pos (15UL)            /*!< THREE_WIRE_EN_CS2 (Bit 15)                            */
#define SPI_MASTER0_CS2_CFG_THREE_WIRE_EN_CS2_Msk (0x8000UL)        /*!< THREE_WIRE_EN_CS2 (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_CS2_CFG_ENABLE_PERIODS_CS2_Pos (14UL)           /*!< ENABLE_PERIODS_CS2 (Bit 14)                           */
#define SPI_MASTER0_CS2_CFG_ENABLE_PERIODS_CS2_Msk (0x4000UL)       /*!< ENABLE_PERIODS_CS2 (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_CS2_CFG_NOP_CS2_Pos   (13UL)                    /*!< NOP_CS2 (Bit 13)                                      */
#define SPI_MASTER0_CS2_CFG_NOP_CS2_Msk   (0x2000UL)                /*!< NOP_CS2 (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_CS2_CFG_CD_EN_CS2_Pos (12UL)                    /*!< CD_EN_CS2 (Bit 12)                                    */
#define SPI_MASTER0_CS2_CFG_CD_EN_CS2_Msk (0x1000UL)                /*!< CD_EN_CS2 (Bitfield-Mask: 0x01)                       */
#define SPI_MASTER0_CS2_CFG_CS_KEEP_LOW_CS2_Pos (11UL)              /*!< CS_KEEP_LOW_CS2 (Bit 11)                              */
#define SPI_MASTER0_CS2_CFG_CS_KEEP_LOW_CS2_Msk (0x800UL)           /*!< CS_KEEP_LOW_CS2 (Bitfield-Mask: 0x01)                 */
#define SPI_MASTER0_CS2_CFG_ENDIAN_CS2_Pos (10UL)                   /*!< ENDIAN_CS2 (Bit 10)                                   */
#define SPI_MASTER0_CS2_CFG_ENDIAN_CS2_Msk (0x400UL)                /*!< ENDIAN_CS2 (Bitfield-Mask: 0x01)                      */
#define SPI_MASTER0_CS2_CFG_REVERSAL_CS2_Pos (9UL)                  /*!< REVERSAL_CS2 (Bit 9)                                  */
#define SPI_MASTER0_CS2_CFG_REVERSAL_CS2_Msk (0x200UL)              /*!< REVERSAL_CS2 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS2_CFG_INFINITE_CS2_Pos (8UL)                  /*!< INFINITE_CS2 (Bit 8)                                  */
#define SPI_MASTER0_CS2_CFG_INFINITE_CS2_Msk (0x100UL)              /*!< INFINITE_CS2 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS2_CFG_WS_CS2_Pos    (2UL)                     /*!< WS_CS2 (Bit 2)                                        */
#define SPI_MASTER0_CS2_CFG_WS_CS2_Msk    (0xfcUL)                  /*!< WS_CS2 (Bitfield-Mask: 0x3f)                          */
#define SPI_MASTER0_CS2_CFG_CPHA_CS2_Pos  (1UL)                     /*!< CPHA_CS2 (Bit 1)                                      */
#define SPI_MASTER0_CS2_CFG_CPHA_CS2_Msk  (0x2UL)                   /*!< CPHA_CS2 (Bitfield-Mask: 0x01)                        */
#define SPI_MASTER0_CS2_CFG_CPOL_CS2_Pos  (0UL)                     /*!< CPOL_CS2 (Bit 0)                                      */
#define SPI_MASTER0_CS2_CFG_CPOL_CS2_Msk  (0x1UL)                   /*!< CPOL_CS2 (Bitfield-Mask: 0x01)                        */
/* ========================================================  CS3_CFG  ======================================================== */
#define SPI_MASTER0_CS3_CFG_COUNT_DIVIDE_CS3_Pos (16UL)             /*!< COUNT_DIVIDE_CS3 (Bit 16)                             */
#define SPI_MASTER0_CS3_CFG_COUNT_DIVIDE_CS3_Msk (0xffff0000UL)     /*!< COUNT_DIVIDE_CS3 (Bitfield-Mask: 0xffff)              */
#define SPI_MASTER0_CS3_CFG_THREE_WIRE_EN_CS3_Pos (15UL)            /*!< THREE_WIRE_EN_CS3 (Bit 15)                            */
#define SPI_MASTER0_CS3_CFG_THREE_WIRE_EN_CS3_Msk (0x8000UL)        /*!< THREE_WIRE_EN_CS3 (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_CS3_CFG_ENABLE_PERIODS_CS3_Pos (14UL)           /*!< ENABLE_PERIODS_CS3 (Bit 14)                           */
#define SPI_MASTER0_CS3_CFG_ENABLE_PERIODS_CS3_Msk (0x4000UL)       /*!< ENABLE_PERIODS_CS3 (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_CS3_CFG_NOP_CS3_Pos   (13UL)                    /*!< NOP_CS3 (Bit 13)                                      */
#define SPI_MASTER0_CS3_CFG_NOP_CS3_Msk   (0x2000UL)                /*!< NOP_CS3 (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_CS3_CFG_CD_EN_CS3_Pos (12UL)                    /*!< CD_EN_CS3 (Bit 12)                                    */
#define SPI_MASTER0_CS3_CFG_CD_EN_CS3_Msk (0x1000UL)                /*!< CD_EN_CS3 (Bitfield-Mask: 0x01)                       */
#define SPI_MASTER0_CS3_CFG_CS_KEEP_LOW_CS3_Pos (11UL)              /*!< CS_KEEP_LOW_CS3 (Bit 11)                              */
#define SPI_MASTER0_CS3_CFG_CS_KEEP_LOW_CS3_Msk (0x800UL)           /*!< CS_KEEP_LOW_CS3 (Bitfield-Mask: 0x01)                 */
#define SPI_MASTER0_CS3_CFG_ENDIAN_CS3_Pos (10UL)                   /*!< ENDIAN_CS3 (Bit 10)                                   */
#define SPI_MASTER0_CS3_CFG_ENDIAN_CS3_Msk (0x400UL)                /*!< ENDIAN_CS3 (Bitfield-Mask: 0x01)                      */
#define SPI_MASTER0_CS3_CFG_REVERSAL_CS3_Pos (9UL)                  /*!< REVERSAL_CS3 (Bit 9)                                  */
#define SPI_MASTER0_CS3_CFG_REVERSAL_CS3_Msk (0x200UL)              /*!< REVERSAL_CS3 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS3_CFG_INFINITE_CS3_Pos (8UL)                  /*!< INFINITE_CS3 (Bit 8)                                  */
#define SPI_MASTER0_CS3_CFG_INFINITE_CS3_Msk (0x100UL)              /*!< INFINITE_CS3 (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_CS3_CFG_WS_CS3_Pos    (2UL)                     /*!< WS_CS3 (Bit 2)                                        */
#define SPI_MASTER0_CS3_CFG_WS_CS3_Msk    (0xfcUL)                  /*!< WS_CS3 (Bitfield-Mask: 0x3f)                          */
#define SPI_MASTER0_CS3_CFG_CPHA_CS3_Pos  (1UL)                     /*!< CPHA_CS3 (Bit 1)                                      */
#define SPI_MASTER0_CS3_CFG_CPHA_CS3_Msk  (0x2UL)                   /*!< CPHA_CS3 (Bitfield-Mask: 0x01)                        */
#define SPI_MASTER0_CS3_CFG_CPOL_CS3_Pos  (0UL)                     /*!< CPOL_CS3 (Bit 0)                                      */
#define SPI_MASTER0_CS3_CFG_CPOL_CS3_Msk  (0x1UL)                   /*!< CPOL_CS3 (Bitfield-Mask: 0x01)                        */
/* ===================================================  COUNTER1_CS1_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER1_CS1_CFG_RECOVERY_PERIOD_CS1_Pos (16UL) /*!< RECOVERY_PERIOD_CS1 (Bit 16)                          */
#define SPI_MASTER0_COUNTER1_CS1_CFG_RECOVERY_PERIOD_CS1_Msk (0xffff0000UL) /*!< RECOVERY_PERIOD_CS1 (Bitfield-Mask: 0xffff)   */
#define SPI_MASTER0_COUNTER1_CS1_CFG_HOLD_PERIIOD_CS1_Pos (0UL)     /*!< HOLD_PERIIOD_CS1 (Bit 0)                              */
#define SPI_MASTER0_COUNTER1_CS1_CFG_HOLD_PERIIOD_CS1_Msk (0xffffUL) /*!< HOLD_PERIIOD_CS1 (Bitfield-Mask: 0xffff)             */
/* ===================================================  COUNTER1_CS2_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER1_CS2_CFG_RECOVERY_PERIOD_CS2_Pos (16UL) /*!< RECOVERY_PERIOD_CS2 (Bit 16)                          */
#define SPI_MASTER0_COUNTER1_CS2_CFG_RECOVERY_PERIOD_CS2_Msk (0xffff0000UL) /*!< RECOVERY_PERIOD_CS2 (Bitfield-Mask: 0xffff)   */
#define SPI_MASTER0_COUNTER1_CS2_CFG_HOLD_PERIIOD_CS2_Pos (0UL)     /*!< HOLD_PERIIOD_CS2 (Bit 0)                              */
#define SPI_MASTER0_COUNTER1_CS2_CFG_HOLD_PERIIOD_CS2_Msk (0xffffUL) /*!< HOLD_PERIIOD_CS2 (Bitfield-Mask: 0xffff)             */
/* ===================================================  COUNTER1_CS3_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER1_CS3_CFG_RECOVERY_PERIOD_CS3_Pos (16UL) /*!< RECOVERY_PERIOD_CS3 (Bit 16)                          */
#define SPI_MASTER0_COUNTER1_CS3_CFG_RECOVERY_PERIOD_CS3_Msk (0xffff0000UL) /*!< RECOVERY_PERIOD_CS3 (Bitfield-Mask: 0xffff)   */
#define SPI_MASTER0_COUNTER1_CS3_CFG_HOLD_PERIIOD_CS3_Pos (0UL)     /*!< HOLD_PERIIOD_CS3 (Bit 0)                              */
#define SPI_MASTER0_COUNTER1_CS3_CFG_HOLD_PERIIOD_CS3_Msk (0xffffUL) /*!< HOLD_PERIIOD_CS3 (Bitfield-Mask: 0xffff)             */
/* ===================================================  COUNTER2_CS1_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER2_CS1_CFG_CD_SETUP_CS1_Pos (16UL)        /*!< CD_SETUP_CS1 (Bit 16)                                 */
#define SPI_MASTER0_COUNTER2_CS1_CFG_CD_SETUP_CS1_Msk (0x7f0000UL)  /*!< CD_SETUP_CS1 (Bitfield-Mask: 0x7f)                    */
#define SPI_MASTER0_COUNTER2_CS1_CFG_SETUP_PERIOD_CS1_Pos (0UL)     /*!< SETUP_PERIOD_CS1 (Bit 0)                              */
#define SPI_MASTER0_COUNTER2_CS1_CFG_SETUP_PERIOD_CS1_Msk (0xffffUL) /*!< SETUP_PERIOD_CS1 (Bitfield-Mask: 0xffff)             */
/* ===================================================  COUNTER2_CS2_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER2_CS2_CFG_CD_SETUP_CS2_Pos (16UL)        /*!< CD_SETUP_CS2 (Bit 16)                                 */
#define SPI_MASTER0_COUNTER2_CS2_CFG_CD_SETUP_CS2_Msk (0x7f0000UL)  /*!< CD_SETUP_CS2 (Bitfield-Mask: 0x7f)                    */
#define SPI_MASTER0_COUNTER2_CS2_CFG_SETUP_PERIOD_CS2_Pos (0UL)     /*!< SETUP_PERIOD_CS2 (Bit 0)                              */
#define SPI_MASTER0_COUNTER2_CS2_CFG_SETUP_PERIOD_CS2_Msk (0xffffUL) /*!< SETUP_PERIOD_CS2 (Bitfield-Mask: 0xffff)             */
/* ===================================================  COUNTER2_CS3_CFG  ==================================================== */
#define SPI_MASTER0_COUNTER2_CS3_CFG_CD_SETUP_CS3_Pos (16UL)        /*!< CD_SETUP_CS3 (Bit 16)                                 */
#define SPI_MASTER0_COUNTER2_CS3_CFG_CD_SETUP_CS3_Msk (0x7f0000UL)  /*!< CD_SETUP_CS3 (Bitfield-Mask: 0x7f)                    */
#define SPI_MASTER0_COUNTER2_CS3_CFG_SETUP_PERIOD_CS3_Pos (0UL)     /*!< SETUP_PERIOD_CS3 (Bit 0)                              */
#define SPI_MASTER0_COUNTER2_CS3_CFG_SETUP_PERIOD_CS3_Msk (0xffffUL) /*!< SETUP_PERIOD_CS3 (Bitfield-Mask: 0xffff)             */
/* =======================================================  FLUSH_CFG  ======================================================= */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_CMD_Pos (16UL)                  /*!< FLUSH_CMD (Bit 16)                                    */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_CMD_Msk (0x10000UL)             /*!< FLUSH_CMD (Bitfield-Mask: 0x01)                       */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_WDATA_Pos (1UL)                 /*!< FLUSH_WDATA (Bit 1)                                   */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_WDATA_Msk (0x2UL)               /*!< FLUSH_WDATA (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_RDATA_Pos (0UL)                 /*!< FLUSH_RDATA (Bit 0)                                   */
#define SPI_MASTER0_FLUSH_CFG_FLUSH_RDATA_Msk (0x1UL)               /*!< FLUSH_RDATA (Bitfield-Mask: 0x01)                     */
/* ====================================================  INTERRUPT_CFG1  ===================================================== */
#define SPI_MASTER0_INTERRUPT_CFG1_HW_FLOW_CTL_Pos (21UL)           /*!< HW_FLOW_CTL (Bit 21)                                  */
#define SPI_MASTER0_INTERRUPT_CFG1_HW_FLOW_CTL_Msk (0x200000UL)     /*!< HW_FLOW_CTL (Bitfield-Mask: 0x01)                     */
#define SPI_MASTER0_INTERRUPT_CFG1_CMD_S_INT_Pos (16UL)             /*!< CMD_S_INT (Bit 16)                                    */
#define SPI_MASTER0_INTERRUPT_CFG1_CMD_S_INT_Msk (0xf0000UL)        /*!< CMD_S_INT (Bitfield-Mask: 0x0f)                       */
#define SPI_MASTER0_INTERRUPT_CFG1_WDATA_S_INT_Pos (8UL)            /*!< WDATA_S_INT (Bit 8)                                   */
#define SPI_MASTER0_INTERRUPT_CFG1_WDATA_S_INT_Msk (0xff00UL)       /*!< WDATA_S_INT (Bitfield-Mask: 0xff)                     */
#define SPI_MASTER0_INTERRUPT_CFG1_RDATA_S_INT_Pos (0UL)            /*!< RDATA_S_INT (Bit 0)                                   */
#define SPI_MASTER0_INTERRUPT_CFG1_RDATA_S_INT_Msk (0xffUL)         /*!< RDATA_S_INT (Bitfield-Mask: 0xff)                     */
/* ====================================================  INTERRUPT_CFG2  ===================================================== */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_WDATA_OVER_CMD_EMPTY_Pos (27UL) /*!< M_ERR_WDATA_OVER_CMD_EMPTY (Bit 27)              */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_WDATA_OVER_CMD_EMPTY_Msk (0x8000000UL) /*!< M_ERR_WDATA_OVER_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_RDATA_UNDR_CMD_EMPTY_Pos (26UL) /*!< M_ERR_RDATA_UNDR_CMD_EMPTY (Bit 26)              */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_RDATA_UNDR_CMD_EMPTY_Msk (0x4000000UL) /*!< M_ERR_RDATA_UNDR_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_CMD_OVER_WDATA_EMPTY_Pos (25UL) /*!< M_ERR_CMD_OVER_WDATA_EMPTY (Bit 25)              */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_CMD_OVER_WDATA_EMPTY_Msk (0x2000000UL) /*!< M_ERR_CMD_OVER_WDATA_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_CMD_OVER_RDATA_FULL_Pos (24UL) /*!< M_ERR_CMD_OVER_RDATA_FULL (Bit 24)                */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_CMD_OVER_RDATA_FULL_Msk (0x1000000UL) /*!< M_ERR_CMD_OVER_RDATA_FULL (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_SW_WRITE_RDATA_Pos (23UL)  /*!< M_ERR_SW_WRITE_RDATA (Bit 23)                         */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_SW_WRITE_RDATA_Msk (0x800000UL) /*!< M_ERR_SW_WRITE_RDATA (Bitfield-Mask: 0x01)       */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_SW_READ_WDATA_Pos (22UL)   /*!< M_ERR_SW_READ_WDATA (Bit 22)                          */
#define SPI_MASTER0_INTERRUPT_CFG2_M_ERR_SW_READ_WDATA_Msk (0x400000UL) /*!< M_ERR_SW_READ_WDATA (Bitfield-Mask: 0x01)         */
#define SPI_MASTER0_INTERRUPT_CFG2_M_UNDERFLOW_WDATA_Pos (21UL)     /*!< M_UNDERFLOW_WDATA (Bit 21)                            */
#define SPI_MASTER0_INTERRUPT_CFG2_M_UNDERFLOW_WDATA_Msk (0x200000UL) /*!< M_UNDERFLOW_WDATA (Bitfield-Mask: 0x01)             */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_RDATA_Pos (20UL)      /*!< M_OVERFLOW_RDATA (Bit 20)                             */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_RDATA_Msk (0x100000UL) /*!< M_OVERFLOW_RDATA (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_INTERRUPT_CFG2_M_UNDERFLOW_RDATA_Pos (19UL)     /*!< M_UNDERFLOW_RDATA (Bit 19)                            */
#define SPI_MASTER0_INTERRUPT_CFG2_M_UNDERFLOW_RDATA_Msk (0x80000UL) /*!< M_UNDERFLOW_RDATA (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_WDATA_Pos (18UL)      /*!< M_OVERFLOW_WDATA (Bit 18)                             */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_WDATA_Msk (0x40000UL) /*!< M_OVERFLOW_WDATA (Bitfield-Mask: 0x01)                */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_CTL_Pos (17UL)        /*!< M_OVERFLOW_CTL (Bit 17)                               */
#define SPI_MASTER0_INTERRUPT_CFG2_M_OVERFLOW_CTL_Msk (0x20000UL)   /*!< M_OVERFLOW_CTL (Bitfield-Mask: 0x01)                  */
#define SPI_MASTER0_INTERRUPT_CFG2_M_DIR_ERR_Pos (16UL)             /*!< M_DIR_ERR (Bit 16)                                    */
#define SPI_MASTER0_INTERRUPT_CFG2_M_DIR_ERR_Msk (0x10000UL)        /*!< M_DIR_ERR (Bitfield-Mask: 0x01)                       */
#define SPI_MASTER0_INTERRUPT_CFG2_M_CMD_Pos (3UL)                  /*!< M_CMD (Bit 3)                                         */
#define SPI_MASTER0_INTERRUPT_CFG2_M_CMD_Msk (0x8UL)                /*!< M_CMD (Bitfield-Mask: 0x01)                           */
#define SPI_MASTER0_INTERRUPT_CFG2_M_WDATA_Pos (2UL)                /*!< M_WDATA (Bit 2)                                       */
#define SPI_MASTER0_INTERRUPT_CFG2_M_WDATA_Msk (0x4UL)              /*!< M_WDATA (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_INTERRUPT_CFG2_M_RDATA_Pos (1UL)                /*!< M_RDATA (Bit 1)                                       */
#define SPI_MASTER0_INTERRUPT_CFG2_M_RDATA_Msk (0x2UL)              /*!< M_RDATA (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_INTERRUPT_CFG2_M_DONE_Pos (0UL)                 /*!< M_DONE (Bit 0)                                        */
#define SPI_MASTER0_INTERRUPT_CFG2_M_DONE_Msk (0x1UL)               /*!< M_DONE (Bitfield-Mask: 0x01)                          */
/* ===================================================  INTERRUPT_STATUS  ==================================================== */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_WDATA_OVER_CMD_EMPTY_Pos (27UL) /*!< ERR_WDATA_OVER_CMD_EMPTY (Bit 27)                */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_WDATA_OVER_CMD_EMPTY_Msk (0x8000000UL) /*!< ERR_WDATA_OVER_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_RDATA_UNDR_CMD_EMPTY_Pos (26UL) /*!< ERR_RDATA_UNDR_CMD_EMPTY (Bit 26)                */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_RDATA_UNDR_CMD_EMPTY_Msk (0x4000000UL) /*!< ERR_RDATA_UNDR_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_CMD_OVER_WDATA_EMPTY_Pos (25UL) /*!< ERR_CMD_OVER_WDATA_EMPTY (Bit 25)                */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_CMD_OVER_WDATA_EMPTY_Msk (0x2000000UL) /*!< ERR_CMD_OVER_WDATA_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_CMD_OVER_RDATA_FULL_Pos (24UL) /*!< ERR_CMD_OVER_RDATA_FULL (Bit 24)                  */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_CMD_OVER_RDATA_FULL_Msk (0x1000000UL) /*!< ERR_CMD_OVER_RDATA_FULL (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_SW_WRITE_RDATA_Pos (23UL)  /*!< ERR_SW_WRITE_RDATA (Bit 23)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_SW_WRITE_RDATA_Msk (0x800000UL) /*!< ERR_SW_WRITE_RDATA (Bitfield-Mask: 0x01)         */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_SW_READ_WDATA_Pos (22UL)   /*!< ERR_SW_READ_WDATA (Bit 22)                            */
#define SPI_MASTER0_INTERRUPT_STATUS_ERR_SW_READ_WDATA_Msk (0x400000UL) /*!< ERR_SW_READ_WDATA (Bitfield-Mask: 0x01)           */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_OVER_C_INT_Pos (21UL)    /*!< RDATA_OVER_C_INT (Bit 21)                             */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_OVER_C_INT_Msk (0x200000UL) /*!< RDATA_OVER_C_INT (Bitfield-Mask: 0x01)             */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_UNDER_C_INT_Pos (20UL)   /*!< WDATA_UNDER_C_INT (Bit 20)                            */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_UNDER_C_INT_Msk (0x100000UL) /*!< WDATA_UNDER_C_INT (Bitfield-Mask: 0x01)           */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_UNDER_C_INT_Pos (19UL)   /*!< RDATA_UNDER_C_INT (Bit 19)                            */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_UNDER_C_INT_Msk (0x80000UL) /*!< RDATA_UNDER_C_INT (Bitfield-Mask: 0x01)            */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_OVER_C_INT_Pos (18UL)    /*!< WDATA_OVER_C_INT (Bit 18)                             */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_OVER_C_INT_Msk (0x40000UL) /*!< WDATA_OVER_C_INT (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_INTERRUPT_STATUS_CMD_OVER_C_INT_Pos (17UL)      /*!< CMD_OVER_C_INT (Bit 17)                               */
#define SPI_MASTER0_INTERRUPT_STATUS_CMD_OVER_C_INT_Msk (0x20000UL) /*!< CMD_OVER_C_INT (Bitfield-Mask: 0x01)                  */
#define SPI_MASTER0_INTERRUPT_STATUS_DIR_ERR_C_INT_Pos (16UL)       /*!< DIR_ERR_C_INT (Bit 16)                                */
#define SPI_MASTER0_INTERRUPT_STATUS_DIR_ERR_C_INT_Msk (0x10000UL)  /*!< DIR_ERR_C_INT (Bitfield-Mask: 0x01)                   */
#define SPI_MASTER0_INTERRUPT_STATUS_CMD_STATUS_C_INT_Pos (3UL)     /*!< CMD_STATUS_C_INT (Bit 3)                              */
#define SPI_MASTER0_INTERRUPT_STATUS_CMD_STATUS_C_INT_Msk (0x8UL)   /*!< CMD_STATUS_C_INT (Bitfield-Mask: 0x01)                */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_STATUS_C_INT_Pos (2UL)   /*!< WDATA_STATUS_C_INT (Bit 2)                            */
#define SPI_MASTER0_INTERRUPT_STATUS_WDATA_STATUS_C_INT_Msk (0x4UL) /*!< WDATA_STATUS_C_INT (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_STATUS_C_INT_Pos (1UL)   /*!< RDATA_STATUS_C_INT (Bit 1)                            */
#define SPI_MASTER0_INTERRUPT_STATUS_RDATA_STATUS_C_INT_Msk (0x2UL) /*!< RDATA_STATUS_C_INT (Bitfield-Mask: 0x01)              */
#define SPI_MASTER0_INTERRUPT_STATUS_DONE_C_INT_Pos (0UL)           /*!< DONE_C_INT (Bit 0)                                    */
#define SPI_MASTER0_INTERRUPT_STATUS_DONE_C_INT_Msk (0x1UL)         /*!< DONE_C_INT (Bitfield-Mask: 0x01)                      */
/* ==================================================  INTERRUPT_STATUS_RC  ================================================== */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_WDATA_OVER_CMD_EMPTY_Pos (27UL) /*!< ERR_WDATA_OVER_CMD_EMPTY (Bit 27)             */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_WDATA_OVER_CMD_EMPTY_Msk (0x8000000UL) /*!< ERR_WDATA_OVER_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_RDATA_UNDR_CMD_EMPTY_Pos (26UL) /*!< ERR_RDATA_UNDR_CMD_EMPTY (Bit 26)             */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_RDATA_UNDR_CMD_EMPTY_Msk (0x4000000UL) /*!< ERR_RDATA_UNDR_CMD_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_CMD_OVER_WDATA_EMPTY_Pos (25UL) /*!< ERR_CMD_OVER_WDATA_EMPTY (Bit 25)             */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_CMD_OVER_WDATA_EMPTY_Msk (0x2000000UL) /*!< ERR_CMD_OVER_WDATA_EMPTY (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_CMD_OVER_RDATA_FULL_Pos (24UL) /*!< ERR_CMD_OVER_RDATA_FULL (Bit 24)               */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_CMD_OVER_RDATA_FULL_Msk (0x1000000UL) /*!< ERR_CMD_OVER_RDATA_FULL (Bitfield-Mask: 0x01) */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_SW_WRITE_RDATA_Pos (23UL) /*!< ERR_SW_WRITE_RDATA (Bit 23)                         */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_SW_WRITE_RDATA_Msk (0x800000UL) /*!< ERR_SW_WRITE_RDATA (Bitfield-Mask: 0x01)      */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_SW_READ_WDATA_Pos (22UL) /*!< ERR_SW_READ_WDATA (Bit 22)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_ERR_SW_READ_WDATA_Msk (0x400000UL) /*!< ERR_SW_READ_WDATA (Bitfield-Mask: 0x01)        */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_OVER_C_INT_Pos (21UL) /*!< RDATA_OVER_C_INT (Bit 21)                             */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_OVER_C_INT_Msk (0x200000UL) /*!< RDATA_OVER_C_INT (Bitfield-Mask: 0x01)          */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_UNDER_C_INT_Pos (20UL) /*!< WDATA_UNDER_C_INT (Bit 20)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_UNDER_C_INT_Msk (0x100000UL) /*!< WDATA_UNDER_C_INT (Bitfield-Mask: 0x01)        */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_UNDER_C_INT_Pos (19UL) /*!< RDATA_UNDER_C_INT (Bit 19)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_UNDER_C_INT_Msk (0x80000UL) /*!< RDATA_UNDER_C_INT (Bitfield-Mask: 0x01)         */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_OVER_C_INT_Pos (18UL) /*!< WDATA_OVER_C_INT (Bit 18)                             */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_OVER_C_INT_Msk (0x40000UL) /*!< WDATA_OVER_C_INT (Bitfield-Mask: 0x01)           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_CMD_OVER_C_INT_Pos (17UL)   /*!< CMD_OVER_C_INT (Bit 17)                               */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_CMD_OVER_C_INT_Msk (0x20000UL) /*!< CMD_OVER_C_INT (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_DIR_ERR_C_INT_Pos (16UL)    /*!< DIR_ERR_C_INT (Bit 16)                                */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_DIR_ERR_C_INT_Msk (0x10000UL) /*!< DIR_ERR_C_INT (Bitfield-Mask: 0x01)                 */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_CMD_STATUS_C_INT_Pos (3UL)  /*!< CMD_STATUS_C_INT (Bit 3)                              */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_CMD_STATUS_C_INT_Msk (0x8UL) /*!< CMD_STATUS_C_INT (Bitfield-Mask: 0x01)               */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_STATUS_C_INT_Pos (2UL) /*!< WDATA_STATUS_C_INT (Bit 2)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_WDATA_STATUS_C_INT_Msk (0x4UL) /*!< WDATA_STATUS_C_INT (Bitfield-Mask: 0x01)           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_STATUS_C_INT_Pos (1UL) /*!< RDATA_STATUS_C_INT (Bit 1)                           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_RDATA_STATUS_C_INT_Msk (0x2UL) /*!< RDATA_STATUS_C_INT (Bitfield-Mask: 0x01)           */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_DONE_C_INT_Pos (0UL)        /*!< DONE_C_INT (Bit 0)                                    */
#define SPI_MASTER0_INTERRUPT_STATUS_RC_DONE_C_INT_Msk (0x1UL)      /*!< DONE_C_INT (Bitfield-Mask: 0x01)                      */
/* =====================================================  CURRENT_STATE  ===================================================== */
#define SPI_MASTER0_CURRENT_STATE_LEN_Pos (16UL)                    /*!< LEN (Bit 16)                                          */
#define SPI_MASTER0_CURRENT_STATE_LEN_Msk (0xffff0000UL)            /*!< LEN (Bitfield-Mask: 0xffff)                           */
#define SPI_MASTER0_CURRENT_STATE_PHASE_COUNT_Pos (8UL)             /*!< PHASE_COUNT (Bit 8)                                   */
#define SPI_MASTER0_CURRENT_STATE_PHASE_COUNT_Msk (0x7f00UL)        /*!< PHASE_COUNT (Bitfield-Mask: 0x7f)                     */
#define SPI_MASTER0_CURRENT_STATE_MAIN_CTL_STATE_Pos (5UL)          /*!< MAIN_CTL_STATE (Bit 5)                                */
#define SPI_MASTER0_CURRENT_STATE_MAIN_CTL_STATE_Msk (0xe0UL)       /*!< MAIN_CTL_STATE (Bitfield-Mask: 0x07)                  */
#define SPI_MASTER0_CURRENT_STATE_WRITE_STATE_Pos (0UL)             /*!< WRITE_STATE (Bit 0)                                   */
#define SPI_MASTER0_CURRENT_STATE_WRITE_STATE_Msk (0x7UL)           /*!< WRITE_STATE (Bitfield-Mask: 0x07)                     */
/* =======================================================  READY_CFG  ======================================================= */
#define SPI_MASTER0_READY_CFG_WDATA_TRS_READY_Pos (8UL)             /*!< WDATA_TRS_READY (Bit 8)                               */
#define SPI_MASTER0_READY_CFG_WDATA_TRS_READY_Msk (0xff00UL)        /*!< WDATA_TRS_READY (Bitfield-Mask: 0xff)                 */
#define SPI_MASTER0_READY_CFG_RDATA_TRS_READY_Pos (0UL)             /*!< RDATA_TRS_READY (Bit 0)                               */
#define SPI_MASTER0_READY_CFG_RDATA_TRS_READY_Msk (0xffUL)          /*!< RDATA_TRS_READY (Bitfield-Mask: 0xff)                 */
/* ======================================================  SPI_ENABLE  ======================================================= */
#define SPI_MASTER0_SPI_ENABLE_SPI_EN_Pos (0UL)                     /*!< SPI_EN (Bit 0)                                        */
#define SPI_MASTER0_SPI_ENABLE_SPI_EN_Msk (0x1UL)                   /*!< SPI_EN (Bitfield-Mask: 0x01)                          */
/* ======================================================  RDATA_FIFO  ======================================================= */
#define SPI_MASTER0_RDATA_FIFO_RDATA_Pos  (0UL)                     /*!< RDATA (Bit 0)                                         */
#define SPI_MASTER0_RDATA_FIFO_RDATA_Msk  (0xffffffffUL)            /*!< RDATA (Bitfield-Mask: 0xffffffff)                     */
/* ===================================================  RDATA_FIFO_STATUS  =================================================== */
#define SPI_MASTER0_RDATA_FIFO_STATUS_FULL_DUPLEX_Pos (31UL)        /*!< FULL_DUPLEX (Bit 31)                                  */
#define SPI_MASTER0_RDATA_FIFO_STATUS_FULL_DUPLEX_Msk (0x80000000UL) /*!< FULL_DUPLEX (Bitfield-Mask: 0x01)                    */
#define SPI_MASTER0_RDATA_FIFO_STATUS_READ_EN_Pos (24UL)            /*!< READ_EN (Bit 24)                                      */
#define SPI_MASTER0_RDATA_FIFO_STATUS_READ_EN_Msk (0x1000000UL)     /*!< READ_EN (Bitfield-Mask: 0x01)                         */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_STATUS_Pos (16UL)       /*!< RDATA_STATUS (Bit 16)                                 */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_STATUS_Msk (0xff0000UL) /*!< RDATA_STATUS (Bitfield-Mask: 0xff)                    */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_RP_Pos (8UL)            /*!< RDATA_RP (Bit 8)                                      */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_RP_Msk (0xff00UL)       /*!< RDATA_RP (Bitfield-Mask: 0xff)                        */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_WP_Pos (0UL)            /*!< RDATA_WP (Bit 0)                                      */
#define SPI_MASTER0_RDATA_FIFO_STATUS_RDATA_WP_Msk (0xffUL)         /*!< RDATA_WP (Bitfield-Mask: 0xff)                        */


/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  DATA  ========================================================== */
#define GPIO_0_DATA_DATA_Pos              (0UL)                     /*!< DATA (Bit 0)                                          */
#define GPIO_0_DATA_DATA_Msk              (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ========================================================  DIR_SET  ======================================================== */
#define GPIO_0_DIR_SET_DIR_SET_Pos        (0UL)                     /*!< DIR_SET (Bit 0)                                       */
#define GPIO_0_DIR_SET_DIR_SET_Msk        (0xffUL)                  /*!< DIR_SET (Bitfield-Mask: 0xff)                         */
/* ========================================================  DIR_CLR  ======================================================== */
#define GPIO_0_DIR_CLR_DIR_CLR_Pos        (0UL)                     /*!< DIR_CLR (Bit 0)                                       */
#define GPIO_0_DIR_CLR_DIR_CLR_Msk        (0xffUL)                  /*!< DIR_CLR (Bitfield-Mask: 0xff)                         */
/* ==========================================================  DIR  ========================================================== */
#define GPIO_0_DIR_DIR_Pos                (0UL)                     /*!< DIR (Bit 0)                                           */
#define GPIO_0_DIR_DIR_Msk                (0xffUL)                  /*!< DIR (Bitfield-Mask: 0xff)                             */
/* =====================================================  INT_SENSE_SET  ===================================================== */
#define GPIO_0_INT_SENSE_SET_INT_SENSE_SET_Pos (0UL)                /*!< INT_SENSE_SET (Bit 0)                                 */
#define GPIO_0_INT_SENSE_SET_INT_SENSE_SET_Msk (0xffUL)             /*!< INT_SENSE_SET (Bitfield-Mask: 0xff)                   */
/* =====================================================  INT_SENSE_CLR  ===================================================== */
#define GPIO_0_INT_SENSE_CLR_INT_SENSE_CLR_Pos (0UL)                /*!< INT_SENSE_CLR (Bit 0)                                 */
#define GPIO_0_INT_SENSE_CLR_INT_SENSE_CLR_Msk (0xffUL)             /*!< INT_SENSE_CLR (Bitfield-Mask: 0xff)                   */
/* =======================================================  INT_SENSE  ======================================================= */
#define GPIO_0_INT_SENSE_INT_SENSE_Pos    (0UL)                     /*!< INT_SENSE (Bit 0)                                     */
#define GPIO_0_INT_SENSE_INT_SENSE_Msk    (0xffUL)                  /*!< INT_SENSE (Bitfield-Mask: 0xff)                       */
/* ==================================================  INT_BOTH_EDGES_SET  =================================================== */
#define GPIO_0_INT_BOTH_EDGES_SET_INT_BOTH_EDGES_SET_Pos (0UL)      /*!< INT_BOTH_EDGES_SET (Bit 0)                            */
#define GPIO_0_INT_BOTH_EDGES_SET_INT_BOTH_EDGES_SET_Msk (0xffUL)   /*!< INT_BOTH_EDGES_SET (Bitfield-Mask: 0xff)              */
/* ==================================================  INT_BOTH_EDGES_CLR  =================================================== */
#define GPIO_0_INT_BOTH_EDGES_CLR_INT_BOTH_EDGES_CLR_Pos (0UL)      /*!< INT_BOTH_EDGES_CLR (Bit 0)                            */
#define GPIO_0_INT_BOTH_EDGES_CLR_INT_BOTH_EDGES_CLR_Msk (0xffUL)   /*!< INT_BOTH_EDGES_CLR (Bitfield-Mask: 0xff)              */
/* ====================================================  INT_BOTH_EDGES  ===================================================== */
#define GPIO_0_INT_BOTH_EDGES_INT_BOTH_EDGES_Pos (0UL)              /*!< INT_BOTH_EDGES (Bit 0)                                */
#define GPIO_0_INT_BOTH_EDGES_INT_BOTH_EDGES_Msk (0xffUL)           /*!< INT_BOTH_EDGES (Bitfield-Mask: 0xff)                  */
/* =====================================================  INT_EVENT_SET  ===================================================== */
#define GPIO_0_INT_EVENT_SET_INT_EVENT_SET_Pos (0UL)                /*!< INT_EVENT_SET (Bit 0)                                 */
#define GPIO_0_INT_EVENT_SET_INT_EVENT_SET_Msk (0xffUL)             /*!< INT_EVENT_SET (Bitfield-Mask: 0xff)                   */
/* =====================================================  INT_EVENT_CLR  ===================================================== */
#define GPIO_0_INT_EVENT_CLR_INT_EVENT_CLR_Pos (0UL)                /*!< INT_EVENT_CLR (Bit 0)                                 */
#define GPIO_0_INT_EVENT_CLR_INT_EVENT_CLR_Msk (0xffUL)             /*!< INT_EVENT_CLR (Bitfield-Mask: 0xff)                   */
/* =======================================================  INT_EVENT  ======================================================= */
#define GPIO_0_INT_EVENT_INT_EVENT_Pos    (0UL)                     /*!< INT_EVENT (Bit 0)                                     */
#define GPIO_0_INT_EVENT_INT_EVENT_Msk    (0xffUL)                  /*!< INT_EVENT (Bitfield-Mask: 0xff)                       */
/* =====================================================  INT_MASK_SET  ====================================================== */
#define GPIO_0_INT_MASK_SET_INT_MASK_SET_Pos (0UL)                  /*!< INT_MASK_SET (Bit 0)                                  */
#define GPIO_0_INT_MASK_SET_INT_MASK_SET_Msk (0xffUL)               /*!< INT_MASK_SET (Bitfield-Mask: 0xff)                    */
/* =====================================================  INT_MASK_CLR  ====================================================== */
#define GPIO_0_INT_MASK_CLR_INT_MASK_CLR_Pos (0UL)                  /*!< INT_MASK_CLR (Bit 0)                                  */
#define GPIO_0_INT_MASK_CLR_INT_MASK_CLR_Msk (0xffUL)               /*!< INT_MASK_CLR (Bitfield-Mask: 0xff)                    */
/* =======================================================  INT_MASK  ======================================================== */
#define GPIO_0_INT_MASK_INT_MASK_Pos      (0UL)                     /*!< INT_MASK (Bit 0)                                      */
#define GPIO_0_INT_MASK_INT_MASK_Msk      (0xffUL)                  /*!< INT_MASK (Bitfield-Mask: 0xff)                        */
/* ======================================================  INT_STATUS  ======================================================= */
#define GPIO_0_INT_STATUS_INT_STATUS_Pos  (0UL)                     /*!< INT_STATUS (Bit 0)                                    */
#define GPIO_0_INT_STATUS_INT_STATUS_Msk  (0xffUL)                  /*!< INT_STATUS (Bitfield-Mask: 0xff)                      */
/* ===================================================  INT_MASKED_STATUS  =================================================== */
#define GPIO_0_INT_MASKED_STATUS_INT_MASKED_STATUS_Pos (0UL)        /*!< INT_MASKED_STATUS (Bit 0)                             */
#define GPIO_0_INT_MASKED_STATUS_INT_MASKED_STATUS_Msk (0xffUL)     /*!< INT_MASKED_STATUS (Bitfield-Mask: 0xff)               */
/* ========================================================  INT_CLR  ======================================================== */
#define GPIO_0_INT_CLR_INT_CLR_Pos        (0UL)                     /*!< INT_CLR (Bit 0)                                       */
#define GPIO_0_INT_CLR_INT_CLR_Msk        (0xffUL)                  /*!< INT_CLR (Bitfield-Mask: 0xff)                         */
/* ========================================================  DISABLE  ======================================================== */
#define GPIO_0_DISABLE_DISABLE_Pos        (0UL)                     /*!< DISABLE (Bit 0)                                       */
#define GPIO_0_DISABLE_DISABLE_Msk        (0x1UL)                   /*!< DISABLE (Bitfield-Mask: 0x01)                         */
/* ====================================================  DATA_FOR_OUTPUT  ==================================================== */
#define GPIO_0_DATA_FOR_OUTPUT_DATA_FOR_OUTPUT_Pos (0UL)            /*!< DATA_FOR_OUTPUT (Bit 0)                               */
#define GPIO_0_DATA_FOR_OUTPUT_DATA_FOR_OUTPUT_Msk (0xffUL)         /*!< DATA_FOR_OUTPUT (Bitfield-Mask: 0xff)                 */
/* ==================================================  INT_TICK_TYPE0_SET  =================================================== */
#define GPIO_0_INT_TICK_TYPE0_SET_INT_TICK_TYPE0_SET_Pos (0UL)      /*!< INT_TICK_TYPE0_SET (Bit 0)                            */
#define GPIO_0_INT_TICK_TYPE0_SET_INT_TICK_TYPE0_SET_Msk (0xffUL)   /*!< INT_TICK_TYPE0_SET (Bitfield-Mask: 0xff)              */
/* ==================================================  INT_TICK_TYPE0_CLR  =================================================== */
#define GPIO_0_INT_TICK_TYPE0_CLR_INT_TICK_TYPE0_CLR_Pos (0UL)      /*!< INT_TICK_TYPE0_CLR (Bit 0)                            */
#define GPIO_0_INT_TICK_TYPE0_CLR_INT_TICK_TYPE0_CLR_Msk (0xffUL)   /*!< INT_TICK_TYPE0_CLR (Bitfield-Mask: 0xff)              */
/* ====================================================  INT_TICK_TYPE0  ===================================================== */
#define GPIO_0_INT_TICK_TYPE0_INT_TICK_TYPE0_Pos (0UL)              /*!< INT_TICK_TYPE0 (Bit 0)                                */
#define GPIO_0_INT_TICK_TYPE0_INT_TICK_TYPE0_Msk (0xffUL)           /*!< INT_TICK_TYPE0 (Bitfield-Mask: 0xff)                  */
/* ==================================================  INT_TICK_TYPE1_SET  =================================================== */
#define GPIO_0_INT_TICK_TYPE1_SET_INT_TICK_TYPE1_SET_Pos (0UL)      /*!< INT_TICK_TYPE1_SET (Bit 0)                            */
#define GPIO_0_INT_TICK_TYPE1_SET_INT_TICK_TYPE1_SET_Msk (0xffUL)   /*!< INT_TICK_TYPE1_SET (Bitfield-Mask: 0xff)              */
/* ==================================================  INT_TICK_TYPE1_CLR  =================================================== */
#define GPIO_0_INT_TICK_TYPE1_CLR_INT_TICK_TYPE1_CLR_Pos (0UL)      /*!< INT_TICK_TYPE1_CLR (Bit 0)                            */
#define GPIO_0_INT_TICK_TYPE1_CLR_INT_TICK_TYPE1_CLR_Msk (0xffUL)   /*!< INT_TICK_TYPE1_CLR (Bitfield-Mask: 0xff)              */
/* ====================================================  INT_TICK_TYPE1  ===================================================== */
#define GPIO_0_INT_TICK_TYPE1_INT_TICK_TYPE1_Pos (0UL)              /*!< INT_TICK_TYPE1 (Bit 0)                                */
#define GPIO_0_INT_TICK_TYPE1_INT_TICK_TYPE1_Msk (0xffUL)           /*!< INT_TICK_TYPE1 (Bitfield-Mask: 0xff)                  */


/* =========================================================================================================================== */
/* ================                                       GP_TIMER_INTR                                       ================ */
/* =========================================================================================================================== */

/* ==========================================================  EN  =========================================================== */
#define GP_TIMER_INTR_0_EN_EN_Pos         (0UL)                     /*!< EN (Bit 0)                                            */
#define GP_TIMER_INTR_0_EN_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =======================================================  SET_VALUE  ======================================================= */
#define GP_TIMER_INTR_0_SET_VALUE_SET_VALUE_Pos (0UL)               /*!< SET_VALUE (Bit 0)                                     */
#define GP_TIMER_INTR_0_SET_VALUE_SET_VALUE_Msk (0xffffffffUL)      /*!< SET_VALUE (Bitfield-Mask: 0xffffffff)                 */
/* ======================================================  SET_OFFSET  ======================================================= */
#define GP_TIMER_INTR_0_SET_OFFSET_SET_OFFSET_Pos (0UL)             /*!< SET_OFFSET (Bit 0)                                    */
#define GP_TIMER_INTR_0_SET_OFFSET_SET_OFFSET_Msk (0xffffUL)        /*!< SET_OFFSET (Bitfield-Mask: 0xffff)                    */
/* ========================================================  TARGET  ========================================================= */
#define GP_TIMER_INTR_0_TARGET_TARGET_Pos (0UL)                     /*!< TARGET (Bit 0)                                        */
#define GP_TIMER_INTR_0_TARGET_TARGET_Msk (0xffffffffUL)            /*!< TARGET (Bitfield-Mask: 0xffffffff)                    */
/* =========================================================  VALUE  ========================================================= */
#define GP_TIMER_INTR_0_VALUE_VALUE_Pos   (0UL)                     /*!< VALUE (Bit 0)                                         */
#define GP_TIMER_INTR_0_VALUE_VALUE_Msk   (0xffffffffUL)            /*!< VALUE (Bitfield-Mask: 0xffffffff)                     */


/* =========================================================================================================================== */
/* ================                                   SHADOW_32K_TIMER_INTR                                   ================ */
/* =========================================================================================================================== */

/* ==========================================================  EN  =========================================================== */
#define SHADOW_32K_TIMER_INTR_EN_EN_Pos   (0UL)                     /*!< EN (Bit 0)                                            */
#define SHADOW_32K_TIMER_INTR_EN_EN_Msk   (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =======================================================  SET_VALUE  ======================================================= */
#define SHADOW_32K_TIMER_INTR_SET_VALUE_SET_VALUE_Pos (0UL)         /*!< SET_VALUE (Bit 0)                                     */
#define SHADOW_32K_TIMER_INTR_SET_VALUE_SET_VALUE_Msk (0xffffffffUL) /*!< SET_VALUE (Bitfield-Mask: 0xffffffff)                */
/* ======================================================  SET_OFFSET  ======================================================= */
#define SHADOW_32K_TIMER_INTR_SET_OFFSET_SET_OFFSET_Pos (0UL)       /*!< SET_OFFSET (Bit 0)                                    */
#define SHADOW_32K_TIMER_INTR_SET_OFFSET_SET_OFFSET_Msk (0xffffUL)  /*!< SET_OFFSET (Bitfield-Mask: 0xffff)                    */
/* ========================================================  TARGET  ========================================================= */
#define SHADOW_32K_TIMER_INTR_TARGET_TARGET_Pos (0UL)               /*!< TARGET (Bit 0)                                        */
#define SHADOW_32K_TIMER_INTR_TARGET_TARGET_Msk (0xffffffffUL)      /*!< TARGET (Bitfield-Mask: 0xffffffff)                    */
/* =========================================================  VALUE  ========================================================= */
#define SHADOW_32K_TIMER_INTR_VALUE_VALUE_Pos (0UL)                 /*!< VALUE (Bit 0)                                         */
#define SHADOW_32K_TIMER_INTR_VALUE_VALUE_Msk (0xffffffffUL)        /*!< VALUE (Bitfield-Mask: 0xffffffff)                     */


/* =========================================================================================================================== */
/* ================                                   SHADOW_32K_TIMER_CTRL                                   ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define SHADOW_32K_TIMER_CTRL_CTRL_EN_Pos (0UL)                     /*!< EN (Bit 0)                                            */
#define SHADOW_32K_TIMER_CTRL_CTRL_EN_Msk (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  PRESET_VALUE  ====================================================== */
#define SHADOW_32K_TIMER_CTRL_PRESET_VALUE_PRESET_VALUE_Pos (0UL)   /*!< PRESET_VALUE (Bit 0)                                  */
#define SHADOW_32K_TIMER_CTRL_PRESET_VALUE_PRESET_VALUE_Msk (0xffffffffUL) /*!< PRESET_VALUE (Bitfield-Mask: 0xffffffff)       */
/* ======================================================  UPDT_OFFSET  ====================================================== */
#define SHADOW_32K_TIMER_CTRL_UPDT_OFFSET_OFFSET_VALUE_Pos (0UL)    /*!< OFFSET_VALUE (Bit 0)                                  */
#define SHADOW_32K_TIMER_CTRL_UPDT_OFFSET_OFFSET_VALUE_Msk (0xffffffffUL) /*!< OFFSET_VALUE (Bitfield-Mask: 0xffffffff)        */
/* =========================================================  VALUE  ========================================================= */
#define SHADOW_32K_TIMER_CTRL_VALUE_VALUE_Pos (0UL)                 /*!< VALUE (Bit 0)                                         */
#define SHADOW_32K_TIMER_CTRL_VALUE_VALUE_Msk (0xffffffffUL)        /*!< VALUE (Bitfield-Mask: 0xffffffff)                     */
/* ==========================================================  INT  ========================================================== */
#define SHADOW_32K_TIMER_CTRL_INT_INT_Pos (0UL)                     /*!< INT (Bit 0)                                           */
#define SHADOW_32K_TIMER_CTRL_INT_INT_Msk (0x1UL)                   /*!< INT (Bitfield-Mask: 0x01)                             */


/* =========================================================================================================================== */
/* ================                                            WD                                             ================ */
/* =========================================================================================================================== */

/* ========================================================  CONFIG  ========================================================= */
#define WD_CONFIG_ENABLE_Pos              (0UL)                     /*!< ENABLE (Bit 0)                                        */
#define WD_CONFIG_ENABLE_Msk              (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define WD_CONFIG_INT_MASK_Pos            (4UL)                     /*!< INT_MASK (Bit 4)                                      */
#define WD_CONFIG_INT_MASK_Msk            (0x10UL)                  /*!< INT_MASK (Bitfield-Mask: 0x01)                        */
#define WD_CONFIG_RST_EN_Pos              (8UL)                     /*!< RST_EN (Bit 8)                                        */
#define WD_CONFIG_RST_EN_Msk              (0x300UL)                 /*!< RST_EN (Bitfield-Mask: 0x03)                          */
#define WD_CONFIG_LTE_MIPS_EJ_DEBUGM_0_EN_Pos (12UL)                /*!< LTE_MIPS_EJ_DEBUGM_0_EN (Bit 12)                      */
#define WD_CONFIG_LTE_MIPS_EJ_DEBUGM_0_EN_Msk (0x1000UL)            /*!< LTE_MIPS_EJ_DEBUGM_0_EN (Bitfield-Mask: 0x01)         */
#define WD_CONFIG_NET_MIPS_EJ_DEBUGM_0_EN_Pos (14UL)                /*!< NET_MIPS_EJ_DEBUGM_0_EN (Bit 14)                      */
#define WD_CONFIG_NET_MIPS_EJ_DEBUGM_0_EN_Msk (0x4000UL)            /*!< NET_MIPS_EJ_DEBUGM_0_EN (Bitfield-Mask: 0x01)         */
#define WD_CONFIG_PHY_MIPS_EJ_DEBUGM_0_EN_Pos (18UL)                /*!< PHY_MIPS_EJ_DEBUGM_0_EN (Bit 18)                      */
#define WD_CONFIG_PHY_MIPS_EJ_DEBUGM_0_EN_Msk (0x40000UL)           /*!< PHY_MIPS_EJ_DEBUGM_0_EN (Bitfield-Mask: 0x01)         */
#define WD_CONFIG_PMP_MIPS_EJ_DEBUGM_0_EN_Pos (19UL)                /*!< PMP_MIPS_EJ_DEBUGM_0_EN (Bit 19)                      */
#define WD_CONFIG_PMP_MIPS_EJ_DEBUGM_0_EN_Msk (0x80000UL)           /*!< PMP_MIPS_EJ_DEBUGM_0_EN (Bitfield-Mask: 0x01)         */
#define WD_CONFIG_MCU_ARM_EJ_DEBUGM_0_EN_Pos (20UL)                 /*!< MCU_ARM_EJ_DEBUGM_0_EN (Bit 20)                       */
#define WD_CONFIG_MCU_ARM_EJ_DEBUGM_0_EN_Msk (0x100000UL)           /*!< MCU_ARM_EJ_DEBUGM_0_EN (Bitfield-Mask: 0x01)          */
/* =======================================================  CNT_LOAD  ======================================================== */
#define WD_CNT_LOAD_LOAD_VAL_Pos          (8UL)                     /*!< LOAD_VAL (Bit 8)                                      */
#define WD_CNT_LOAD_LOAD_VAL_Msk          (0xffffff00UL)            /*!< LOAD_VAL (Bitfield-Mask: 0xffffff)                    */
/* =======================================================  CLEAR_INT  ======================================================= */
#define WD_CLEAR_INT_INT_STAT_Pos         (0UL)                     /*!< INT_STAT (Bit 0)                                      */
#define WD_CLEAR_INT_INT_STAT_Msk         (0x1UL)                   /*!< INT_STAT (Bitfield-Mask: 0x01)                        */
#define WD_CLEAR_INT_RST_LEVEL_Pos        (4UL)                     /*!< RST_LEVEL (Bit 4)                                     */
#define WD_CLEAR_INT_RST_LEVEL_Msk        (0x10UL)                  /*!< RST_LEVEL (Bitfield-Mask: 0x01)                       */
/* ========================================================  STATUS  ========================================================= */
#define WD_STATUS_INT_STAT_Pos            (0UL)                     /*!< INT_STAT (Bit 0)                                      */
#define WD_STATUS_INT_STAT_Msk            (0x1UL)                   /*!< INT_STAT (Bitfield-Mask: 0x01)                        */
#define WD_STATUS_RST_LEVEL_Pos           (4UL)                     /*!< RST_LEVEL (Bit 4)                                     */
#define WD_STATUS_RST_LEVEL_Msk           (0x10UL)                  /*!< RST_LEVEL (Bitfield-Mask: 0x01)                       */
/* ========================================================  CNT_VAL  ======================================================== */
#define WD_CNT_VAL_COUNTER_VAL_Pos        (0UL)                     /*!< COUNTER_VAL (Bit 0)                                   */
#define WD_CNT_VAL_COUNTER_VAL_Msk        (0xffffffffUL)            /*!< COUNTER_VAL (Bitfield-Mask: 0xffffffff)               */
/* ========================================================  PROTECT  ======================================================== */
#define WD_PROTECT_PROTECT_WORD_Pos       (0UL)                     /*!< PROTECT_WORD (Bit 0)                                  */
#define WD_PROTECT_PROTECT_WORD_Msk       (0xffffUL)                /*!< PROTECT_WORD (Bitfield-Mask: 0xffff)                  */


/* =========================================================================================================================== */
/* ================                                       IO_WKUP_CTRL                                        ================ */
/* =========================================================================================================================== */

/* ====================================================  WAKEUP_0_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_DEBOUNCE_EN_Pos (5UL)           /*!< DEBOUNCE_EN (Bit 5)                                   */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_DEBOUNCE_EN_Msk (0x20UL)        /*!< DEBOUNCE_EN (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_0_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL1_DEBOUNCE_MAX_VAL_Pos (0UL)      /*!< DEBOUNCE_MAX_VAL (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_0_CTRL1_DEBOUNCE_MAX_VAL_Msk (0x3ffUL)  /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0x3ff)               */
/* ======================================================  WAKEUP_0_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_0_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_0_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_0_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_0_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_0_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_0_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_0_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_0_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_0_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_0_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_1_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_DEBOUNCE_EN_Pos (5UL)           /*!< DEBOUNCE_EN (Bit 5)                                   */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_DEBOUNCE_EN_Msk (0x20UL)        /*!< DEBOUNCE_EN (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_1_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL1_DEBOUNCE_MAX_VAL_Pos (0UL)      /*!< DEBOUNCE_MAX_VAL (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_1_CTRL1_DEBOUNCE_MAX_VAL_Msk (0x3ffUL)  /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0x3ff)               */
/* ======================================================  WAKEUP_1_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_1_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_1_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_1_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_1_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_1_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_1_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_1_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_1_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_1_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_1_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_2_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_DEBOUNCE_EN_Pos (5UL)           /*!< DEBOUNCE_EN (Bit 5)                                   */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_DEBOUNCE_EN_Msk (0x20UL)        /*!< DEBOUNCE_EN (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_2_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL1_DEBOUNCE_MAX_VAL_Pos (0UL)      /*!< DEBOUNCE_MAX_VAL (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_2_CTRL1_DEBOUNCE_MAX_VAL_Msk (0x3ffUL)  /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0x3ff)               */
/* ======================================================  WAKEUP_2_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_2_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_2_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_2_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_2_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_2_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_2_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_2_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_2_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_2_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_2_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_3_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_DEBOUNCE_EN_Pos (5UL)           /*!< DEBOUNCE_EN (Bit 5)                                   */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_DEBOUNCE_EN_Msk (0x20UL)        /*!< DEBOUNCE_EN (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_3_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL1_DEBOUNCE_MAX_VAL_Pos (0UL)      /*!< DEBOUNCE_MAX_VAL (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_3_CTRL1_DEBOUNCE_MAX_VAL_Msk (0x3ffUL)  /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0x3ff)               */
/* ======================================================  WAKEUP_3_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_3_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_3_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_3_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_3_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_3_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_3_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_3_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_3_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_3_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_3_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_4_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_DEBOUNCE_EN_Pos (5UL)           /*!< DEBOUNCE_EN (Bit 5)                                   */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_DEBOUNCE_EN_Msk (0x20UL)        /*!< DEBOUNCE_EN (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_4_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL1_DEBOUNCE_MAX_VAL_Pos (0UL)      /*!< DEBOUNCE_MAX_VAL (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_4_CTRL1_DEBOUNCE_MAX_VAL_Msk (0x3ffUL)  /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0x3ff)               */
/* ======================================================  WAKEUP_4_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_4_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_4_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_4_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_4_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_4_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_4_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_4_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_4_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_4_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_4_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_5_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_5_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_5_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
/* ======================================================  WAKEUP_5_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_5_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_5_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_5_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_5_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_5_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_5_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_5_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_5_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_5_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_5_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_6_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_6_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_6_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
/* ======================================================  WAKEUP_6_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_6_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_6_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_6_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_6_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_6_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_6_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_6_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_6_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_6_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_6_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_7_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_7_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_7_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
/* ======================================================  WAKEUP_7_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_7_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_7_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_7_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_7_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_7_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_7_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_7_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_7_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_7_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_7_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_8_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_8_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_8_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
/* ======================================================  WAKEUP_8_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_8_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_8_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_8_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_8_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_8_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_8_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_8_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_8_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_8_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_8_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ====================================================  WAKEUP_9_CTRL0  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_CLK_SELECT_Pos (6UL)            /*!< CLK_SELECT (Bit 6)                                    */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_CLK_SELECT_Msk (0x40UL)         /*!< CLK_SELECT (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_POL_CHANGE_Pos (4UL)            /*!< POL_CHANGE (Bit 4)                                    */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_POL_CHANGE_Msk (0x10UL)         /*!< POL_CHANGE (Bitfield-Mask: 0x01)                      */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_ASYNC_WAKEUP_Pos (3UL)          /*!< ASYNC_WAKEUP (Bit 3)                                  */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_ASYNC_WAKEUP_Msk (0x8UL)        /*!< ASYNC_WAKEUP (Bitfield-Mask: 0x01)                    */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_EDGE_KIND_Pos (1UL)             /*!< EDGE_KIND (Bit 1)                                     */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_EDGE_KIND_Msk (0x6UL)           /*!< EDGE_KIND (Bitfield-Mask: 0x03)                       */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_EDGE_EN_Pos (0UL)               /*!< EDGE_EN (Bit 0)                                       */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL0_EDGE_EN_Msk (0x1UL)             /*!< EDGE_EN (Bitfield-Mask: 0x01)                         */
/* ====================================================  WAKEUP_9_CTRL1  ===================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL1_WAKEUP_IO_SEL_Pos (10UL)        /*!< WAKEUP_IO_SEL (Bit 10)                                */
#define IO_WKUP_CTRL_WAKEUP_9_CTRL1_WAKEUP_IO_SEL_Msk (0xfc00UL)    /*!< WAKEUP_IO_SEL (Bitfield-Mask: 0x3f)                   */
/* ======================================================  WAKEUP_9_EN  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_EN_WAKEUP_EN_Pos (0UL)                /*!< WAKEUP_EN (Bit 0)                                     */
#define IO_WKUP_CTRL_WAKEUP_9_EN_WAKEUP_EN_Msk (0x1UL)              /*!< WAKEUP_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  WAKEUP_9_INT_EN  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_INT_EN_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_9_INT_EN_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
/* =====================================================  WAKEUP_9_INT  ====================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_INT_IO_RAW_DATA_Pos (1UL)             /*!< IO_RAW_DATA (Bit 1)                                   */
#define IO_WKUP_CTRL_WAKEUP_9_INT_IO_RAW_DATA_Msk (0x2UL)           /*!< IO_RAW_DATA (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_9_INT_INT_GPMCLK_Pos (0UL)              /*!< INT_GPMCLK (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_9_INT_INT_GPMCLK_Msk (0x1UL)            /*!< INT_GPMCLK (Bitfield-Mask: 0x01)                      */
/* ===================================================  WAKEUP_9_INT_RCLR  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_9_INT_RCLR_INT_GPMCLK_RCLK_Pos (0UL)    /*!< INT_GPMCLK_RCLK (Bit 0)                               */
#define IO_WKUP_CTRL_WAKEUP_9_INT_RCLR_INT_GPMCLK_RCLK_Msk (0x1UL)  /*!< INT_GPMCLK_RCLK (Bitfield-Mask: 0x01)                 */
/* ===================================================  WAKEUP_UART0_CTRL  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_RTS_POL_Pos (3UL)            /*!< RTS_POL (Bit 3)                                       */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_RTS_POL_Msk (0x8UL)          /*!< RTS_POL (Bitfield-Mask: 0x01)                         */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_WKUP_RX_POL_Pos (2UL)        /*!< WKUP_RX_POL (Bit 2)                                   */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_WKUP_RX_POL_Msk (0x4UL)      /*!< WKUP_RX_POL (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_WKUP_INT_EN_Pos (0UL)        /*!< WKUP_INT_EN (Bit 0)                                   */
#define IO_WKUP_CTRL_WAKEUP_UART0_CTRL_WKUP_INT_EN_Msk (0x1UL)      /*!< WKUP_INT_EN (Bitfield-Mask: 0x01)                     */
/* ==================================================  WAKEUP_UART0_IN_SEL  ================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART0_IN_SEL_IN_SEL_Pos (0UL)           /*!< IN_SEL (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_UART0_IN_SEL_IN_SEL_Msk (0x7UL)         /*!< IN_SEL (Bitfield-Mask: 0x07)                          */
/* ===================================================  WAKEUP_UART0_INT  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART0_INT_WAKEUP_INT_Pos (0UL)          /*!< WAKEUP_INT (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_UART0_INT_WAKEUP_INT_Msk (0x1UL)        /*!< WAKEUP_INT (Bitfield-Mask: 0x01)                      */
/* =================================================  WAKEUP_UART0_INT_RCLR  ================================================= */
#define IO_WKUP_CTRL_WAKEUP_UART0_INT_RCLR_WAKEUP_INT_RCLR_Pos (0UL) /*!< WAKEUP_INT_RCLR (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_UART0_INT_RCLR_WAKEUP_INT_RCLR_Msk (0x1UL) /*!< WAKEUP_INT_RCLR (Bitfield-Mask: 0x01)              */
/* ===================================================  WAKEUP_UART1_CTRL  =================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_RTS_POL_Pos (3UL)            /*!< RTS_POL (Bit 3)                                       */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_RTS_POL_Msk (0x8UL)          /*!< RTS_POL (Bitfield-Mask: 0x01)                         */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_WKUP_RX_POL_Pos (2UL)        /*!< WKUP_RX_POL (Bit 2)                                   */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_WKUP_RX_POL_Msk (0x4UL)      /*!< WKUP_RX_POL (Bitfield-Mask: 0x01)                     */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_WKUP_INT_EN_Pos (0UL)        /*!< WKUP_INT_EN (Bit 0)                                   */
#define IO_WKUP_CTRL_WAKEUP_UART1_CTRL_WKUP_INT_EN_Msk (0x1UL)      /*!< WKUP_INT_EN (Bitfield-Mask: 0x01)                     */
/* ==================================================  WAKEUP_UART1_IN_SEL  ================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART1_IN_SEL_IN_SEL_Pos (0UL)           /*!< IN_SEL (Bit 0)                                        */
#define IO_WKUP_CTRL_WAKEUP_UART1_IN_SEL_IN_SEL_Msk (0x7UL)         /*!< IN_SEL (Bitfield-Mask: 0x07)                          */
/* ===================================================  WAKEUP_UART1_INT  ==================================================== */
#define IO_WKUP_CTRL_WAKEUP_UART1_INT_WAKEUP_INT_Pos (0UL)          /*!< WAKEUP_INT (Bit 0)                                    */
#define IO_WKUP_CTRL_WAKEUP_UART1_INT_WAKEUP_INT_Msk (0x1UL)        /*!< WAKEUP_INT (Bitfield-Mask: 0x01)                      */
/* =================================================  WAKEUP_UART1_INT_RCLR  ================================================= */
#define IO_WKUP_CTRL_WAKEUP_UART1_INT_RCLR_WAKEUP_INT_RCLR_Pos (0UL) /*!< WAKEUP_INT_RCLR (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_UART1_INT_RCLR_WAKEUP_INT_RCLR_Msk (0x1UL) /*!< WAKEUP_INT_RCLR (Bitfield-Mask: 0x01)              */
/* ==================================================  WAKEUP_KEYPAD_CTRL0  ================================================== */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_CLK_SEL_Pos (16UL) /*!< KEYPAD_WAKEUP_CLK_SEL (Bit 16)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_CLK_SEL_Msk (0x10000UL) /*!< KEYPAD_WAKEUP_CLK_SEL (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_INT_EN_Pos (14UL) /*!< KEYPAD_WAKEUP_INT_EN (Bit 14)                    */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_INT_EN_Msk (0x4000UL) /*!< KEYPAD_WAKEUP_INT_EN (Bitfield-Mask: 0x01)   */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_DEBOUNCE_MAX_VAL_Pos (2UL) /*!< DEBOUNCE_MAX_VAL (Bit 2)                              */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_DEBOUNCE_MAX_VAL_Msk (0x3ffcUL) /*!< DEBOUNCE_MAX_VAL (Bitfield-Mask: 0xfff)          */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KAYPAD_WAKEUP_START_VAL_CAPTURE_Pos (1UL) /*!< KAYPAD_WAKEUP_START_VAL_CAPTURE (Bit 1) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KAYPAD_WAKEUP_START_VAL_CAPTURE_Msk (0x2UL) /*!< KAYPAD_WAKEUP_START_VAL_CAPTURE (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_EN_Pos (0UL) /*!< KEYPAD_WAKEUP_EN (Bit 0)                              */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_CTRL0_KEYPAD_WAKEUP_EN_Msk (0x1UL) /*!< KEYPAD_WAKEUP_EN (Bitfield-Mask: 0x01)              */
/* =============================================  WAKEUP_KEYPAD_START_DATA_VAL  ============================================== */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_START_DATA_VAL_KEYPAD_START_DATA_VAL_Pos (0UL) /*!< KEYPAD_START_DATA_VAL (Bit 0)           */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_START_DATA_VAL_KEYPAD_START_DATA_VAL_Msk (0x3ffUL) /*!< KEYPAD_START_DATA_VAL (Bitfield-Mask: 0x3ff) */
/* ================================================  WAKEUP_KEYPAD_INT_STAT  ================================================= */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_EN_STAT_Pos (31UL) /*!< KEYPAD_WAKEUP_EN_STAT (Bit 31)               */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_EN_STAT_Msk (0x80000000UL) /*!< KEYPAD_WAKEUP_EN_STAT (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_DIFF_ARRAY_Pos (2UL) /*!< KEYPAD_WAKEUP_INT_DIFF_ARRAY (Bit 2)   */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_DIFF_ARRAY_Msk (0xffcUL) /*!< KEYPAD_WAKEUP_INT_DIFF_ARRAY (Bitfield-Mask: 0x3ff) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_ASYNC_Pos (1UL) /*!< KEYPAD_WAKEUP_INT_ASYNC (Bit 1)             */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_ASYNC_Msk (0x2UL) /*!< KEYPAD_WAKEUP_INT_ASYNC (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_GPMCLK_Pos (0UL) /*!< KEYPAD_WAKEUP_INT_GPMCLK (Bit 0)           */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_KEYPAD_WAKEUP_INT_GPMCLK_Msk (0x1UL) /*!< KEYPAD_WAKEUP_INT_GPMCLK (Bitfield-Mask: 0x01) */
/* ==============================================  WAKEUP_KEYPAD_INT_STAT_RCLR  ============================================== */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_EN_STAT_RCLR_Pos (31UL) /*!< KEYPAD_WAKEUP_EN_STAT_RCLR (Bit 31) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_EN_STAT_RCLR_Msk (0x80000000UL) /*!< KEYPAD_WAKEUP_EN_STAT_RCLR (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_DIFF_ARRAY_RCLR_Pos (2UL) /*!< KEYPAD_WAKEUP_INT_DIFF_ARRAY_RCLR (Bit 2) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_DIFF_ARRAY_RCLR_Msk (0xffcUL) /*!< KEYPAD_WAKEUP_INT_DIFF_ARRAY_RCLR (Bitfield-Mask: 0x3ff) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_ASYNC_RCLR_Pos (1UL) /*!< KEYPAD_WAKEUP_INT_ASYNC_RCLR (Bit 1) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_ASYNC_RCLR_Msk (0x2UL) /*!< KEYPAD_WAKEUP_INT_ASYNC_RCLR (Bitfield-Mask: 0x01) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_GPMCLK_RCLR_Pos (0UL) /*!< KEYPAD_WAKEUP_INT_GPMCLK_RCLR (Bit 0) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_INT_STAT_RCLR_KEYPAD_WAKEUP_INT_GPMCLK_RCLR_Msk (0x1UL) /*!< KEYPAD_WAKEUP_INT_GPMCLK_RCLR (Bitfield-Mask: 0x01) */
/* =================================================  WAKEUP_KEYPAD_IO_SEL0  ================================================= */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL7_Pos (14UL) /*!< KEYPAD_WAKEUP_IO_SEL7 (Bit 14)                */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL7_Msk (0xc000UL) /*!< KEYPAD_WAKEUP_IO_SEL7 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL6_Pos (12UL) /*!< KEYPAD_WAKEUP_IO_SEL6 (Bit 12)                */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL6_Msk (0x3000UL) /*!< KEYPAD_WAKEUP_IO_SEL6 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL5_Pos (10UL) /*!< KEYPAD_WAKEUP_IO_SEL5 (Bit 10)                */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL5_Msk (0xc00UL) /*!< KEYPAD_WAKEUP_IO_SEL5 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL4_Pos (8UL) /*!< KEYPAD_WAKEUP_IO_SEL4 (Bit 8)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL4_Msk (0x300UL) /*!< KEYPAD_WAKEUP_IO_SEL4 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL3_Pos (6UL) /*!< KEYPAD_WAKEUP_IO_SEL3 (Bit 6)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL3_Msk (0xc0UL) /*!< KEYPAD_WAKEUP_IO_SEL3 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL2_Pos (4UL) /*!< KEYPAD_WAKEUP_IO_SEL2 (Bit 4)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL2_Msk (0x30UL) /*!< KEYPAD_WAKEUP_IO_SEL2 (Bitfield-Mask: 0x03) */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL1_Pos (2UL) /*!< KEYPAD_WAKEUP_IO_SEL1 (Bit 2)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL1_Msk (0xcUL) /*!< KEYPAD_WAKEUP_IO_SEL1 (Bitfield-Mask: 0x03)  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL0_Pos (0UL) /*!< KEYPAD_WAKEUP_IO_SEL0 (Bit 0)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL0_KEYPAD_WAKEUP_IO_SEL0_Msk (0x3UL) /*!< KEYPAD_WAKEUP_IO_SEL0 (Bitfield-Mask: 0x03)  */
/* =================================================  WAKEUP_KEYPAD_IO_SEL1  ================================================= */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL1_KEYPAD_WAKEUP_IO_SEL9_Pos (2UL) /*!< KEYPAD_WAKEUP_IO_SEL9 (Bit 2)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL1_KEYPAD_WAKEUP_IO_SEL9_Msk (0xcUL) /*!< KEYPAD_WAKEUP_IO_SEL9 (Bitfield-Mask: 0x03)  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL1_KEYPAD_WAKEUP_IO_SEL8_Pos (0UL) /*!< KEYPAD_WAKEUP_IO_SEL8 (Bit 0)                  */
#define IO_WKUP_CTRL_WAKEUP_KEYPAD_IO_SEL1_KEYPAD_WAKEUP_IO_SEL8_Msk (0x3UL) /*!< KEYPAD_WAKEUP_IO_SEL8 (Bitfield-Mask: 0x03)  */
/* ======================================================  EXTRET_STAT  ====================================================== */
#define IO_WKUP_CTRL_EXTRET_STAT_EXTRET_0_Pos (0UL)                 /*!< EXTRET_0 (Bit 0)                                      */
#define IO_WKUP_CTRL_EXTRET_STAT_EXTRET_0_Msk (0x1UL)               /*!< EXTRET_0 (Bitfield-Mask: 0x01)                        */


/* =========================================================================================================================== */
/* ================                                  ATOMIC_COUNTER_MAILBOX                                   ================ */
/* =========================================================================================================================== */

/* ==========================================================  INC  ========================================================== */
#define ATOMIC_COUNTER_MAILBOX4_INC_INC_Pos (0UL)                   /*!< INC (Bit 0)                                           */
#define ATOMIC_COUNTER_MAILBOX4_INC_INC_Msk (0xffUL)                /*!< INC (Bitfield-Mask: 0xff)                             */
/* ==========================================================  DEC  ========================================================== */
#define ATOMIC_COUNTER_MAILBOX4_DEC_DEC_Pos (0UL)                   /*!< DEC (Bit 0)                                           */
#define ATOMIC_COUNTER_MAILBOX4_DEC_DEC_Msk (0xffUL)                /*!< DEC (Bitfield-Mask: 0xff)                             */
/* =========================================================  CTRL  ========================================================== */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_INT_EN_Pos (0UL)               /*!< INT_EN (Bit 0)                                        */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_INT_EN_Msk (0x1UL)             /*!< INT_EN (Bitfield-Mask: 0x01)                          */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_INT_MODE_Pos (1UL)             /*!< INT_MODE (Bit 1)                                      */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_INT_MODE_Msk (0x6UL)           /*!< INT_MODE (Bitfield-Mask: 0x03)                        */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_HW_EN_Pos (3UL)                /*!< HW_EN (Bit 3)                                         */
#define ATOMIC_COUNTER_MAILBOX4_CTRL_HW_EN_Msk (0x8UL)              /*!< HW_EN (Bitfield-Mask: 0x01)                           */
/* =======================================================  INT_STAT  ======================================================== */
#define ATOMIC_COUNTER_MAILBOX4_INT_STAT_INT_STAT_Pos (0UL)         /*!< INT_STAT (Bit 0)                                      */
#define ATOMIC_COUNTER_MAILBOX4_INT_STAT_INT_STAT_Msk (0x1UL)       /*!< INT_STAT (Bitfield-Mask: 0x01)                        */
/* ==========================================================  VAL  ========================================================== */
#define ATOMIC_COUNTER_MAILBOX4_VAL_VAL_Pos (0UL)                   /*!< VAL (Bit 0)                                           */
#define ATOMIC_COUNTER_MAILBOX4_VAL_VAL_Msk (0xffUL)                /*!< VAL (Bitfield-Mask: 0xff)                             */


/* =========================================================================================================================== */
/* ================                                         LED_CTRL                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  RESTART  ======================================================== */
#define LED_CTRL_RESTART_RESTART_Pos      (0UL)                     /*!< RESTART (Bit 0)                                       */
#define LED_CTRL_RESTART_RESTART_Msk      (0x7ffUL)                 /*!< RESTART (Bitfield-Mask: 0x7ff)                        */
/* =======================================================  CNTR_CFG  ======================================================== */
#define LED_CTRL_CNTR_CFG_GRF_LED_CTRL_CNTR_TARGET_Pos (4UL)        /*!< GRF_LED_CTRL_CNTR_TARGET (Bit 4)                      */
#define LED_CTRL_CNTR_CFG_GRF_LED_CTRL_CNTR_TARGET_Msk (0xffff0UL)  /*!< GRF_LED_CTRL_CNTR_TARGET (Bitfield-Mask: 0xffff)      */
#define LED_CTRL_CNTR_CFG_GRF_LED_CTRL_CNTR_CLK_EN_Pos (0UL)        /*!< GRF_LED_CTRL_CNTR_CLK_EN (Bit 0)                      */
#define LED_CTRL_CNTR_CFG_GRF_LED_CTRL_CNTR_CLK_EN_Msk (0x1UL)      /*!< GRF_LED_CTRL_CNTR_CLK_EN (Bitfield-Mask: 0x01)        */
/* =========================================================  CFG_0  ========================================================= */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_0_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* =========================================================  CFG_1  ========================================================= */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_1_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* =========================================================  CFG_2  ========================================================= */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_2_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* =========================================================  CFG_3  ========================================================= */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_3_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* =========================================================  CFG_4  ========================================================= */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_4_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* =========================================================  CFG_5  ========================================================= */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_OFFSET_Pos (8UL)                /*!< GRF_LED_CTRL_OFFSET (Bit 8)                           */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_OFFSET_Msk (0xfff00UL)          /*!< GRF_LED_CTRL_OFFSET (Bitfield-Mask: 0xfff)            */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_DIM_SEL_Pos (5UL)               /*!< GRF_LED_CTRL_DIM_SEL (Bit 5)                          */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_DIM_SEL_Msk (0x60UL)            /*!< GRF_LED_CTRL_DIM_SEL (Bitfield-Mask: 0x03)            */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_POLARITY_Pos (4UL)              /*!< GRF_LED_CTRL_POLARITY (Bit 4)                         */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_POLARITY_Msk (0x10UL)           /*!< GRF_LED_CTRL_POLARITY (Bitfield-Mask: 0x01)           */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_CLK_EN_Pos (0UL)                /*!< GRF_LED_CTRL_CLK_EN (Bit 0)                           */
#define LED_CTRL_CFG_5_GRF_LED_CTRL_CLK_EN_Msk (0x1UL)              /*!< GRF_LED_CTRL_CLK_EN (Bitfield-Mask: 0x01)             */
/* ======================================================  DURATION_0  ======================================================= */
#define LED_CTRL_DURATION_0_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_0_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_0_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_0_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* ======================================================  DURATION_1  ======================================================= */
#define LED_CTRL_DURATION_1_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_1_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_1_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_1_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* ======================================================  DURATION_2  ======================================================= */
#define LED_CTRL_DURATION_2_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_2_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_2_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_2_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* ======================================================  DURATION_3  ======================================================= */
#define LED_CTRL_DURATION_3_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_3_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_3_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_3_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* ======================================================  DURATION_4  ======================================================= */
#define LED_CTRL_DURATION_4_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_4_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_4_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_4_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* ======================================================  DURATION_5  ======================================================= */
#define LED_CTRL_DURATION_5_GRF_LED_CTRL_OFF_DURATION_Pos (12UL)    /*!< GRF_LED_CTRL_OFF_DURATION (Bit 12)                    */
#define LED_CTRL_DURATION_5_GRF_LED_CTRL_OFF_DURATION_Msk (0xfff000UL) /*!< GRF_LED_CTRL_OFF_DURATION (Bitfield-Mask: 0xfff)   */
#define LED_CTRL_DURATION_5_GRF_LED_CTRL_ON_DURATION_Pos (0UL)      /*!< GRF_LED_CTRL_ON_DURATION (Bit 0)                      */
#define LED_CTRL_DURATION_5_GRF_LED_CTRL_ON_DURATION_Msk (0xfffUL)  /*!< GRF_LED_CTRL_ON_DURATION (Bitfield-Mask: 0xfff)       */
/* =======================================================  DIM_CFG_0  ======================================================= */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_BRIGHT_LEVELS_Pos (26UL) /*!< GRF_LED_CTRL_DIM_BRIGHT_LEVELS (Bit 26)              */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_BRIGHT_LEVELS_Msk (0xfc000000UL) /*!< GRF_LED_CTRL_DIM_BRIGHT_LEVELS (Bitfield-Mask: 0x3f) */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS_Pos (16UL) /*!< GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS (Bit 16)      */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS_Msk (0x3ff0000UL) /*!< GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_HIGH_DELAY_Pos (8UL)    /*!< GRF_LED_CTRL_DIM_HIGH_DELAY (Bit 8)                   */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_HIGH_DELAY_Msk (0xff00UL) /*!< GRF_LED_CTRL_DIM_HIGH_DELAY (Bitfield-Mask: 0xff)   */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_LOW_DELAY_Pos (0UL)     /*!< GRF_LED_CTRL_DIM_LOW_DELAY (Bit 0)                    */
#define LED_CTRL_DIM_CFG_0_GRF_LED_CTRL_DIM_LOW_DELAY_Msk (0xffUL)  /*!< GRF_LED_CTRL_DIM_LOW_DELAY (Bitfield-Mask: 0xff)      */
/* =======================================================  DIM_CFG_1  ======================================================= */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_BRIGHT_LEVELS_Pos (26UL) /*!< GRF_LED_CTRL_DIM_BRIGHT_LEVELS (Bit 26)              */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_BRIGHT_LEVELS_Msk (0xfc000000UL) /*!< GRF_LED_CTRL_DIM_BRIGHT_LEVELS (Bitfield-Mask: 0x3f) */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS_Pos (16UL) /*!< GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS (Bit 16)      */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS_Msk (0x3ff0000UL) /*!< GRF_LED_CTRL_DIM_BASE_UNIT_REPEATS (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_HIGH_DELAY_Pos (8UL)    /*!< GRF_LED_CTRL_DIM_HIGH_DELAY (Bit 8)                   */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_HIGH_DELAY_Msk (0xff00UL) /*!< GRF_LED_CTRL_DIM_HIGH_DELAY (Bitfield-Mask: 0xff)   */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_LOW_DELAY_Pos (0UL)     /*!< GRF_LED_CTRL_DIM_LOW_DELAY (Bit 0)                    */
#define LED_CTRL_DIM_CFG_1_GRF_LED_CTRL_DIM_LOW_DELAY_Msk (0xffUL)  /*!< GRF_LED_CTRL_DIM_LOW_DELAY (Bitfield-Mask: 0xff)      */
/* =====================================================  DIM_STATUS_0  ====================================================== */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_ONEKHZ_CNTR_Pos (22UL)   /*!< LED_CTRL_DIM_ONEKHZ_CNTR (Bit 22)                     */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_ONEKHZ_CNTR_Msk (0xffc00000UL) /*!< LED_CTRL_DIM_ONEKHZ_CNTR (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR_Pos (12UL) /*!< LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR (Bit 12)   */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR_Msk (0x3ff000UL) /*!< LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR_Pos (4UL) /*!< LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR (Bit 4)   */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR_Msk (0xff0UL) /*!< LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR (Bitfield-Mask: 0xff) */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_STATE_Pos (1UL)          /*!< LED_CTRL_DIM_STATE (Bit 1)                            */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_STATE_Msk (0xeUL)        /*!< LED_CTRL_DIM_STATE (Bitfield-Mask: 0x07)              */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_S_Pos (0UL)              /*!< LED_CTRL_DIM_S (Bit 0)                                */
#define LED_CTRL_DIM_STATUS_0_LED_CTRL_DIM_S_Msk (0x1UL)            /*!< LED_CTRL_DIM_S (Bitfield-Mask: 0x01)                  */
/* =====================================================  DIM_STATUS_1  ====================================================== */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_ONEKHZ_CNTR_Pos (22UL)   /*!< LED_CTRL_DIM_ONEKHZ_CNTR (Bit 22)                     */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_ONEKHZ_CNTR_Msk (0xffc00000UL) /*!< LED_CTRL_DIM_ONEKHZ_CNTR (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR_Pos (12UL) /*!< LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR (Bit 12)   */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR_Msk (0x3ff000UL) /*!< LED_CTRL_DIM_BASE_UNIT_REPEAT_CNTR (Bitfield-Mask: 0x3ff) */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR_Pos (4UL) /*!< LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR (Bit 4)   */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR_Msk (0xff0UL) /*!< LED_CTRL_DIM_BRIGHTNESS_LEVELS_CNTR (Bitfield-Mask: 0xff) */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_STATE_Pos (1UL)          /*!< LED_CTRL_DIM_STATE (Bit 1)                            */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_STATE_Msk (0xeUL)        /*!< LED_CTRL_DIM_STATE (Bitfield-Mask: 0x07)              */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_S_Pos (0UL)              /*!< LED_CTRL_DIM_S (Bit 0)                                */
#define LED_CTRL_DIM_STATUS_1_LED_CTRL_DIM_S_Msk (0x1UL)            /*!< LED_CTRL_DIM_S (Bitfield-Mask: 0x01)                  */
/* ======================================================  CNTR_STATUS  ====================================================== */
#define LED_CTRL_CNTR_STATUS_LED_CTRL_CLK_CNTR_Pos (13UL)           /*!< LED_CTRL_CLK_CNTR (Bit 13)                            */
#define LED_CTRL_CNTR_STATUS_LED_CTRL_CLK_CNTR_Msk (0xfffe000UL)    /*!< LED_CTRL_CLK_CNTR (Bitfield-Mask: 0x7fff)             */
#define LED_CTRL_CNTR_STATUS_LED_CTRL_ONEKHZ_CNTR_Pos (0UL)         /*!< LED_CTRL_ONEKHZ_CNTR (Bit 0)                          */
#define LED_CTRL_CNTR_STATUS_LED_CTRL_ONEKHZ_CNTR_Msk (0x1fffUL)    /*!< LED_CTRL_ONEKHZ_CNTR (Bitfield-Mask: 0x1fff)          */
/* ========================================================  STATUS  ========================================================= */
#define LED_CTRL_STATUS_LED_CTRL_LED_1_Pos (1UL)                    /*!< LED_CTRL_LED_1 (Bit 1)                                */
#define LED_CTRL_STATUS_LED_CTRL_LED_1_Msk (0x2UL)                  /*!< LED_CTRL_LED_1 (Bitfield-Mask: 0x01)                  */
#define LED_CTRL_STATUS_LED_CTRL_LED_0_Pos (0UL)                    /*!< LED_CTRL_LED_0 (Bit 0)                                */
#define LED_CTRL_STATUS_LED_CTRL_LED_0_Msk (0x1UL)                  /*!< LED_CTRL_LED_0 (Bitfield-Mask: 0x01)                  */


/* =========================================================================================================================== */
/* ================                                        IO_FUNC_SEL                                        ================ */
/* =========================================================================================================================== */

/* =====================================================  FLASH0_CS_N0  ====================================================== */
#define IO_FUNC_SEL_FLASH0_CS_N0_regmcu_io_cfg_sel_FLASH0_CS_N0_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N0 (Bit 0)          */
#define IO_FUNC_SEL_FLASH0_CS_N0_regmcu_io_cfg_sel_FLASH0_CS_N0_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N0 (Bitfield-Mask: 0x07) */
/* =====================================================  FLASH0_CS_N1  ====================================================== */
#define IO_FUNC_SEL_FLASH0_CS_N1_regmcu_io_cfg_sel_FLASH0_CS_N1_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N1 (Bit 0)          */
#define IO_FUNC_SEL_FLASH0_CS_N1_regmcu_io_cfg_sel_FLASH0_CS_N1_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N1 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_SCK  ======================================================= */
#define IO_FUNC_SEL_FLASH0_SCK_regmcu_io_cfg_sel_FLASH0_SCK_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_SCK (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_SCK_regmcu_io_cfg_sel_FLASH0_SCK_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_SCK (Bitfield-Mask: 0x07) */
/* =====================================================  FLASH0_RESETN  ===================================================== */
#define IO_FUNC_SEL_FLASH0_RESETN_regmcu_io_cfg_sel_FLASH0_RESETN_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_RESETN (Bit 0)       */
#define IO_FUNC_SEL_FLASH0_RESETN_regmcu_io_cfg_sel_FLASH0_RESETN_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_RESETN (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_DQS  ======================================================= */
#define IO_FUNC_SEL_FLASH0_DQS_regmcu_io_cfg_sel_FLASH0_DQS_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_DQS (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_DQS_regmcu_io_cfg_sel_FLASH0_DQS_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_DQS (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO0  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO0_regmcu_io_cfg_sel_FLASH0_IO0_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO0 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO0_regmcu_io_cfg_sel_FLASH0_IO0_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO0 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO1  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO1_regmcu_io_cfg_sel_FLASH0_IO1_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO1 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO1_regmcu_io_cfg_sel_FLASH0_IO1_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO1 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO2  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO2_regmcu_io_cfg_sel_FLASH0_IO2_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO2 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO2_regmcu_io_cfg_sel_FLASH0_IO2_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO2 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO3  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO3_regmcu_io_cfg_sel_FLASH0_IO3_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO3 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO3_regmcu_io_cfg_sel_FLASH0_IO3_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO3 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO4  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO4_regmcu_io_cfg_sel_FLASH0_IO4_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO4 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO4_regmcu_io_cfg_sel_FLASH0_IO4_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO4 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO5  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO5_regmcu_io_cfg_sel_FLASH0_IO5_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO5 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO5_regmcu_io_cfg_sel_FLASH0_IO5_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO5 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO6  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO6_regmcu_io_cfg_sel_FLASH0_IO6_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO6 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO6_regmcu_io_cfg_sel_FLASH0_IO6_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO6 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH0_IO7  ======================================================= */
#define IO_FUNC_SEL_FLASH0_IO7_regmcu_io_cfg_sel_FLASH0_IO7_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_IO7 (Bit 0)                */
#define IO_FUNC_SEL_FLASH0_IO7_regmcu_io_cfg_sel_FLASH0_IO7_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_IO7 (Bitfield-Mask: 0x07) */
/* =====================================================  FLASH0_CS_N2  ====================================================== */
#define IO_FUNC_SEL_FLASH0_CS_N2_regmcu_io_cfg_sel_FLASH0_CS_N2_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N2 (Bit 0)          */
#define IO_FUNC_SEL_FLASH0_CS_N2_regmcu_io_cfg_sel_FLASH0_CS_N2_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH0_CS_N2 (Bitfield-Mask: 0x07) */
/* =========================================================  GPIO0  ========================================================= */
#define IO_FUNC_SEL_GPIO0_regmcu_io_cfg_sel_GPIO0_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO0 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO0_regmcu_io_cfg_sel_GPIO0_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO0 (Bitfield-Mask: 0x07)         */
/* =========================================================  GPIO1  ========================================================= */
#define IO_FUNC_SEL_GPIO1_regmcu_io_cfg_sel_GPIO1_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO1 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO1_regmcu_io_cfg_sel_GPIO1_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO1 (Bitfield-Mask: 0x07)         */
/* =========================================================  GPIO2  ========================================================= */
#define IO_FUNC_SEL_GPIO2_regmcu_io_cfg_sel_GPIO2_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO2 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO2_regmcu_io_cfg_sel_GPIO2_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO2 (Bitfield-Mask: 0x07)         */
/* =========================================================  GPIO3  ========================================================= */
#define IO_FUNC_SEL_GPIO3_regmcu_io_cfg_sel_GPIO3_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO3 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO3_regmcu_io_cfg_sel_GPIO3_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO3 (Bitfield-Mask: 0x07)         */
/* =========================================================  GPIO4  ========================================================= */
#define IO_FUNC_SEL_GPIO4_regmcu_io_cfg_sel_GPIO4_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO4 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO4_regmcu_io_cfg_sel_GPIO4_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO4 (Bitfield-Mask: 0x07)         */
/* =========================================================  GPIO5  ========================================================= */
#define IO_FUNC_SEL_GPIO5_regmcu_io_cfg_sel_GPIO5_Pos (0UL)         /*!< regmcu_io_cfg_sel_GPIO5 (Bit 0)                       */
#define IO_FUNC_SEL_GPIO5_regmcu_io_cfg_sel_GPIO5_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_GPIO5 (Bitfield-Mask: 0x07)         */
/* ====================================================  RFFE_VDDIO_OUT  ===================================================== */
#define IO_FUNC_SEL_RFFE_VDDIO_OUT_regmcu_io_cfg_sel_RFFE_VDDIO_OUT_Pos (0UL) /*!< regmcu_io_cfg_sel_RFFE_VDDIO_OUT (Bit 0)    */
#define IO_FUNC_SEL_RFFE_VDDIO_OUT_regmcu_io_cfg_sel_RFFE_VDDIO_OUT_Msk (0x7UL) /*!< regmcu_io_cfg_sel_RFFE_VDDIO_OUT (Bitfield-Mask: 0x07) */
/* =======================================================  RFFE_SCLK  ======================================================= */
#define IO_FUNC_SEL_RFFE_SCLK_regmcu_io_cfg_sel_RFFE_SCLK_Pos (0UL) /*!< regmcu_io_cfg_sel_RFFE_SCLK (Bit 0)                   */
#define IO_FUNC_SEL_RFFE_SCLK_regmcu_io_cfg_sel_RFFE_SCLK_Msk (0x7UL) /*!< regmcu_io_cfg_sel_RFFE_SCLK (Bitfield-Mask: 0x07)   */
/* ======================================================  RFFE_SDATA  ======================================================= */
#define IO_FUNC_SEL_RFFE_SDATA_regmcu_io_cfg_sel_RFFE_SDATA_Pos (0UL) /*!< regmcu_io_cfg_sel_RFFE_SDATA (Bit 0)                */
#define IO_FUNC_SEL_RFFE_SDATA_regmcu_io_cfg_sel_RFFE_SDATA_Msk (0x7UL) /*!< regmcu_io_cfg_sel_RFFE_SDATA (Bitfield-Mask: 0x07) */
/* ========================================================  SC_RST  ========================================================= */
#define IO_FUNC_SEL_SC_RST_regmcu_io_cfg_sel_SC_RST_Pos (0UL)       /*!< regmcu_io_cfg_sel_SC_RST (Bit 0)                      */
#define IO_FUNC_SEL_SC_RST_regmcu_io_cfg_sel_SC_RST_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_SC_RST (Bitfield-Mask: 0x07)        */
/* =========================================================  SC_IO  ========================================================= */
#define IO_FUNC_SEL_SC_IO_regmcu_io_cfg_sel_SC_IO_Pos (0UL)         /*!< regmcu_io_cfg_sel_SC_IO (Bit 0)                       */
#define IO_FUNC_SEL_SC_IO_regmcu_io_cfg_sel_SC_IO_Msk (0x7UL)       /*!< regmcu_io_cfg_sel_SC_IO (Bitfield-Mask: 0x07)         */
/* ========================================================  SC_CLK  ========================================================= */
#define IO_FUNC_SEL_SC_CLK_regmcu_io_cfg_sel_SC_CLK_Pos (0UL)       /*!< regmcu_io_cfg_sel_SC_CLK (Bit 0)                      */
#define IO_FUNC_SEL_SC_CLK_regmcu_io_cfg_sel_SC_CLK_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_SC_CLK (Bitfield-Mask: 0x07)        */
/* ========================================================  SC_DET  ========================================================= */
#define IO_FUNC_SEL_SC_DET_regmcu_io_cfg_sel_SC_DET_Pos (0UL)       /*!< regmcu_io_cfg_sel_SC_DET (Bit 0)                      */
#define IO_FUNC_SEL_SC_DET_regmcu_io_cfg_sel_SC_DET_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_SC_DET (Bitfield-Mask: 0x07)        */
/* ========================================================  SC_SWP  ========================================================= */
#define IO_FUNC_SEL_SC_SWP_regmcu_io_cfg_sel_SC_SWP_Pos (0UL)       /*!< regmcu_io_cfg_sel_SC_SWP (Bit 0)                      */
#define IO_FUNC_SEL_SC_SWP_regmcu_io_cfg_sel_SC_SWP_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_SC_SWP (Bitfield-Mask: 0x07)        */
/* ========================================================  EJ_TCK  ========================================================= */
#define IO_FUNC_SEL_EJ_TCK_regmcu_io_cfg_sel_EJ_TCK_Pos (0UL)       /*!< regmcu_io_cfg_sel_EJ_TCK (Bit 0)                      */
#define IO_FUNC_SEL_EJ_TCK_regmcu_io_cfg_sel_EJ_TCK_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_EJ_TCK (Bitfield-Mask: 0x07)        */
/* ========================================================  EJ_TMS  ========================================================= */
#define IO_FUNC_SEL_EJ_TMS_regmcu_io_cfg_sel_EJ_TMS_Pos (0UL)       /*!< regmcu_io_cfg_sel_EJ_TMS (Bit 0)                      */
#define IO_FUNC_SEL_EJ_TMS_regmcu_io_cfg_sel_EJ_TMS_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_EJ_TMS (Bitfield-Mask: 0x07)        */
/* ========================================================  EJ_TRST  ======================================================== */
#define IO_FUNC_SEL_EJ_TRST_regmcu_io_cfg_sel_EJ_TRST_Pos (0UL)     /*!< regmcu_io_cfg_sel_EJ_TRST (Bit 0)                     */
#define IO_FUNC_SEL_EJ_TRST_regmcu_io_cfg_sel_EJ_TRST_Msk (0x7UL)   /*!< regmcu_io_cfg_sel_EJ_TRST (Bitfield-Mask: 0x07)       */
/* ========================================================  EJ_TDI  ========================================================= */
#define IO_FUNC_SEL_EJ_TDI_regmcu_io_cfg_sel_EJ_TDI_Pos (0UL)       /*!< regmcu_io_cfg_sel_EJ_TDI (Bit 0)                      */
#define IO_FUNC_SEL_EJ_TDI_regmcu_io_cfg_sel_EJ_TDI_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_EJ_TDI (Bitfield-Mask: 0x07)        */
/* ========================================================  EJ_TDO  ========================================================= */
#define IO_FUNC_SEL_EJ_TDO_regmcu_io_cfg_sel_EJ_TDO_Pos (0UL)       /*!< regmcu_io_cfg_sel_EJ_TDO (Bit 0)                      */
#define IO_FUNC_SEL_EJ_TDO_regmcu_io_cfg_sel_EJ_TDO_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_EJ_TDO (Bitfield-Mask: 0x07)        */
/* =======================================================  UART0_RX  ======================================================== */
#define IO_FUNC_SEL_UART0_RX_regmcu_io_cfg_sel_UART0_RX_Pos (0UL)   /*!< regmcu_io_cfg_sel_UART0_RX (Bit 0)                    */
#define IO_FUNC_SEL_UART0_RX_regmcu_io_cfg_sel_UART0_RX_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART0_RX (Bitfield-Mask: 0x07)      */
/* =======================================================  UART0_TX  ======================================================== */
#define IO_FUNC_SEL_UART0_TX_regmcu_io_cfg_sel_UART0_TX_Pos (0UL)   /*!< regmcu_io_cfg_sel_UART0_TX (Bit 0)                    */
#define IO_FUNC_SEL_UART0_TX_regmcu_io_cfg_sel_UART0_TX_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART0_TX (Bitfield-Mask: 0x07)      */
/* =======================================================  UART0_CTS  ======================================================= */
#define IO_FUNC_SEL_UART0_CTS_regmcu_io_cfg_sel_UART0_CTS_Pos (0UL) /*!< regmcu_io_cfg_sel_UART0_CTS (Bit 0)                   */
#define IO_FUNC_SEL_UART0_CTS_regmcu_io_cfg_sel_UART0_CTS_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART0_CTS (Bitfield-Mask: 0x07)   */
/* =======================================================  UART0_RTS  ======================================================= */
#define IO_FUNC_SEL_UART0_RTS_regmcu_io_cfg_sel_UART0_RTS_Pos (0UL) /*!< regmcu_io_cfg_sel_UART0_RTS (Bit 0)                   */
#define IO_FUNC_SEL_UART0_RTS_regmcu_io_cfg_sel_UART0_RTS_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART0_RTS (Bitfield-Mask: 0x07)   */
/* =======================================================  UART2_RX  ======================================================== */
#define IO_FUNC_SEL_UART2_RX_regmcu_io_cfg_sel_UART2_RX_Pos (0UL)   /*!< regmcu_io_cfg_sel_UART2_RX (Bit 0)                    */
#define IO_FUNC_SEL_UART2_RX_regmcu_io_cfg_sel_UART2_RX_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART2_RX (Bitfield-Mask: 0x07)      */
/* =======================================================  UART2_TX  ======================================================== */
#define IO_FUNC_SEL_UART2_TX_regmcu_io_cfg_sel_UART2_TX_Pos (0UL)   /*!< regmcu_io_cfg_sel_UART2_TX (Bit 0)                    */
#define IO_FUNC_SEL_UART2_TX_regmcu_io_cfg_sel_UART2_TX_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART2_TX (Bitfield-Mask: 0x07)      */
/* =======================================================  UART2_CTS  ======================================================= */
#define IO_FUNC_SEL_UART2_CTS_regmcu_io_cfg_sel_UART2_CTS_Pos (0UL) /*!< regmcu_io_cfg_sel_UART2_CTS (Bit 0)                   */
#define IO_FUNC_SEL_UART2_CTS_regmcu_io_cfg_sel_UART2_CTS_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART2_CTS (Bitfield-Mask: 0x07)   */
/* =======================================================  UART2_RTS  ======================================================= */
#define IO_FUNC_SEL_UART2_RTS_regmcu_io_cfg_sel_UART2_RTS_Pos (0UL) /*!< regmcu_io_cfg_sel_UART2_RTS (Bit 0)                   */
#define IO_FUNC_SEL_UART2_RTS_regmcu_io_cfg_sel_UART2_RTS_Msk (0x7UL) /*!< regmcu_io_cfg_sel_UART2_RTS (Bitfield-Mask: 0x07)   */
/* =======================================================  DEBUG_SEL  ======================================================= */
#define IO_FUNC_SEL_DEBUG_SEL_regmcu_io_cfg_sel_DEBUG_SEL_Pos (0UL) /*!< regmcu_io_cfg_sel_DEBUG_SEL (Bit 0)                   */
#define IO_FUNC_SEL_DEBUG_SEL_regmcu_io_cfg_sel_DEBUG_SEL_Msk (0x7UL) /*!< regmcu_io_cfg_sel_DEBUG_SEL (Bitfield-Mask: 0x07)   */
/* ======================================================  DEBUG_RSTN  ======================================================= */
#define IO_FUNC_SEL_DEBUG_RSTN_regmcu_io_cfg_sel_DEBUG_RSTN_Pos (0UL) /*!< regmcu_io_cfg_sel_DEBUG_RSTN (Bit 0)                */
#define IO_FUNC_SEL_DEBUG_RSTN_regmcu_io_cfg_sel_DEBUG_RSTN_Msk (0x7UL) /*!< regmcu_io_cfg_sel_DEBUG_RSTN (Bitfield-Mask: 0x07) */
/* ======================================================  SPIM0_MOSI  ======================================================= */
#define IO_FUNC_SEL_SPIM0_MOSI_regmcu_io_cfg_sel_SPIM0_MOSI_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM0_MOSI (Bit 0)                */
#define IO_FUNC_SEL_SPIM0_MOSI_regmcu_io_cfg_sel_SPIM0_MOSI_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM0_MOSI (Bitfield-Mask: 0x07) */
/* ======================================================  SPIM0_MISO  ======================================================= */
#define IO_FUNC_SEL_SPIM0_MISO_regmcu_io_cfg_sel_SPIM0_MISO_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM0_MISO (Bit 0)                */
#define IO_FUNC_SEL_SPIM0_MISO_regmcu_io_cfg_sel_SPIM0_MISO_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM0_MISO (Bitfield-Mask: 0x07) */
/* =======================================================  SPIM0_EN0  ======================================================= */
#define IO_FUNC_SEL_SPIM0_EN0_regmcu_io_cfg_sel_SPIM0_EN0_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM0_EN0 (Bit 0)                   */
#define IO_FUNC_SEL_SPIM0_EN0_regmcu_io_cfg_sel_SPIM0_EN0_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM0_EN0 (Bitfield-Mask: 0x07)   */
/* =======================================================  SPIM0_EN1  ======================================================= */
#define IO_FUNC_SEL_SPIM0_EN1_regmcu_io_cfg_sel_SPIM0_EN1_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM0_EN1 (Bit 0)                   */
#define IO_FUNC_SEL_SPIM0_EN1_regmcu_io_cfg_sel_SPIM0_EN1_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM0_EN1 (Bitfield-Mask: 0x07)   */
/* =======================================================  SPIM0_CLK  ======================================================= */
#define IO_FUNC_SEL_SPIM0_CLK_regmcu_io_cfg_sel_SPIM0_CLK_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM0_CLK (Bit 0)                   */
#define IO_FUNC_SEL_SPIM0_CLK_regmcu_io_cfg_sel_SPIM0_CLK_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM0_CLK (Bitfield-Mask: 0x07)   */
/* ======================================================  SPIM1_MOSI  ======================================================= */
#define IO_FUNC_SEL_SPIM1_MOSI_regmcu_io_cfg_sel_SPIM1_MOSI_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM1_MOSI (Bit 0)                */
#define IO_FUNC_SEL_SPIM1_MOSI_regmcu_io_cfg_sel_SPIM1_MOSI_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM1_MOSI (Bitfield-Mask: 0x07) */
/* ======================================================  SPIM1_MISO  ======================================================= */
#define IO_FUNC_SEL_SPIM1_MISO_regmcu_io_cfg_sel_SPIM1_MISO_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM1_MISO (Bit 0)                */
#define IO_FUNC_SEL_SPIM1_MISO_regmcu_io_cfg_sel_SPIM1_MISO_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM1_MISO (Bitfield-Mask: 0x07) */
/* =======================================================  SPIM1_EN  ======================================================== */
#define IO_FUNC_SEL_SPIM1_EN_regmcu_io_cfg_sel_SPIM1_EN_Pos (0UL)   /*!< regmcu_io_cfg_sel_SPIM1_EN (Bit 0)                    */
#define IO_FUNC_SEL_SPIM1_EN_regmcu_io_cfg_sel_SPIM1_EN_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM1_EN (Bitfield-Mask: 0x07)      */
/* =======================================================  SPIM1_CLK  ======================================================= */
#define IO_FUNC_SEL_SPIM1_CLK_regmcu_io_cfg_sel_SPIM1_CLK_Pos (0UL) /*!< regmcu_io_cfg_sel_SPIM1_CLK (Bit 0)                   */
#define IO_FUNC_SEL_SPIM1_CLK_regmcu_io_cfg_sel_SPIM1_CLK_Msk (0x7UL) /*!< regmcu_io_cfg_sel_SPIM1_CLK (Bitfield-Mask: 0x07)   */
/* =======================================================  I2C0_SDA  ======================================================== */
#define IO_FUNC_SEL_I2C0_SDA_regmcu_io_cfg_sel_I2C0_SDA_Pos (0UL)   /*!< regmcu_io_cfg_sel_I2C0_SDA (Bit 0)                    */
#define IO_FUNC_SEL_I2C0_SDA_regmcu_io_cfg_sel_I2C0_SDA_Msk (0x7UL) /*!< regmcu_io_cfg_sel_I2C0_SDA (Bitfield-Mask: 0x07)      */
/* =======================================================  I2C0_SCL  ======================================================== */
#define IO_FUNC_SEL_I2C0_SCL_regmcu_io_cfg_sel_I2C0_SCL_Pos (0UL)   /*!< regmcu_io_cfg_sel_I2C0_SCL (Bit 0)                    */
#define IO_FUNC_SEL_I2C0_SCL_regmcu_io_cfg_sel_I2C0_SCL_Msk (0x7UL) /*!< regmcu_io_cfg_sel_I2C0_SCL (Bitfield-Mask: 0x07)      */
/* =======================================================  I2C1_SDA  ======================================================== */
#define IO_FUNC_SEL_I2C1_SDA_regmcu_io_cfg_sel_I2C1_SDA_Pos (0UL)   /*!< regmcu_io_cfg_sel_I2C1_SDA (Bit 0)                    */
#define IO_FUNC_SEL_I2C1_SDA_regmcu_io_cfg_sel_I2C1_SDA_Msk (0x7UL) /*!< regmcu_io_cfg_sel_I2C1_SDA (Bitfield-Mask: 0x07)      */
/* =======================================================  I2C1_SCL  ======================================================== */
#define IO_FUNC_SEL_I2C1_SCL_regmcu_io_cfg_sel_I2C1_SCL_Pos (0UL)   /*!< regmcu_io_cfg_sel_I2C1_SCL (Bit 0)                    */
#define IO_FUNC_SEL_I2C1_SCL_regmcu_io_cfg_sel_I2C1_SCL_Msk (0x7UL) /*!< regmcu_io_cfg_sel_I2C1_SCL (Bitfield-Mask: 0x07)      */
/* ========================================================  PCM_CLK  ======================================================== */
#define IO_FUNC_SEL_PCM_CLK_regmcu_io_cfg_sel_PCM_CLK_Pos (0UL)     /*!< regmcu_io_cfg_sel_PCM_CLK (Bit 0)                     */
#define IO_FUNC_SEL_PCM_CLK_regmcu_io_cfg_sel_PCM_CLK_Msk (0x7UL)   /*!< regmcu_io_cfg_sel_PCM_CLK (Bitfield-Mask: 0x07)       */
/* ========================================================  PCM_FS  ========================================================= */
#define IO_FUNC_SEL_PCM_FS_regmcu_io_cfg_sel_PCM_FS_Pos (0UL)       /*!< regmcu_io_cfg_sel_PCM_FS (Bit 0)                      */
#define IO_FUNC_SEL_PCM_FS_regmcu_io_cfg_sel_PCM_FS_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_PCM_FS (Bitfield-Mask: 0x07)        */
/* ========================================================  PCM_IN  ========================================================= */
#define IO_FUNC_SEL_PCM_IN_regmcu_io_cfg_sel_PCM_IN_Pos (0UL)       /*!< regmcu_io_cfg_sel_PCM_IN (Bit 0)                      */
#define IO_FUNC_SEL_PCM_IN_regmcu_io_cfg_sel_PCM_IN_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_PCM_IN (Bitfield-Mask: 0x07)        */
/* ========================================================  PCM_OUT  ======================================================== */
#define IO_FUNC_SEL_PCM_OUT_regmcu_io_cfg_sel_PCM_OUT_Pos (0UL)     /*!< regmcu_io_cfg_sel_PCM_OUT (Bit 0)                     */
#define IO_FUNC_SEL_PCM_OUT_regmcu_io_cfg_sel_PCM_OUT_Msk (0x7UL)   /*!< regmcu_io_cfg_sel_PCM_OUT (Bitfield-Mask: 0x07)       */
/* =========================================================  PWM0  ========================================================== */
#define IO_FUNC_SEL_PWM0_regmcu_io_cfg_sel_PWM0_Pos (0UL)           /*!< regmcu_io_cfg_sel_PWM0 (Bit 0)                        */
#define IO_FUNC_SEL_PWM0_regmcu_io_cfg_sel_PWM0_Msk (0x7UL)         /*!< regmcu_io_cfg_sel_PWM0 (Bitfield-Mask: 0x07)          */
/* =========================================================  PWM1  ========================================================== */
#define IO_FUNC_SEL_PWM1_regmcu_io_cfg_sel_PWM1_Pos (0UL)           /*!< regmcu_io_cfg_sel_PWM1 (Bit 0)                        */
#define IO_FUNC_SEL_PWM1_regmcu_io_cfg_sel_PWM1_Msk (0x7UL)         /*!< regmcu_io_cfg_sel_PWM1 (Bitfield-Mask: 0x07)          */
/* =========================================================  PWM2  ========================================================== */
#define IO_FUNC_SEL_PWM2_regmcu_io_cfg_sel_PWM2_Pos (0UL)           /*!< regmcu_io_cfg_sel_PWM2 (Bit 0)                        */
#define IO_FUNC_SEL_PWM2_regmcu_io_cfg_sel_PWM2_Msk (0x7UL)         /*!< regmcu_io_cfg_sel_PWM2 (Bitfield-Mask: 0x07)          */
/* =========================================================  PWM3  ========================================================== */
#define IO_FUNC_SEL_PWM3_regmcu_io_cfg_sel_PWM3_Pos (0UL)           /*!< regmcu_io_cfg_sel_PWM3 (Bit 0)                        */
#define IO_FUNC_SEL_PWM3_regmcu_io_cfg_sel_PWM3_Msk (0x7UL)         /*!< regmcu_io_cfg_sel_PWM3 (Bitfield-Mask: 0x07)          */
/* ======================================================  FLASH1_CS_N  ====================================================== */
#define IO_FUNC_SEL_FLASH1_CS_N_regmcu_io_cfg_sel_FLASH1_CS_N_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_CS_N (Bit 0)             */
#define IO_FUNC_SEL_FLASH1_CS_N_regmcu_io_cfg_sel_FLASH1_CS_N_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_CS_N (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH1_SCK  ======================================================= */
#define IO_FUNC_SEL_FLASH1_SCK_regmcu_io_cfg_sel_FLASH1_SCK_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_SCK (Bit 0)                */
#define IO_FUNC_SEL_FLASH1_SCK_regmcu_io_cfg_sel_FLASH1_SCK_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_SCK (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH1_IO0  ======================================================= */
#define IO_FUNC_SEL_FLASH1_IO0_regmcu_io_cfg_sel_FLASH1_IO0_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_IO0 (Bit 0)                */
#define IO_FUNC_SEL_FLASH1_IO0_regmcu_io_cfg_sel_FLASH1_IO0_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_IO0 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH1_IO1  ======================================================= */
#define IO_FUNC_SEL_FLASH1_IO1_regmcu_io_cfg_sel_FLASH1_IO1_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_IO1 (Bit 0)                */
#define IO_FUNC_SEL_FLASH1_IO1_regmcu_io_cfg_sel_FLASH1_IO1_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_IO1 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH1_IO2  ======================================================= */
#define IO_FUNC_SEL_FLASH1_IO2_regmcu_io_cfg_sel_FLASH1_IO2_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_IO2 (Bit 0)                */
#define IO_FUNC_SEL_FLASH1_IO2_regmcu_io_cfg_sel_FLASH1_IO2_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_IO2 (Bitfield-Mask: 0x07) */
/* ======================================================  FLASH1_IO3  ======================================================= */
#define IO_FUNC_SEL_FLASH1_IO3_regmcu_io_cfg_sel_FLASH1_IO3_Pos (0UL) /*!< regmcu_io_cfg_sel_FLASH1_IO3 (Bit 0)                */
#define IO_FUNC_SEL_FLASH1_IO3_regmcu_io_cfg_sel_FLASH1_IO3_Msk (0x7UL) /*!< regmcu_io_cfg_sel_FLASH1_IO3 (Bitfield-Mask: 0x07) */
/* ========================================================  CLKOUT  ========================================================= */
#define IO_FUNC_SEL_CLKOUT_regmcu_io_cfg_sel_CLKOUT_Pos (0UL)       /*!< regmcu_io_cfg_sel_CLKOUT (Bit 0)                      */
#define IO_FUNC_SEL_CLKOUT_regmcu_io_cfg_sel_CLKOUT_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_CLKOUT (Bitfield-Mask: 0x07)        */
/* ========================================================  WAKEUP  ========================================================= */
#define IO_FUNC_SEL_WAKEUP_regmcu_io_cfg_sel_WAKEUP_Pos (0UL)       /*!< regmcu_io_cfg_sel_WAKEUP (Bit 0)                      */
#define IO_FUNC_SEL_WAKEUP_regmcu_io_cfg_sel_WAKEUP_Msk (0x7UL)     /*!< regmcu_io_cfg_sel_WAKEUP (Bitfield-Mask: 0x07)        */
/* ==========================================================  PB  =========================================================== */
#define IO_FUNC_SEL_PB_regmcu_io_cfg_sel_PB_Pos (0UL)               /*!< regmcu_io_cfg_sel_PB (Bit 0)                          */
#define IO_FUNC_SEL_PB_regmcu_io_cfg_sel_PB_Msk (0x7UL)             /*!< regmcu_io_cfg_sel_PB (Bitfield-Mask: 0x07)            */


/* =========================================================================================================================== */
/* ================                                        CLK_CONTROL                                        ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define CLK_CONTROL_CTRL_MCU_UART0_EXT_CLK_DIS_Pos (17UL)           /*!< MCU_UART0_EXT_CLK_DIS (Bit 17)                        */
#define CLK_CONTROL_CTRL_MCU_UART0_EXT_CLK_DIS_Msk (0x20000UL)      /*!< MCU_UART0_EXT_CLK_DIS (Bitfield-Mask: 0x01)           */
#define CLK_CONTROL_CTRL_MCU_UART1_EXT_CLK_DIS_Pos (16UL)           /*!< MCU_UART1_EXT_CLK_DIS (Bit 16)                        */
#define CLK_CONTROL_CTRL_MCU_UART1_EXT_CLK_DIS_Msk (0x10000UL)      /*!< MCU_UART1_EXT_CLK_DIS (Bitfield-Mask: 0x01)           */
#define CLK_CONTROL_CTRL_MUX_XO_URCLK_SEL_Pos (10UL)                /*!< MUX_XO_URCLK_SEL (Bit 10)                             */
#define CLK_CONTROL_CTRL_MUX_XO_URCLK_SEL_Msk (0x400UL)             /*!< MUX_XO_URCLK_SEL (Bitfield-Mask: 0x01)                */
#define CLK_CONTROL_CTRL_MUX_UART0_EXT_CLK_SEL_Pos (9UL)            /*!< MUX_UART0_EXT_CLK_SEL (Bit 9)                         */
#define CLK_CONTROL_CTRL_MUX_UART0_EXT_CLK_SEL_Msk (0x200UL)        /*!< MUX_UART0_EXT_CLK_SEL (Bitfield-Mask: 0x01)           */
#define CLK_CONTROL_CTRL_MUX_UART1_EXT_CLK_SEL_Pos (8UL)            /*!< MUX_UART1_EXT_CLK_SEL (Bit 8)                         */
#define CLK_CONTROL_CTRL_MUX_UART1_EXT_CLK_SEL_Msk (0x100UL)        /*!< MUX_UART1_EXT_CLK_SEL (Bitfield-Mask: 0x01)           */
#define CLK_CONTROL_CTRL_SEL_PLL_MCU_REFCLK_Pos (7UL)               /*!< SEL_PLL_MCU_REFCLK (Bit 7)                            */
#define CLK_CONTROL_CTRL_SEL_PLL_MCU_REFCLK_Msk (0x80UL)            /*!< SEL_PLL_MCU_REFCLK (Bitfield-Mask: 0x01)              */
#define CLK_CONTROL_CTRL_DIV_Pos          (4UL)                     /*!< DIV (Bit 4)                                           */
#define CLK_CONTROL_CTRL_DIV_Msk          (0x70UL)                  /*!< DIV (Bitfield-Mask: 0x07)                             */
#define CLK_CONTROL_CTRL_SEL1_Pos         (3UL)                     /*!< SEL1 (Bit 3)                                          */
#define CLK_CONTROL_CTRL_SEL1_Msk         (0x8UL)                   /*!< SEL1 (Bitfield-Mask: 0x01)                            */
#define CLK_CONTROL_CTRL_SEL0_Pos         (2UL)                     /*!< SEL0 (Bit 2)                                          */
#define CLK_CONTROL_CTRL_SEL0_Msk         (0x4UL)                   /*!< SEL0 (Bitfield-Mask: 0x01)                            */
#define CLK_CONTROL_CTRL_GF_RST_Pos       (1UL)                     /*!< GF_RST (Bit 1)                                        */
#define CLK_CONTROL_CTRL_GF_RST_Msk       (0x2UL)                   /*!< GF_RST (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_CTRL_GF_SEL_Pos       (0UL)                     /*!< GF_SEL (Bit 0)                                        */
#define CLK_CONTROL_CTRL_GF_SEL_Msk       (0x1UL)                   /*!< GF_SEL (Bitfield-Mask: 0x01)                          */
/* =======================================================  DPLL_CFG  ======================================================== */
#define CLK_CONTROL_DPLL_CFG_SLIP_EN_Pos  (23UL)                    /*!< SLIP_EN (Bit 23)                                      */
#define CLK_CONTROL_DPLL_CFG_SLIP_EN_Msk  (0x800000UL)              /*!< SLIP_EN (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_DPLL_CFG_TEST_Pos     (22UL)                    /*!< TEST (Bit 22)                                         */
#define CLK_CONTROL_DPLL_CFG_TEST_Msk     (0x400000UL)              /*!< TEST (Bitfield-Mask: 0x01)                            */
#define CLK_CONTROL_DPLL_CFG_INTFB_Pos    (21UL)                    /*!< INTFB (Bit 21)                                        */
#define CLK_CONTROL_DPLL_CFG_INTFB_Msk    (0x200000UL)              /*!< INTFB (Bitfield-Mask: 0x01)                           */
#define CLK_CONTROL_DPLL_CFG_BYPSS_Pos    (20UL)                    /*!< BYPSS (Bit 20)                                        */
#define CLK_CONTROL_DPLL_CFG_BYPSS_Msk    (0x100000UL)              /*!< BYPSS (Bitfield-Mask: 0x01)                           */
#define CLK_CONTROL_DPLL_CFG_OD_Pos       (16UL)                    /*!< OD (Bit 16)                                           */
#define CLK_CONTROL_DPLL_CFG_OD_Msk       (0xf0000UL)               /*!< OD (Bitfield-Mask: 0x0f)                              */
#define CLK_CONTROL_DPLL_CFG_NR_Pos       (12UL)                    /*!< NR (Bit 12)                                           */
#define CLK_CONTROL_DPLL_CFG_NR_Msk       (0xf000UL)                /*!< NR (Bitfield-Mask: 0x0f)                              */
#define CLK_CONTROL_DPLL_CFG_NF_Pos       (6UL)                     /*!< NF (Bit 6)                                            */
#define CLK_CONTROL_DPLL_CFG_NF_Msk       (0xfc0UL)                 /*!< NF (Bitfield-Mask: 0x3f)                              */
#define CLK_CONTROL_DPLL_CFG_BWADJ_Pos    (0UL)                     /*!< BWADJ (Bit 0)                                         */
#define CLK_CONTROL_DPLL_CFG_BWADJ_Msk    (0x3fUL)                  /*!< BWADJ (Bitfield-Mask: 0x3f)                           */
/* ========================================================  DPLL_EN  ======================================================== */
#define CLK_CONTROL_DPLL_EN_PWRDN_Pos     (0UL)                     /*!< PWRDN (Bit 0)                                         */
#define CLK_CONTROL_DPLL_EN_PWRDN_Msk     (0x1UL)                   /*!< PWRDN (Bitfield-Mask: 0x01)                           */
/* =======================================================  DPLL_RST  ======================================================== */
#define CLK_CONTROL_DPLL_RST_DPLL_RST_Pos (0UL)                     /*!< DPLL_RST (Bit 0)                                      */
#define CLK_CONTROL_DPLL_RST_DPLL_RST_Msk (0x1UL)                   /*!< DPLL_RST (Bitfield-Mask: 0x01)                        */
/* =======================================================  DPLL_STT  ======================================================== */
#define CLK_CONTROL_DPLL_STT_DPLL_FBSLIP_SAVE_Pos (1UL)             /*!< DPLL_FBSLIP_SAVE (Bit 1)                              */
#define CLK_CONTROL_DPLL_STT_DPLL_FBSLIP_SAVE_Msk (0x2UL)           /*!< DPLL_FBSLIP_SAVE (Bitfield-Mask: 0x01)                */
#define CLK_CONTROL_DPLL_STT_DPLL_RFSLIP_SAVE_Pos (0UL)             /*!< DPLL_RFSLIP_SAVE (Bit 0)                              */
#define CLK_CONTROL_DPLL_STT_DPLL_RFSLIP_SAVE_Msk (0x1UL)           /*!< DPLL_RFSLIP_SAVE (Bitfield-Mask: 0x01)                */
/* ====================================================  MCU_CLK_REQ_BYP  ==================================================== */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MSE_BRIDGE_Pos (31UL)           /*!< MSE_BRIDGE (Bit 31)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MSE_BRIDGE_Msk (0x80000000UL)   /*!< MSE_BRIDGE (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_PCM_Pos (30UL)              /*!< MCU_PCM (Bit 30)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_PCM_Msk (0x40000000UL)      /*!< MCU_PCM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_PWM_Pos (29UL)              /*!< MCU_PWM (Bit 29)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_PWM_Msk (0x20000000UL)      /*!< MCU_PWM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_REGMCU_Pos (28UL)           /*!< MCU_REGMCU (Bit 28)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_REGMCU_Msk (0x10000000UL)   /*!< MCU_REGMCU (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_GPM_Pos (27UL)          /*!< MCU_SSX_GPM (Bit 27)                                  */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_GPM_Msk (0x8000000UL)   /*!< MCU_SSX_GPM (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_PMP_Pos (26UL)          /*!< MCU_SSX_PMP (Bit 26)                                  */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_PMP_Msk (0x4000000UL)   /*!< MCU_SSX_PMP (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SHADOW_32KHZ_Pos (25UL)     /*!< MCU_SHADOW_32KHZ (Bit 25)                             */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SHADOW_32KHZ_Msk (0x2000000UL) /*!< MCU_SHADOW_32KHZ (Bitfield-Mask: 0x01)             */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_TIMERS_Pos (24UL)           /*!< MCU_TIMERS (Bit 24)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_TIMERS_Msk (0x1000000UL)    /*!< MCU_TIMERS (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_IOSEL_Pos (23UL)            /*!< MCU_IOSEL (Bit 23)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_IOSEL_Msk (0x800000UL)      /*!< MCU_IOSEL (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SIC_Pos (22UL)              /*!< MCU_SIC (Bit 22)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SIC_Msk (0x400000UL)        /*!< MCU_SIC (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_BIST_Pos (21UL)             /*!< MCU_BIST (Bit 21)                                     */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_BIST_Msk (0x200000UL)       /*!< MCU_BIST (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_CLK32K_LED_Pos (20UL)       /*!< MCU_CLK32K_LED (Bit 20)                               */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_CLK32K_LED_Msk (0x100000UL) /*!< MCU_CLK32K_LED (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF0_OCP_Pos (19UL)       /*!< MCU_UARTF0_OCP (Bit 19)                               */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF0_OCP_Msk (0x80000UL)  /*!< MCU_UARTF0_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF1_OCP_Pos (18UL)       /*!< MCU_UARTF1_OCP (Bit 18)                               */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF1_OCP_Msk (0x40000UL)  /*!< MCU_UARTF1_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_M4_Pos (17UL)               /*!< MCU_M4 (Bit 17)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_M4_Msk (0x20000UL)          /*!< MCU_M4 (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_DEBUG_Pos (16UL)            /*!< MCU_DEBUG (Bit 16)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_DEBUG_Msk (0x10000UL)       /*!< MCU_DEBUG (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_MASTER0_Pos (15UL)      /*!< MCU_SPI_MASTER0 (Bit 15)                              */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_MASTER0_Msk (0x8000UL)  /*!< MCU_SPI_MASTER0 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_MASTER1_Pos (14UL)      /*!< MCU_SPI_MASTER1 (Bit 14)                              */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_MASTER1_Msk (0x4000UL)  /*!< MCU_SPI_MASTER1 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_SLAVE_Pos (13UL)        /*!< MCU_SPI_SLAVE (Bit 13)                                */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SPI_SLAVE_Msk (0x2000UL)    /*!< MCU_SPI_SLAVE (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI0_Pos (12UL)           /*!< MCU_UARTI0 (Bit 12)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI0_Msk (0x1000UL)       /*!< MCU_UARTI0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI1_Pos (11UL)           /*!< MCU_UARTI1 (Bit 11)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI1_Msk (0x800UL)        /*!< MCU_UARTI1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI2_Pos (10UL)           /*!< MCU_UARTI2 (Bit 10)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTI2_Msk (0x400UL)        /*!< MCU_UARTI2 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF0_Pos (9UL)            /*!< MCU_UARTF0 (Bit 9)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF0_Msk (0x200UL)        /*!< MCU_UARTF0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF1_Pos (8UL)            /*!< MCU_UARTF1 (Bit 8)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_UARTF1_Msk (0x100UL)        /*!< MCU_UARTF1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SF_Pos (7UL)                /*!< MCU_SF (Bit 7)                                        */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SF_Msk (0x80UL)             /*!< MCU_SF (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GDMA_Pos (6UL)              /*!< MCU_GDMA (Bit 6)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GDMA_Msk (0x40UL)           /*!< MCU_GDMA (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_I2C0_Pos (5UL)              /*!< MCU_I2C0 (Bit 5)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_I2C0_Msk (0x20UL)           /*!< MCU_I2C0 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_I2C1_Pos (4UL)              /*!< MCU_I2C1 (Bit 4)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_I2C1_Msk (0x10UL)           /*!< MCU_I2C1 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_Pos (3UL)               /*!< MCU_SSX (Bit 3)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_SSX_Msk (0x8UL)             /*!< MCU_SSX (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GPIO_IF_Pos (2UL)           /*!< MCU_GPIO_IF (Bit 2)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GPIO_IF_Msk (0x4UL)         /*!< MCU_GPIO_IF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GPIO_RF_Pos (1UL)           /*!< MCU_GPIO_RF (Bit 1)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_GPIO_RF_Msk (0x2UL)         /*!< MCU_GPIO_RF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_LED_Pos (0UL)               /*!< MCU_LED (Bit 0)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_BYP_MCU_LED_Msk (0x1UL)             /*!< MCU_LED (Bitfield-Mask: 0x01)                         */
/* ====================================================  MCU_CLK_REQ_EN  ===================================================== */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MSE_BRIDGE_Pos (31UL)            /*!< MSE_BRIDGE (Bit 31)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MSE_BRIDGE_Msk (0x80000000UL)    /*!< MSE_BRIDGE (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_PCM_Pos (30UL)               /*!< MCU_PCM (Bit 30)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_PCM_Msk (0x40000000UL)       /*!< MCU_PCM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_PWM_Pos (29UL)               /*!< MCU_PWM (Bit 29)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_PWM_Msk (0x20000000UL)       /*!< MCU_PWM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_REGMCU_Pos (28UL)            /*!< MCU_REGMCU (Bit 28)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_REGMCU_Msk (0x10000000UL)    /*!< MCU_REGMCU (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_GPM_Pos (27UL)           /*!< MCU_SSX_GPM (Bit 27)                                  */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_GPM_Msk (0x8000000UL)    /*!< MCU_SSX_GPM (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_PMP_Pos (26UL)           /*!< MCU_SSX_PMP (Bit 26)                                  */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_PMP_Msk (0x4000000UL)    /*!< MCU_SSX_PMP (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SHADOW_32KHZ_Pos (25UL)      /*!< MCU_SHADOW_32KHZ (Bit 25)                             */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SHADOW_32KHZ_Msk (0x2000000UL) /*!< MCU_SHADOW_32KHZ (Bitfield-Mask: 0x01)              */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_TIMERS_Pos (24UL)            /*!< MCU_TIMERS (Bit 24)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_TIMERS_Msk (0x1000000UL)     /*!< MCU_TIMERS (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_IOSEL_Pos (23UL)             /*!< MCU_IOSEL (Bit 23)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_IOSEL_Msk (0x800000UL)       /*!< MCU_IOSEL (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SIC_Pos (22UL)               /*!< MCU_SIC (Bit 22)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SIC_Msk (0x400000UL)         /*!< MCU_SIC (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_BIST_Pos (21UL)              /*!< MCU_BIST (Bit 21)                                     */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_BIST_Msk (0x200000UL)        /*!< MCU_BIST (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_CLK32K_LED_Pos (20UL)        /*!< MCU_CLK32K_LED (Bit 20)                               */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_CLK32K_LED_Msk (0x100000UL)  /*!< MCU_CLK32K_LED (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF0_OCP_Pos (19UL)        /*!< MCU_UARTF0_OCP (Bit 19)                               */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF0_OCP_Msk (0x80000UL)   /*!< MCU_UARTF0_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF1_OCP_Pos (18UL)        /*!< MCU_UARTF1_OCP (Bit 18)                               */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF1_OCP_Msk (0x40000UL)   /*!< MCU_UARTF1_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_M4_Pos (17UL)                /*!< MCU_M4 (Bit 17)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_M4_Msk (0x20000UL)           /*!< MCU_M4 (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_DEBUG_Pos (16UL)             /*!< MCU_DEBUG (Bit 16)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_DEBUG_Msk (0x10000UL)        /*!< MCU_DEBUG (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_MASTER0_Pos (15UL)       /*!< MCU_SPI_MASTER0 (Bit 15)                              */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_MASTER0_Msk (0x8000UL)   /*!< MCU_SPI_MASTER0 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_MASTER1_Pos (14UL)       /*!< MCU_SPI_MASTER1 (Bit 14)                              */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_MASTER1_Msk (0x4000UL)   /*!< MCU_SPI_MASTER1 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_SLAVE_Pos (13UL)         /*!< MCU_SPI_SLAVE (Bit 13)                                */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SPI_SLAVE_Msk (0x2000UL)     /*!< MCU_SPI_SLAVE (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI0_Pos (12UL)            /*!< MCU_UARTI0 (Bit 12)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI0_Msk (0x1000UL)        /*!< MCU_UARTI0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI1_Pos (11UL)            /*!< MCU_UARTI1 (Bit 11)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI1_Msk (0x800UL)         /*!< MCU_UARTI1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI2_Pos (10UL)            /*!< MCU_UARTI2 (Bit 10)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTI2_Msk (0x400UL)         /*!< MCU_UARTI2 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF0_Pos (9UL)             /*!< MCU_UARTF0 (Bit 9)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF0_Msk (0x200UL)         /*!< MCU_UARTF0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF1_Pos (8UL)             /*!< MCU_UARTF1 (Bit 8)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_UARTF1_Msk (0x100UL)         /*!< MCU_UARTF1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SF_Pos (7UL)                 /*!< MCU_SF (Bit 7)                                        */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SF_Msk (0x80UL)              /*!< MCU_SF (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GDMA_Pos (6UL)               /*!< MCU_GDMA (Bit 6)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GDMA_Msk (0x40UL)            /*!< MCU_GDMA (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_I2C0_Pos (5UL)               /*!< MCU_I2C0 (Bit 5)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_I2C0_Msk (0x20UL)            /*!< MCU_I2C0 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_I2C1_Pos (4UL)               /*!< MCU_I2C1 (Bit 4)                                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_I2C1_Msk (0x10UL)            /*!< MCU_I2C1 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_Pos (3UL)                /*!< MCU_SSX (Bit 3)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_SSX_Msk (0x8UL)              /*!< MCU_SSX (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GPIO_IF_Pos (2UL)            /*!< MCU_GPIO_IF (Bit 2)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GPIO_IF_Msk (0x4UL)          /*!< MCU_GPIO_IF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GPIO_RF_Pos (1UL)            /*!< MCU_GPIO_RF (Bit 1)                                   */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_GPIO_RF_Msk (0x2UL)          /*!< MCU_GPIO_RF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_LED_Pos (0UL)                /*!< MCU_LED (Bit 0)                                       */
#define CLK_CONTROL_MCU_CLK_REQ_EN_MCU_LED_Msk (0x1UL)              /*!< MCU_LED (Bitfield-Mask: 0x01)                         */
/* ====================================================  STAT_GATED_CLK  ===================================================== */
#define CLK_CONTROL_STAT_GATED_CLK_MSE_BRIDGE_Pos (31UL)            /*!< MSE_BRIDGE (Bit 31)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MSE_BRIDGE_Msk (0x80000000UL)    /*!< MSE_BRIDGE (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_PCM_Pos (30UL)               /*!< MCU_PCM (Bit 30)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_PCM_Msk (0x40000000UL)       /*!< MCU_PCM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_PWM_Pos (29UL)               /*!< MCU_PWM (Bit 29)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_PWM_Msk (0x20000000UL)       /*!< MCU_PWM (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_REGMCU_Pos (28UL)            /*!< MCU_REGMCU (Bit 28)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_REGMCU_Msk (0x10000000UL)    /*!< MCU_REGMCU (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_GPM_Pos (27UL)           /*!< MCU_SSX_GPM (Bit 27)                                  */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_GPM_Msk (0x8000000UL)    /*!< MCU_SSX_GPM (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_PMP_Pos (26UL)           /*!< MCU_SSX_PMP (Bit 26)                                  */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_PMP_Msk (0x4000000UL)    /*!< MCU_SSX_PMP (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SHADOW_32KHZ_Pos (25UL)      /*!< MCU_SHADOW_32KHZ (Bit 25)                             */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SHADOW_32KHZ_Msk (0x2000000UL) /*!< MCU_SHADOW_32KHZ (Bitfield-Mask: 0x01)              */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_TIMERS_Pos (24UL)            /*!< MCU_TIMERS (Bit 24)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_TIMERS_Msk (0x1000000UL)     /*!< MCU_TIMERS (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_IOSEL_Pos (23UL)             /*!< MCU_IOSEL (Bit 23)                                    */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_IOSEL_Msk (0x800000UL)       /*!< MCU_IOSEL (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SIC_Pos (22UL)               /*!< MCU_SIC (Bit 22)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SIC_Msk (0x400000UL)         /*!< MCU_SIC (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_BIST_Pos (21UL)              /*!< MCU_BIST (Bit 21)                                     */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_BIST_Msk (0x200000UL)        /*!< MCU_BIST (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_CLK32K_LED_Pos (20UL)        /*!< MCU_CLK32K_LED (Bit 20)                               */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_CLK32K_LED_Msk (0x100000UL)  /*!< MCU_CLK32K_LED (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF0_OCP_Pos (19UL)        /*!< MCU_UARTF0_OCP (Bit 19)                               */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF0_OCP_Msk (0x80000UL)   /*!< MCU_UARTF0_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF1_OCP_Pos (18UL)        /*!< MCU_UARTF1_OCP (Bit 18)                               */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF1_OCP_Msk (0x40000UL)   /*!< MCU_UARTF1_OCP (Bitfield-Mask: 0x01)                  */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_M4_Pos (17UL)                /*!< MCU_M4 (Bit 17)                                       */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_M4_Msk (0x20000UL)           /*!< MCU_M4 (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_DEBUG_Pos (16UL)             /*!< MCU_DEBUG (Bit 16)                                    */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_DEBUG_Msk (0x10000UL)        /*!< MCU_DEBUG (Bitfield-Mask: 0x01)                       */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_MASTER0_Pos (15UL)       /*!< MCU_SPI_MASTER0 (Bit 15)                              */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_MASTER0_Msk (0x8000UL)   /*!< MCU_SPI_MASTER0 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_MASTER1_Pos (14UL)       /*!< MCU_SPI_MASTER1 (Bit 14)                              */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_MASTER1_Msk (0x4000UL)   /*!< MCU_SPI_MASTER1 (Bitfield-Mask: 0x01)                 */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_SLAVE_Pos (13UL)         /*!< MCU_SPI_SLAVE (Bit 13)                                */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SPI_SLAVE_Msk (0x2000UL)     /*!< MCU_SPI_SLAVE (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI0_Pos (12UL)            /*!< MCU_UARTI0 (Bit 12)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI0_Msk (0x1000UL)        /*!< MCU_UARTI0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI1_Pos (11UL)            /*!< MCU_UARTI1 (Bit 11)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI1_Msk (0x800UL)         /*!< MCU_UARTI1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI2_Pos (10UL)            /*!< MCU_UARTI2 (Bit 10)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTI2_Msk (0x400UL)         /*!< MCU_UARTI2 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF0_Pos (9UL)             /*!< MCU_UARTF0 (Bit 9)                                    */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF0_Msk (0x200UL)         /*!< MCU_UARTF0 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF1_Pos (8UL)             /*!< MCU_UARTF1 (Bit 8)                                    */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_UARTF1_Msk (0x100UL)         /*!< MCU_UARTF1 (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SF_Pos (7UL)                 /*!< MCU_SF (Bit 7)                                        */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SF_Msk (0x80UL)              /*!< MCU_SF (Bitfield-Mask: 0x01)                          */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GDMA_Pos (6UL)               /*!< MCU_GDMA (Bit 6)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GDMA_Msk (0x40UL)            /*!< MCU_GDMA (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_I2C0_Pos (5UL)               /*!< MCU_I2C0 (Bit 5)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_I2C0_Msk (0x20UL)            /*!< MCU_I2C0 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_I2C1_Pos (4UL)               /*!< MCU_I2C1 (Bit 4)                                      */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_I2C1_Msk (0x10UL)            /*!< MCU_I2C1 (Bitfield-Mask: 0x01)                        */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_Pos (3UL)                /*!< MCU_SSX (Bit 3)                                       */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_SSX_Msk (0x8UL)              /*!< MCU_SSX (Bitfield-Mask: 0x01)                         */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GPIO_IF_Pos (2UL)            /*!< MCU_GPIO_IF (Bit 2)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GPIO_IF_Msk (0x4UL)          /*!< MCU_GPIO_IF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GPIO_RF_Pos (1UL)            /*!< MCU_GPIO_RF (Bit 1)                                   */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_GPIO_RF_Msk (0x2UL)          /*!< MCU_GPIO_RF (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_LED_Pos (0UL)                /*!< MCU_LED (Bit 0)                                       */
#define CLK_CONTROL_STAT_GATED_CLK_MCU_LED_Msk (0x1UL)              /*!< MCU_LED (Bitfield-Mask: 0x01)                         */
/* ===================================================  MCU_ROOT_REQ_BYP  ==================================================== */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_AO_MCU_Pos (2UL)          /*!< ROOT_AO_MCU (Bit 2)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_AO_MCU_Msk (0x4UL)        /*!< ROOT_AO_MCU (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_HW_MCU_Pos (1UL)          /*!< ROOT_HW_MCU (Bit 1)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_HW_MCU_Msk (0x2UL)        /*!< ROOT_HW_MCU (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_SW_MCU_Pos (0UL)          /*!< ROOT_SW_MCU (Bit 0)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_BYP_ROOT_SW_MCU_Msk (0x1UL)        /*!< ROOT_SW_MCU (Bitfield-Mask: 0x01)                     */
/* ===================================================  MCU_CLK_REQ_BYP2  ==================================================== */
#define CLK_CONTROL_MCU_CLK_REQ_BYP2_MCU_CLKREG_Pos (1UL)           /*!< MCU_CLKREG (Bit 1)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_BYP2_MCU_CLKREG_Msk (0x2UL)         /*!< MCU_CLKREG (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_BYP2_MCU_SLOW_IF_CLKOUT_Pos (0UL)   /*!< MCU_SLOW_IF_CLKOUT (Bit 0)                            */
#define CLK_CONTROL_MCU_CLK_REQ_BYP2_MCU_SLOW_IF_CLKOUT_Msk (0x1UL) /*!< MCU_SLOW_IF_CLKOUT (Bitfield-Mask: 0x01)              */
/* ====================================================  MCU_CLK_REQ_EN2  ==================================================== */
#define CLK_CONTROL_MCU_CLK_REQ_EN2_MCU_CLKREG_Pos (1UL)            /*!< MCU_CLKREG (Bit 1)                                    */
#define CLK_CONTROL_MCU_CLK_REQ_EN2_MCU_CLKREG_Msk (0x2UL)          /*!< MCU_CLKREG (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_MCU_CLK_REQ_EN2_MCU_SLOW_IF_CLKOUT_Pos (0UL)    /*!< MCU_SLOW_IF_CLKOUT (Bit 0)                            */
#define CLK_CONTROL_MCU_CLK_REQ_EN2_MCU_SLOW_IF_CLKOUT_Msk (0x1UL)  /*!< MCU_SLOW_IF_CLKOUT (Bitfield-Mask: 0x01)              */
/* ====================================================  STAT_GATED_CLK2  ==================================================== */
#define CLK_CONTROL_STAT_GATED_CLK2_MCU_CLKREG_Pos (1UL)            /*!< MCU_CLKREG (Bit 1)                                    */
#define CLK_CONTROL_STAT_GATED_CLK2_MCU_CLKREG_Msk (0x2UL)          /*!< MCU_CLKREG (Bitfield-Mask: 0x01)                      */
#define CLK_CONTROL_STAT_GATED_CLK2_MCU_SLOW_IF_CLKOUT_Pos (0UL)    /*!< MCU_SLOW_IF_CLKOUT (Bit 0)                            */
#define CLK_CONTROL_STAT_GATED_CLK2_MCU_SLOW_IF_CLKOUT_Msk (0x1UL)  /*!< MCU_SLOW_IF_CLKOUT (Bitfield-Mask: 0x01)              */
/* ====================================================  MCU_ROOT_REQ_EN  ==================================================== */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_AO_MCU_Pos (2UL)           /*!< ROOT_AO_MCU (Bit 2)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_AO_MCU_Msk (0x4UL)         /*!< ROOT_AO_MCU (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_HW_MCU_Pos (1UL)           /*!< ROOT_HW_MCU (Bit 1)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_HW_MCU_Msk (0x2UL)         /*!< ROOT_HW_MCU (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_SW_MCU_Pos (0UL)           /*!< ROOT_SW_MCU (Bit 0)                                   */
#define CLK_CONTROL_MCU_ROOT_REQ_EN_ROOT_SW_MCU_Msk (0x1UL)         /*!< ROOT_SW_MCU (Bitfield-Mask: 0x01)                     */
/* ====================================================  STAT_GATED_ROOT  ==================================================== */
#define CLK_CONTROL_STAT_GATED_ROOT_AO_Pos (2UL)                    /*!< AO (Bit 2)                                            */
#define CLK_CONTROL_STAT_GATED_ROOT_AO_Msk (0x4UL)                  /*!< AO (Bitfield-Mask: 0x01)                              */
#define CLK_CONTROL_STAT_GATED_ROOT_HW_Pos (1UL)                    /*!< HW (Bit 1)                                            */
#define CLK_CONTROL_STAT_GATED_ROOT_HW_Msk (0x2UL)                  /*!< HW (Bitfield-Mask: 0x01)                              */
#define CLK_CONTROL_STAT_GATED_ROOT_SW_Pos (0UL)                    /*!< SW (Bit 0)                                            */
#define CLK_CONTROL_STAT_GATED_ROOT_SW_Msk (0x1UL)                  /*!< SW (Bitfield-Mask: 0x01)                              */
/* ====================================================  PMG_SSX_MCU_CFG  ==================================================== */
#define CLK_CONTROL_PMG_SSX_MCU_CFG_MCUREG_SONICS_CLK_CTRL_CNT_TARGET_Pos (0UL) /*!< MCUREG_SONICS_CLK_CTRL_CNT_TARGET (Bit 0) */
#define CLK_CONTROL_PMG_SSX_MCU_CFG_MCUREG_SONICS_CLK_CTRL_CNT_TARGET_Msk (0x3ffUL) /*!< MCUREG_SONICS_CLK_CTRL_CNT_TARGET (Bitfield-Mask: 0x3ff) */
/* ==================================================  USER_TIMER_CLK_CFG  =================================================== */
#define CLK_CONTROL_USER_TIMER_CLK_CFG_TIMERS_CLK_SELECT_Pos (0UL)  /*!< TIMERS_CLK_SELECT (Bit 0)                             */
#define CLK_CONTROL_USER_TIMER_CLK_CFG_TIMERS_CLK_SELECT_Msk (0xfUL) /*!< TIMERS_CLK_SELECT (Bitfield-Mask: 0x0f)              */
/* ================================================  USER_TIMER_CLK_REQ_BYP  ================================================= */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER_PCLK_Pos (9UL) /*!< USER_TIMER_PCLK (Bit 9)                              */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER_PCLK_Msk (0x200UL) /*!< USER_TIMER_PCLK (Bitfield-Mask: 0x01)            */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER_FREE_PCLK_Pos (8UL) /*!< USER_TIMER_FREE_PCLK (Bit 8)                    */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER_FREE_PCLK_Msk (0x100UL) /*!< USER_TIMER_FREE_PCLK (Bitfield-Mask: 0x01)  */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER3_CLK32K_Pos (7UL) /*!< USER_TIMER3_CLK32K (Bit 7)                        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER3_CLK32K_Msk (0x80UL) /*!< USER_TIMER3_CLK32K (Bitfield-Mask: 0x01)       */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER2_CLK32K_Pos (6UL) /*!< USER_TIMER2_CLK32K (Bit 6)                        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER2_CLK32K_Msk (0x40UL) /*!< USER_TIMER2_CLK32K (Bitfield-Mask: 0x01)       */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER1_CLK32K_Pos (5UL) /*!< USER_TIMER1_CLK32K (Bit 5)                        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER1_CLK32K_Msk (0x20UL) /*!< USER_TIMER1_CLK32K (Bitfield-Mask: 0x01)       */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER0_CLK32K_Pos (4UL) /*!< USER_TIMER0_CLK32K (Bit 4)                        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER0_CLK32K_Msk (0x10UL) /*!< USER_TIMER0_CLK32K (Bitfield-Mask: 0x01)       */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER3_Pos (3UL)    /*!< USER_TIMER3 (Bit 3)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER3_Msk (0x8UL)  /*!< USER_TIMER3 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER2_Pos (2UL)    /*!< USER_TIMER2 (Bit 2)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER2_Msk (0x4UL)  /*!< USER_TIMER2 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER1_Pos (1UL)    /*!< USER_TIMER1 (Bit 1)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER1_Msk (0x2UL)  /*!< USER_TIMER1 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER0_Pos (0UL)    /*!< USER_TIMER0 (Bit 0)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_BYP_USER_TIMER0_Msk (0x1UL)  /*!< USER_TIMER0 (Bitfield-Mask: 0x01)                     */
/* =================================================  USER_TIMER_CLK_REQ_EN  ================================================= */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER_PCLK_Pos (9UL) /*!< USER_TIMER_PCLK (Bit 9)                               */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER_PCLK_Msk (0x200UL) /*!< USER_TIMER_PCLK (Bitfield-Mask: 0x01)             */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER_FREE_PCLK_Pos (8UL) /*!< USER_TIMER_FREE_PCLK (Bit 8)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER_FREE_PCLK_Msk (0x100UL) /*!< USER_TIMER_FREE_PCLK (Bitfield-Mask: 0x01)   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER3_CLK32K_Pos (7UL) /*!< USER_TIMER3_CLK32K (Bit 7)                         */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER3_CLK32K_Msk (0x80UL) /*!< USER_TIMER3_CLK32K (Bitfield-Mask: 0x01)        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER2_CLK32K_Pos (6UL) /*!< USER_TIMER2_CLK32K (Bit 6)                         */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER2_CLK32K_Msk (0x40UL) /*!< USER_TIMER2_CLK32K (Bitfield-Mask: 0x01)        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER1_CLK32K_Pos (5UL) /*!< USER_TIMER1_CLK32K (Bit 5)                         */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER1_CLK32K_Msk (0x20UL) /*!< USER_TIMER1_CLK32K (Bitfield-Mask: 0x01)        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER0_CLK32K_Pos (4UL) /*!< USER_TIMER0_CLK32K (Bit 4)                         */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER0_CLK32K_Msk (0x10UL) /*!< USER_TIMER0_CLK32K (Bitfield-Mask: 0x01)        */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER3_Pos (3UL)     /*!< USER_TIMER3 (Bit 3)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER3_Msk (0x8UL)   /*!< USER_TIMER3 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER2_Pos (2UL)     /*!< USER_TIMER2 (Bit 2)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER2_Msk (0x4UL)   /*!< USER_TIMER2 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER1_Pos (1UL)     /*!< USER_TIMER1 (Bit 1)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER1_Msk (0x2UL)   /*!< USER_TIMER1 (Bitfield-Mask: 0x01)                     */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER0_Pos (0UL)     /*!< USER_TIMER0 (Bit 0)                                   */
#define CLK_CONTROL_USER_TIMER_CLK_REQ_EN_USER_TIMER0_Msk (0x1UL)   /*!< USER_TIMER0 (Bitfield-Mask: 0x01)                     */
/* ===============================================  USER_TIMER_STAT_GATED_CLK  =============================================== */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER_PCLK_Pos (9UL) /*!< USER_TIMER_PCLK (Bit 9)                           */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER_PCLK_Msk (0x200UL) /*!< USER_TIMER_PCLK (Bitfield-Mask: 0x01)         */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER_FREE_PCLK_Pos (8UL) /*!< USER_TIMER_FREE_PCLK (Bit 8)                 */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER_FREE_PCLK_Msk (0x100UL) /*!< USER_TIMER_FREE_PCLK (Bitfield-Mask: 0x01) */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER3_CLK32K_Pos (7UL) /*!< USER_TIMER3_CLK32K (Bit 7)                     */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER3_CLK32K_Msk (0x80UL) /*!< USER_TIMER3_CLK32K (Bitfield-Mask: 0x01)    */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER2_CLK32K_Pos (6UL) /*!< USER_TIMER2_CLK32K (Bit 6)                     */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER2_CLK32K_Msk (0x40UL) /*!< USER_TIMER2_CLK32K (Bitfield-Mask: 0x01)    */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER1_CLK32K_Pos (5UL) /*!< USER_TIMER1_CLK32K (Bit 5)                     */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER1_CLK32K_Msk (0x20UL) /*!< USER_TIMER1_CLK32K (Bitfield-Mask: 0x01)    */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER0_CLK32K_Pos (4UL) /*!< USER_TIMER0_CLK32K (Bit 4)                     */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER0_CLK32K_Msk (0x10UL) /*!< USER_TIMER0_CLK32K (Bitfield-Mask: 0x01)    */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER3_Pos (3UL) /*!< USER_TIMER3 (Bit 3)                                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER3_Msk (0x8UL) /*!< USER_TIMER3 (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER2_Pos (2UL) /*!< USER_TIMER2 (Bit 2)                                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER2_Msk (0x4UL) /*!< USER_TIMER2 (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER1_Pos (1UL) /*!< USER_TIMER1 (Bit 1)                                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER1_Msk (0x2UL) /*!< USER_TIMER1 (Bitfield-Mask: 0x01)                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER0_Pos (0UL) /*!< USER_TIMER0 (Bit 0)                                   */
#define CLK_CONTROL_USER_TIMER_STAT_GATED_CLK_USER_TIMER0_Msk (0x1UL) /*!< USER_TIMER0 (Bitfield-Mask: 0x01)                   */


/* =========================================================================================================================== */
/* ================                                        RST_CONTROL                                        ================ */
/* =========================================================================================================================== */

/* ========================================================  REG_SET  ======================================================== */
#define RST_CONTROL_REG_SET_RESET_LED_Pos (0UL)                     /*!< RESET_LED (Bit 0)                                     */
#define RST_CONTROL_REG_SET_RESET_LED_Msk (0x1UL)                   /*!< RESET_LED (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_SET_RESET_PCM_Pos (1UL)                     /*!< RESET_PCM (Bit 1)                                     */
#define RST_CONTROL_REG_SET_RESET_PCM_Msk (0x2UL)                   /*!< RESET_PCM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_SET_RESET_TIMERS_Pos (2UL)                  /*!< RESET_TIMERS (Bit 2)                                  */
#define RST_CONTROL_REG_SET_RESET_TIMERS_Msk (0x4UL)                /*!< RESET_TIMERS (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_SET_RESET_DEBUG_Pos (3UL)                   /*!< RESET_DEBUG (Bit 3)                                   */
#define RST_CONTROL_REG_SET_RESET_DEBUG_Msk (0x8UL)                 /*!< RESET_DEBUG (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_SET_RESET_SPI_MASTER0_Pos (4UL)             /*!< RESET_SPI_MASTER0 (Bit 4)                             */
#define RST_CONTROL_REG_SET_RESET_SPI_MASTER0_Msk (0x10UL)          /*!< RESET_SPI_MASTER0 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_SET_RESET_SPI_MASTER1_Pos (5UL)             /*!< RESET_SPI_MASTER1 (Bit 5)                             */
#define RST_CONTROL_REG_SET_RESET_SPI_MASTER1_Msk (0x20UL)          /*!< RESET_SPI_MASTER1 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_SET_RESET_SPI_SLAVE_Pos (6UL)               /*!< RESET_SPI_SLAVE (Bit 6)                               */
#define RST_CONTROL_REG_SET_RESET_SPI_SLAVE_Msk (0x40UL)            /*!< RESET_SPI_SLAVE (Bitfield-Mask: 0x01)                 */
#define RST_CONTROL_REG_SET_RESET_UARTI0_Pos (7UL)                  /*!< RESET_UARTI0 (Bit 7)                                  */
#define RST_CONTROL_REG_SET_RESET_UARTI0_Msk (0x80UL)               /*!< RESET_UARTI0 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_SET_RESET_UARTI1_Pos (8UL)                  /*!< RESET_UARTI1 (Bit 8)                                  */
#define RST_CONTROL_REG_SET_RESET_UARTI1_Msk (0x100UL)              /*!< RESET_UARTI1 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_SET_RESET_UARTI2_Pos (9UL)                  /*!< RESET_UARTI2 (Bit 9)                                  */
#define RST_CONTROL_REG_SET_RESET_UARTI2_Msk (0x200UL)              /*!< RESET_UARTI2 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_SET_RESET_UARF0_Pos (10UL)                  /*!< RESET_UARF0 (Bit 10)                                  */
#define RST_CONTROL_REG_SET_RESET_UARF0_Msk (0x400UL)               /*!< RESET_UARF0 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_SET_RESET_UARF1_Pos (11UL)                  /*!< RESET_UARF1 (Bit 11)                                  */
#define RST_CONTROL_REG_SET_RESET_UARF1_Msk (0x800UL)               /*!< RESET_UARF1 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_SET_RESET_SF_Pos  (12UL)                    /*!< RESET_SF (Bit 12)                                     */
#define RST_CONTROL_REG_SET_RESET_SF_Msk  (0x1000UL)                /*!< RESET_SF (Bitfield-Mask: 0x01)                        */
#define RST_CONTROL_REG_SET_RESET_GDMA_Pos (13UL)                   /*!< RESET_GDMA (Bit 13)                                   */
#define RST_CONTROL_REG_SET_RESET_GDMA_Msk (0x2000UL)               /*!< RESET_GDMA (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_SET_RESET_I2C0_Pos (14UL)                   /*!< RESET_I2C0 (Bit 14)                                   */
#define RST_CONTROL_REG_SET_RESET_I2C0_Msk (0x4000UL)               /*!< RESET_I2C0 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_SET_RESET_I2C1_Pos (15UL)                   /*!< RESET_I2C1 (Bit 15)                                   */
#define RST_CONTROL_REG_SET_RESET_I2C1_Msk (0x8000UL)               /*!< RESET_I2C1 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_SET_RESET_GPIO_Pos (16UL)                   /*!< RESET_GPIO (Bit 16)                                   */
#define RST_CONTROL_REG_SET_RESET_GPIO_Msk (0x10000UL)              /*!< RESET_GPIO (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_SET_RESET_SIC_Pos (17UL)                    /*!< RESET_SIC (Bit 17)                                    */
#define RST_CONTROL_REG_SET_RESET_SIC_Msk (0x20000UL)               /*!< RESET_SIC (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_SET_RESET_IOSEL_Pos (18UL)                  /*!< RESET_IOSEL (Bit 18)                                  */
#define RST_CONTROL_REG_SET_RESET_IOSEL_Msk (0x40000UL)             /*!< RESET_IOSEL (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_SET_RESET_USER_TIMER_N_Pos (19UL)           /*!< RESET_USER_TIMER_N (Bit 19)                           */
#define RST_CONTROL_REG_SET_RESET_USER_TIMER_N_Msk (0x80000UL)      /*!< RESET_USER_TIMER_N (Bitfield-Mask: 0x01)              */
#define RST_CONTROL_REG_SET_RESET_USER_TIMER_SOFT_N_Pos (20UL)      /*!< RESET_USER_TIMER_SOFT_N (Bit 20)                      */
#define RST_CONTROL_REG_SET_RESET_USER_TIMER_SOFT_N_Msk (0x100000UL) /*!< RESET_USER_TIMER_SOFT_N (Bitfield-Mask: 0x01)        */
#define RST_CONTROL_REG_SET_RESET_PWM_Pos (21UL)                    /*!< RESET_PWM (Bit 21)                                    */
#define RST_CONTROL_REG_SET_RESET_PWM_Msk (0x200000UL)              /*!< RESET_PWM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_SET_RESET_CLKOUT_Pos (22UL)                 /*!< RESET_CLKOUT (Bit 22)                                 */
#define RST_CONTROL_REG_SET_RESET_CLKOUT_Msk (0x400000UL)           /*!< RESET_CLKOUT (Bitfield-Mask: 0x01)                    */
/* ========================================================  REG_CLR  ======================================================== */
#define RST_CONTROL_REG_CLR_RESET_LED_Pos (0UL)                     /*!< RESET_LED (Bit 0)                                     */
#define RST_CONTROL_REG_CLR_RESET_LED_Msk (0x1UL)                   /*!< RESET_LED (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_CLR_RESET_PCM_Pos (1UL)                     /*!< RESET_PCM (Bit 1)                                     */
#define RST_CONTROL_REG_CLR_RESET_PCM_Msk (0x2UL)                   /*!< RESET_PCM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_CLR_RESET_TIMERS_Pos (2UL)                  /*!< RESET_TIMERS (Bit 2)                                  */
#define RST_CONTROL_REG_CLR_RESET_TIMERS_Msk (0x4UL)                /*!< RESET_TIMERS (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_CLR_RESET_DEBUG_Pos (3UL)                   /*!< RESET_DEBUG (Bit 3)                                   */
#define RST_CONTROL_REG_CLR_RESET_DEBUG_Msk (0x8UL)                 /*!< RESET_DEBUG (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_CLR_RESET_SPI_MASTER0_Pos (4UL)             /*!< RESET_SPI_MASTER0 (Bit 4)                             */
#define RST_CONTROL_REG_CLR_RESET_SPI_MASTER0_Msk (0x10UL)          /*!< RESET_SPI_MASTER0 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_CLR_RESET_SPI_MASTER1_Pos (5UL)             /*!< RESET_SPI_MASTER1 (Bit 5)                             */
#define RST_CONTROL_REG_CLR_RESET_SPI_MASTER1_Msk (0x20UL)          /*!< RESET_SPI_MASTER1 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_CLR_RESET_SPI_SLAVE_Pos (6UL)               /*!< RESET_SPI_SLAVE (Bit 6)                               */
#define RST_CONTROL_REG_CLR_RESET_SPI_SLAVE_Msk (0x40UL)            /*!< RESET_SPI_SLAVE (Bitfield-Mask: 0x01)                 */
#define RST_CONTROL_REG_CLR_RESET_UARTI0_Pos (7UL)                  /*!< RESET_UARTI0 (Bit 7)                                  */
#define RST_CONTROL_REG_CLR_RESET_UARTI0_Msk (0x80UL)               /*!< RESET_UARTI0 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_CLR_RESET_UARTI1_Pos (8UL)                  /*!< RESET_UARTI1 (Bit 8)                                  */
#define RST_CONTROL_REG_CLR_RESET_UARTI1_Msk (0x100UL)              /*!< RESET_UARTI1 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_CLR_RESET_UARTI2_Pos (9UL)                  /*!< RESET_UARTI2 (Bit 9)                                  */
#define RST_CONTROL_REG_CLR_RESET_UARTI2_Msk (0x200UL)              /*!< RESET_UARTI2 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_CLR_RESET_UARF0_Pos (10UL)                  /*!< RESET_UARF0 (Bit 10)                                  */
#define RST_CONTROL_REG_CLR_RESET_UARF0_Msk (0x400UL)               /*!< RESET_UARF0 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_CLR_RESET_UARF1_Pos (11UL)                  /*!< RESET_UARF1 (Bit 11)                                  */
#define RST_CONTROL_REG_CLR_RESET_UARF1_Msk (0x800UL)               /*!< RESET_UARF1 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_CLR_RESET_SF_Pos  (12UL)                    /*!< RESET_SF (Bit 12)                                     */
#define RST_CONTROL_REG_CLR_RESET_SF_Msk  (0x1000UL)                /*!< RESET_SF (Bitfield-Mask: 0x01)                        */
#define RST_CONTROL_REG_CLR_RESET_GDMA_Pos (13UL)                   /*!< RESET_GDMA (Bit 13)                                   */
#define RST_CONTROL_REG_CLR_RESET_GDMA_Msk (0x2000UL)               /*!< RESET_GDMA (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_CLR_RESET_I2C0_Pos (14UL)                   /*!< RESET_I2C0 (Bit 14)                                   */
#define RST_CONTROL_REG_CLR_RESET_I2C0_Msk (0x4000UL)               /*!< RESET_I2C0 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_CLR_RESET_I2C1_Pos (15UL)                   /*!< RESET_I2C1 (Bit 15)                                   */
#define RST_CONTROL_REG_CLR_RESET_I2C1_Msk (0x8000UL)               /*!< RESET_I2C1 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_CLR_RESET_GPIO_Pos (16UL)                   /*!< RESET_GPIO (Bit 16)                                   */
#define RST_CONTROL_REG_CLR_RESET_GPIO_Msk (0x10000UL)              /*!< RESET_GPIO (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_CLR_RESET_SIC_Pos (17UL)                    /*!< RESET_SIC (Bit 17)                                    */
#define RST_CONTROL_REG_CLR_RESET_SIC_Msk (0x20000UL)               /*!< RESET_SIC (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_CLR_RESET_IOSEL_Pos (18UL)                  /*!< RESET_IOSEL (Bit 18)                                  */
#define RST_CONTROL_REG_CLR_RESET_IOSEL_Msk (0x40000UL)             /*!< RESET_IOSEL (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_CLR_RESET_USER_TIMER_N_Pos (19UL)           /*!< RESET_USER_TIMER_N (Bit 19)                           */
#define RST_CONTROL_REG_CLR_RESET_USER_TIMER_N_Msk (0x80000UL)      /*!< RESET_USER_TIMER_N (Bitfield-Mask: 0x01)              */
#define RST_CONTROL_REG_CLR_RESET_USER_TIMER_SOFT_N_Pos (20UL)      /*!< RESET_USER_TIMER_SOFT_N (Bit 20)                      */
#define RST_CONTROL_REG_CLR_RESET_USER_TIMER_SOFT_N_Msk (0x100000UL) /*!< RESET_USER_TIMER_SOFT_N (Bitfield-Mask: 0x01)        */
#define RST_CONTROL_REG_CLR_RESET_PWM_Pos (21UL)                    /*!< RESET_PWM (Bit 21)                                    */
#define RST_CONTROL_REG_CLR_RESET_PWM_Msk (0x200000UL)              /*!< RESET_PWM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_CLR_RESET_CLKOUT_Pos (22UL)                 /*!< RESET_CLKOUT (Bit 22)                                 */
#define RST_CONTROL_REG_CLR_RESET_CLKOUT_Msk (0x400000UL)           /*!< RESET_CLKOUT (Bitfield-Mask: 0x01)                    */
/* ==========================================================  REG  ========================================================== */
#define RST_CONTROL_REG_RESET_LED_Pos     (0UL)                     /*!< RESET_LED (Bit 0)                                     */
#define RST_CONTROL_REG_RESET_LED_Msk     (0x1UL)                   /*!< RESET_LED (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_RESET_PCM_Pos     (1UL)                     /*!< RESET_PCM (Bit 1)                                     */
#define RST_CONTROL_REG_RESET_PCM_Msk     (0x2UL)                   /*!< RESET_PCM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_RESET_TIMERS_Pos  (2UL)                     /*!< RESET_TIMERS (Bit 2)                                  */
#define RST_CONTROL_REG_RESET_TIMERS_Msk  (0x4UL)                   /*!< RESET_TIMERS (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_RESET_DEBUG_Pos   (3UL)                     /*!< RESET_DEBUG (Bit 3)                                   */
#define RST_CONTROL_REG_RESET_DEBUG_Msk   (0x8UL)                   /*!< RESET_DEBUG (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_RESET_SPI_MASTER0_Pos (4UL)                 /*!< RESET_SPI_MASTER0 (Bit 4)                             */
#define RST_CONTROL_REG_RESET_SPI_MASTER0_Msk (0x10UL)              /*!< RESET_SPI_MASTER0 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_RESET_SPI_MASTER1_Pos (5UL)                 /*!< RESET_SPI_MASTER1 (Bit 5)                             */
#define RST_CONTROL_REG_RESET_SPI_MASTER1_Msk (0x20UL)              /*!< RESET_SPI_MASTER1 (Bitfield-Mask: 0x01)               */
#define RST_CONTROL_REG_RESET_SPI_SLAVE_Pos (6UL)                   /*!< RESET_SPI_SLAVE (Bit 6)                               */
#define RST_CONTROL_REG_RESET_SPI_SLAVE_Msk (0x40UL)                /*!< RESET_SPI_SLAVE (Bitfield-Mask: 0x01)                 */
#define RST_CONTROL_REG_RESET_UARTI0_Pos  (7UL)                     /*!< RESET_UARTI0 (Bit 7)                                  */
#define RST_CONTROL_REG_RESET_UARTI0_Msk  (0x80UL)                  /*!< RESET_UARTI0 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_RESET_UARTI1_Pos  (8UL)                     /*!< RESET_UARTI1 (Bit 8)                                  */
#define RST_CONTROL_REG_RESET_UARTI1_Msk  (0x100UL)                 /*!< RESET_UARTI1 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_RESET_UARTI2_Pos  (9UL)                     /*!< RESET_UARTI2 (Bit 9)                                  */
#define RST_CONTROL_REG_RESET_UARTI2_Msk  (0x200UL)                 /*!< RESET_UARTI2 (Bitfield-Mask: 0x01)                    */
#define RST_CONTROL_REG_RESET_UARF0_Pos   (10UL)                    /*!< RESET_UARF0 (Bit 10)                                  */
#define RST_CONTROL_REG_RESET_UARF0_Msk   (0x400UL)                 /*!< RESET_UARF0 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_RESET_UARF1_Pos   (11UL)                    /*!< RESET_UARF1 (Bit 11)                                  */
#define RST_CONTROL_REG_RESET_UARF1_Msk   (0x800UL)                 /*!< RESET_UARF1 (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_RESET_SF_Pos      (12UL)                    /*!< RESET_SF (Bit 12)                                     */
#define RST_CONTROL_REG_RESET_SF_Msk      (0x1000UL)                /*!< RESET_SF (Bitfield-Mask: 0x01)                        */
#define RST_CONTROL_REG_RESET_GDMA_Pos    (13UL)                    /*!< RESET_GDMA (Bit 13)                                   */
#define RST_CONTROL_REG_RESET_GDMA_Msk    (0x2000UL)                /*!< RESET_GDMA (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_RESET_I2C0_Pos    (14UL)                    /*!< RESET_I2C0 (Bit 14)                                   */
#define RST_CONTROL_REG_RESET_I2C0_Msk    (0x4000UL)                /*!< RESET_I2C0 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_RESET_I2C1_Pos    (15UL)                    /*!< RESET_I2C1 (Bit 15)                                   */
#define RST_CONTROL_REG_RESET_I2C1_Msk    (0x8000UL)                /*!< RESET_I2C1 (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_RESET_GPIO_Pos    (16UL)                    /*!< RESET_GPIO (Bit 16)                                   */
#define RST_CONTROL_REG_RESET_GPIO_Msk    (0x10000UL)               /*!< RESET_GPIO (Bitfield-Mask: 0x01)                      */
#define RST_CONTROL_REG_RESET_SIC_Pos     (17UL)                    /*!< RESET_SIC (Bit 17)                                    */
#define RST_CONTROL_REG_RESET_SIC_Msk     (0x20000UL)               /*!< RESET_SIC (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_RESET_IOSEL_Pos   (18UL)                    /*!< RESET_IOSEL (Bit 18)                                  */
#define RST_CONTROL_REG_RESET_IOSEL_Msk   (0x40000UL)               /*!< RESET_IOSEL (Bitfield-Mask: 0x01)                     */
#define RST_CONTROL_REG_RESET_USER_TIMER_N_Pos (19UL)               /*!< RESET_USER_TIMER_N (Bit 19)                           */
#define RST_CONTROL_REG_RESET_USER_TIMER_N_Msk (0x80000UL)          /*!< RESET_USER_TIMER_N (Bitfield-Mask: 0x01)              */
#define RST_CONTROL_REG_RESET_USER_TIMER_SOFT_N_Pos (20UL)          /*!< RESET_USER_TIMER_SOFT_N (Bit 20)                      */
#define RST_CONTROL_REG_RESET_USER_TIMER_SOFT_N_Msk (0x100000UL)    /*!< RESET_USER_TIMER_SOFT_N (Bitfield-Mask: 0x01)         */
#define RST_CONTROL_REG_RESET_PWM_Pos     (21UL)                    /*!< RESET_PWM (Bit 21)                                    */
#define RST_CONTROL_REG_RESET_PWM_Msk     (0x200000UL)              /*!< RESET_PWM (Bitfield-Mask: 0x01)                       */
#define RST_CONTROL_REG_RESET_CLKOUT_Pos  (22UL)                    /*!< RESET_CLKOUT (Bit 22)                                 */
#define RST_CONTROL_REG_RESET_CLKOUT_Msk  (0x400000UL)              /*!< RESET_CLKOUT (Bitfield-Mask: 0x01)                    */


/* =========================================================================================================================== */
/* ================                                         PERF_CNTR                                         ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define PERF_CNTR_CTRL_ENABLE_Pos         (9UL)                     /*!< ENABLE (Bit 9)                                        */
#define PERF_CNTR_CTRL_ENABLE_Msk         (0x200UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define PERF_CNTR_CTRL_CLEAR_Pos          (8UL)                     /*!< CLEAR (Bit 8)                                         */
#define PERF_CNTR_CTRL_CLEAR_Msk          (0x100UL)                 /*!< CLEAR (Bitfield-Mask: 0x01)                           */
#define PERF_CNTR_CTRL_CNT0_SEL_Pos       (4UL)                     /*!< CNT0_SEL (Bit 4)                                      */
#define PERF_CNTR_CTRL_CNT0_SEL_Msk       (0xf0UL)                  /*!< CNT0_SEL (Bitfield-Mask: 0x0f)                        */
#define PERF_CNTR_CTRL_CNT1_SEL_Pos       (0UL)                     /*!< CNT1_SEL (Bit 0)                                      */
#define PERF_CNTR_CTRL_CNT1_SEL_Msk       (0xfUL)                   /*!< CNT1_SEL (Bitfield-Mask: 0x0f)                        */
/* =========================================================  CNT0  ========================================================== */
#define PERF_CNTR_CNT0_CNT0_Pos           (0UL)                     /*!< CNT0 (Bit 0)                                          */
#define PERF_CNTR_CNT0_CNT0_Msk           (0xffffffffUL)            /*!< CNT0 (Bitfield-Mask: 0xffffffff)                      */
/* =========================================================  CNT1  ========================================================== */
#define PERF_CNTR_CNT1_CNT1_Pos           (0UL)                     /*!< CNT1 (Bit 0)                                          */
#define PERF_CNTR_CNT1_CNT1_Msk           (0xffffffffUL)            /*!< CNT1 (Bitfield-Mask: 0xffffffff)                      */
/* =========================================================  M4_PC  ========================================================= */
#define PERF_CNTR_M4_PC_M4_PC_Pos         (0UL)                     /*!< M4_PC (Bit 0)                                         */
#define PERF_CNTR_M4_PC_M4_PC_Msk         (0xffffffffUL)            /*!< M4_PC (Bitfield-Mask: 0xffffffff)                     */
/* ======================================================  M4_CUR_PRIO  ====================================================== */
#define PERF_CNTR_M4_CUR_PRIO_M4_CUR_PRIO_Pos (0UL)                 /*!< M4_CUR_PRIO (Bit 0)                                   */
#define PERF_CNTR_M4_CUR_PRIO_M4_CUR_PRIO_Msk (0xffUL)              /*!< M4_CUR_PRIO (Bitfield-Mask: 0xff)                     */


/* =========================================================================================================================== */
/* ================                                          REGFILE                                          ================ */
/* =========================================================================================================================== */

/* ======================================================  ICACHE_CTRL  ====================================================== */
#define REGFILE_ICACHE_CTRL_ICACHE_INVALIDATE_Pos (0UL)             /*!< ICACHE_INVALIDATE (Bit 0)                             */
#define REGFILE_ICACHE_CTRL_ICACHE_INVALIDATE_Msk (0x1UL)           /*!< ICACHE_INVALIDATE (Bitfield-Mask: 0x01)               */
/* ==================================================  PWR_ON_ACK_SETTING  =================================================== */
#define REGFILE_PWR_ON_ACK_SETTING_DIRECT_SETTING_Pos (0UL)         /*!< DIRECT_SETTING (Bit 0)                                */
#define REGFILE_PWR_ON_ACK_SETTING_DIRECT_SETTING_Msk (0x1UL)       /*!< DIRECT_SETTING (Bitfield-Mask: 0x01)                  */
#define REGFILE_PWR_ON_ACK_SETTING_SELECT_Pos (1UL)                 /*!< SELECT (Bit 1)                                        */
#define REGFILE_PWR_ON_ACK_SETTING_SELECT_Msk (0x2UL)               /*!< SELECT (Bitfield-Mask: 0x01)                          */
/* =======================================================  HPROT_CFG  ======================================================= */
#define REGFILE_HPROT_CFG_AHB_MSE_DPORT_PROT2_SEL_Pos (5UL)         /*!< AHB_MSE_DPORT_PROT2_SEL (Bit 5)                       */
#define REGFILE_HPROT_CFG_AHB_MSE_DPORT_PROT2_SEL_Msk (0x20UL)      /*!< AHB_MSE_DPORT_PROT2_SEL (Bitfield-Mask: 0x01)         */
#define REGFILE_HPROT_CFG_AHB_MSE_DPORT_PROT2_VAL_Pos (4UL)         /*!< AHB_MSE_DPORT_PROT2_VAL (Bit 4)                       */
#define REGFILE_HPROT_CFG_AHB_MSE_DPORT_PROT2_VAL_Msk (0x10UL)      /*!< AHB_MSE_DPORT_PROT2_VAL (Bitfield-Mask: 0x01)         */
#define REGFILE_HPROT_CFG_AHB_SYS2SSX_PROT2_SEL_Pos (3UL)           /*!< AHB_SYS2SSX_PROT2_SEL (Bit 3)                         */
#define REGFILE_HPROT_CFG_AHB_SYS2SSX_PROT2_SEL_Msk (0x8UL)         /*!< AHB_SYS2SSX_PROT2_SEL (Bitfield-Mask: 0x01)           */
#define REGFILE_HPROT_CFG_AHB_SYS2SSX_PROT2_VAL_Pos (2UL)           /*!< AHB_SYS2SSX_PROT2_VAL (Bit 2)                         */
#define REGFILE_HPROT_CFG_AHB_SYS2SSX_PROT2_VAL_Msk (0x4UL)         /*!< AHB_SYS2SSX_PROT2_VAL (Bitfield-Mask: 0x01)           */
#define REGFILE_HPROT_CFG_AHB_PROG_PROT2_SEL_Pos (1UL)              /*!< AHB_PROG_PROT2_SEL (Bit 1)                            */
#define REGFILE_HPROT_CFG_AHB_PROG_PROT2_SEL_Msk (0x2UL)            /*!< AHB_PROG_PROT2_SEL (Bitfield-Mask: 0x01)              */
#define REGFILE_HPROT_CFG_AHB_PROG_PROT2_VAL_Pos (0UL)              /*!< AHB_PROG_PROT2_VAL (Bit 0)                            */
#define REGFILE_HPROT_CFG_AHB_PROG_PROT2_VAL_Msk (0x1UL)            /*!< AHB_PROG_PROT2_VAL (Bitfield-Mask: 0x01)              */
/* ===================================================  MCU_SW_RESET_REQ  ==================================================== */
#define REGFILE_MCU_SW_RESET_REQ_MCU_SW_RESET_REQ_Pos (0UL)         /*!< MCU_SW_RESET_REQ (Bit 0)                              */
#define REGFILE_MCU_SW_RESET_REQ_MCU_SW_RESET_REQ_Msk (0xffUL)      /*!< MCU_SW_RESET_REQ (Bitfield-Mask: 0xff)                */
/* ======================================================  MCU_STATUS  ======================================================= */
#define REGFILE_MCU_STATUS_MCU_USER_TIMER_Pos (14UL)                /*!< MCU_USER_TIMER (Bit 14)                               */
#define REGFILE_MCU_STATUS_MCU_USER_TIMER_Msk (0x4000UL)            /*!< MCU_USER_TIMER (Bitfield-Mask: 0x01)                  */
#define REGFILE_MCU_STATUS_MCU_WD_Pos     (13UL)                    /*!< MCU_WD (Bit 13)                                       */
#define REGFILE_MCU_STATUS_MCU_WD_Msk     (0x2000UL)                /*!< MCU_WD (Bitfield-Mask: 0x01)                          */
#define REGFILE_MCU_STATUS_SIC_FAIL_Pos   (12UL)                    /*!< SIC_FAIL (Bit 12)                                     */
#define REGFILE_MCU_STATUS_SIC_FAIL_Msk   (0x1000UL)                /*!< SIC_FAIL (Bitfield-Mask: 0x01)                        */
#define REGFILE_MCU_STATUS_M4_DEBUG_MODE_Pos (11UL)                 /*!< M4_DEBUG_MODE (Bit 11)                                */
#define REGFILE_MCU_STATUS_M4_DEBUG_MODE_Msk (0x800UL)              /*!< M4_DEBUG_MODE (Bitfield-Mask: 0x01)                   */
#define REGFILE_MCU_STATUS_M4_HALTED_Pos  (10UL)                    /*!< M4_HALTED (Bit 10)                                    */
#define REGFILE_MCU_STATUS_M4_HALTED_Msk  (0x400UL)                 /*!< M4_HALTED (Bitfield-Mask: 0x01)                       */
#define REGFILE_MCU_STATUS_M4_SYSRSTREQ_Pos (9UL)                   /*!< M4_SYSRSTREQ (Bit 9)                                  */
#define REGFILE_MCU_STATUS_M4_SYSRSTREQ_Msk (0x200UL)               /*!< M4_SYSRSTREQ (Bitfield-Mask: 0x01)                    */
#define REGFILE_MCU_STATUS_M4_LOCKUP_Pos  (8UL)                     /*!< M4_LOCKUP (Bit 8)                                     */
#define REGFILE_MCU_STATUS_M4_LOCKUP_Msk  (0x100UL)                 /*!< M4_LOCKUP (Bitfield-Mask: 0x01)                       */
#define REGFILE_MCU_STATUS_SW_RST_REQ_Pos (0UL)                     /*!< SW_RST_REQ (Bit 0)                                    */
#define REGFILE_MCU_STATUS_SW_RST_REQ_Msk (0xffUL)                  /*!< SW_RST_REQ (Bitfield-Mask: 0xff)                      */
/* ==================================================  MCU_STATUS_MASK_NMI  ================================================== */
#define REGFILE_MCU_STATUS_MASK_NMI_MCU_STATUS_MASK_NMI_Pos (0UL)   /*!< MCU_STATUS_MASK_NMI (Bit 0)                           */
#define REGFILE_MCU_STATUS_MASK_NMI_MCU_STATUS_MASK_NMI_Msk (0xffffUL) /*!< MCU_STATUS_MASK_NMI (Bitfield-Mask: 0xffff)        */
/* ==================================================  MCU_STATUS_MASK_PMP  ================================================== */
#define REGFILE_MCU_STATUS_MASK_PMP_MCU_STATUS_MASK_PMP_Pos (0UL)   /*!< MCU_STATUS_MASK_PMP (Bit 0)                           */
#define REGFILE_MCU_STATUS_MASK_PMP_MCU_STATUS_MASK_PMP_Msk (0xffffUL) /*!< MCU_STATUS_MASK_PMP (Bitfield-Mask: 0xffff)        */
/* ===================================================  MCU_DMA_HANDSHAKE  =================================================== */
#define REGFILE_MCU_DMA_HANDSHAKE_SELECT_Pos (2UL)                  /*!< SELECT (Bit 2)                                        */
#define REGFILE_MCU_DMA_HANDSHAKE_SELECT_Msk (0x1cUL)               /*!< SELECT (Bitfield-Mask: 0x07)                          */
#define REGFILE_MCU_DMA_HANDSHAKE_CFG_SELECT_Pos (0UL)              /*!< CFG_SELECT (Bit 0)                                    */
#define REGFILE_MCU_DMA_HANDSHAKE_CFG_SELECT_Msk (0x3UL)            /*!< CFG_SELECT (Bitfield-Mask: 0x03)                      */
/* ===============================================  MCU_CLK32K_EDGE_INT_STAT  ================================================ */
#define REGFILE_MCU_CLK32K_EDGE_INT_STAT_MCU_CLK32K_EDGE_INT_STAT_Pos (0UL) /*!< MCU_CLK32K_EDGE_INT_STAT (Bit 0)              */
#define REGFILE_MCU_CLK32K_EDGE_INT_STAT_MCU_CLK32K_EDGE_INT_STAT_Msk (0x1UL) /*!< MCU_CLK32K_EDGE_INT_STAT (Bitfield-Mask: 0x01) */
/* ================================================  MCU_CLK32K_EDGE_INT_RC  ================================================= */
#define REGFILE_MCU_CLK32K_EDGE_INT_RC_MCU_CLK32K_EDGE_INT_RC_Pos (0UL) /*!< MCU_CLK32K_EDGE_INT_RC (Bit 0)                    */
#define REGFILE_MCU_CLK32K_EDGE_INT_RC_MCU_CLK32K_EDGE_INT_RC_Msk (0x1UL) /*!< MCU_CLK32K_EDGE_INT_RC (Bitfield-Mask: 0x01)    */
/* ================================================  MCU_CLK32K_EDGE_INT_EN  ================================================= */
#define REGFILE_MCU_CLK32K_EDGE_INT_EN_MCU_CLK32K_EDGE_INT_EN_Pos (0UL) /*!< MCU_CLK32K_EDGE_INT_EN (Bit 0)                    */
#define REGFILE_MCU_CLK32K_EDGE_INT_EN_MCU_CLK32K_EDGE_INT_EN_Msk (0x1UL) /*!< MCU_CLK32K_EDGE_INT_EN (Bitfield-Mask: 0x01)    */
/* ===================================================  UART0_WAKEUP_CFG  ==================================================== */
#define REGFILE_UART0_WAKEUP_CFG_UART_WAKEUP_EN_Pos (0UL)           /*!< UART_WAKEUP_EN (Bit 0)                                */
#define REGFILE_UART0_WAKEUP_CFG_UART_WAKEUP_EN_Msk (0x1UL)         /*!< UART_WAKEUP_EN (Bitfield-Mask: 0x01)                  */
/* ===================================================  UART0_WAKEUP_STAT  =================================================== */
#define REGFILE_UART0_WAKEUP_STAT_UART_WAKEUP_Pos (0UL)             /*!< UART_WAKEUP (Bit 0)                                   */
#define REGFILE_UART0_WAKEUP_STAT_UART_WAKEUP_Msk (0x1UL)           /*!< UART_WAKEUP (Bitfield-Mask: 0x01)                     */
/* ====================================================  UART0_WAKEUP_RC  ==================================================== */
#define REGFILE_UART0_WAKEUP_RC_UART_WAKEUP_Pos (0UL)               /*!< UART_WAKEUP (Bit 0)                                   */
#define REGFILE_UART0_WAKEUP_RC_UART_WAKEUP_Msk (0x1UL)             /*!< UART_WAKEUP (Bitfield-Mask: 0x01)                     */
/* ===================================================  UART1_WAKEUP_CFG  ==================================================== */
#define REGFILE_UART1_WAKEUP_CFG_UART_WAKEUP_EN_Pos (0UL)           /*!< UART_WAKEUP_EN (Bit 0)                                */
#define REGFILE_UART1_WAKEUP_CFG_UART_WAKEUP_EN_Msk (0x1UL)         /*!< UART_WAKEUP_EN (Bitfield-Mask: 0x01)                  */
/* ===================================================  UART1_WAKEUP_STAT  =================================================== */
#define REGFILE_UART1_WAKEUP_STAT_UART_WAKEUP_Pos (0UL)             /*!< UART_WAKEUP (Bit 0)                                   */
#define REGFILE_UART1_WAKEUP_STAT_UART_WAKEUP_Msk (0x1UL)           /*!< UART_WAKEUP (Bitfield-Mask: 0x01)                     */
/* ====================================================  UART1_WAKEUP_RC  ==================================================== */
#define REGFILE_UART1_WAKEUP_RC_UART_WAKEUP_Pos (0UL)               /*!< UART_WAKEUP (Bit 0)                                   */
#define REGFILE_UART1_WAKEUP_RC_UART_WAKEUP_Msk (0x1UL)             /*!< UART_WAKEUP (Bitfield-Mask: 0x01)                     */


/* =========================================================================================================================== */
/* ================                                       GP_TIMER_CTRL                                       ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define GP_TIMER_CTRL_CTRL_EN_Pos         (0UL)                     /*!< EN (Bit 0)                                            */
#define GP_TIMER_CTRL_CTRL_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  PRESET_VALUE  ====================================================== */
#define GP_TIMER_CTRL_PRESET_VALUE_PRESET_VALUE_Pos (0UL)           /*!< PRESET_VALUE (Bit 0)                                  */
#define GP_TIMER_CTRL_PRESET_VALUE_PRESET_VALUE_Msk (0xffffffffUL)  /*!< PRESET_VALUE (Bitfield-Mask: 0xffffffff)              */
/* ======================================================  UPDT_OFFSET  ====================================================== */
#define GP_TIMER_CTRL_UPDT_OFFSET_OFFSET_VALUE_Pos (0UL)            /*!< OFFSET_VALUE (Bit 0)                                  */
#define GP_TIMER_CTRL_UPDT_OFFSET_OFFSET_VALUE_Msk (0xffffffffUL)   /*!< OFFSET_VALUE (Bitfield-Mask: 0xffffffff)              */
/* =========================================================  VALUE  ========================================================= */
#define GP_TIMER_CTRL_VALUE_VALUE_Pos     (0UL)                     /*!< VALUE (Bit 0)                                         */
#define GP_TIMER_CTRL_VALUE_VALUE_Msk     (0xffffffffUL)            /*!< VALUE (Bitfield-Mask: 0xffffffff)                     */
/* ==========================================================  INT  ========================================================== */
#define GP_TIMER_CTRL_INT_INT_Pos         (0UL)                     /*!< INT (Bit 0)                                           */
#define GP_TIMER_CTRL_INT_INT_Msk         (0x1UL)                   /*!< INT (Bitfield-Mask: 0x01)                             */


/* =========================================================================================================================== */
/* ================                                            NCO                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  CFG  ========================================================== */
#define NCO_CFG_MCU_NCO_RATE_Pos          (0UL)                     /*!< MCU_NCO_RATE (Bit 0)                                  */
#define NCO_CFG_MCU_NCO_RATE_Msk          (0xffffUL)                /*!< MCU_NCO_RATE (Bitfield-Mask: 0xffff)                  */
#define NCO_CFG_MCU_NCO_ENABLE_Pos        (16UL)                    /*!< MCU_NCO_ENABLE (Bit 16)                               */
#define NCO_CFG_MCU_NCO_ENABLE_Msk        (0x10000UL)               /*!< MCU_NCO_ENABLE (Bitfield-Mask: 0x01)                  */
/* ======================================================  WRAP_VALUE  ======================================================= */
#define NCO_WRAP_VALUE_WRAP_VALUE_Pos     (0UL)                     /*!< WRAP_VALUE (Bit 0)                                    */
#define NCO_WRAP_VALUE_WRAP_VALUE_Msk     (0x1ffffUL)               /*!< WRAP_VALUE (Bitfield-Mask: 0x1ffff)                   */
/* =======================================================  ACC_VALUE  ======================================================= */
#define NCO_ACC_VALUE_ACC_VALUE_Pos       (0UL)                     /*!< ACC_VALUE (Bit 0)                                     */
#define NCO_ACC_VALUE_ACC_VALUE_Msk       (0xffffUL)                /*!< ACC_VALUE (Bitfield-Mask: 0xffff)                     */
/* ====================================================  ACC_LOAD_VALUE  ===================================================== */
#define NCO_ACC_LOAD_VALUE_ACC_LOAD_VALUE_Pos (0UL)                 /*!< ACC_LOAD_VALUE (Bit 0)                                */
#define NCO_ACC_LOAD_VALUE_ACC_LOAD_VALUE_Msk (0xffffUL)            /*!< ACC_LOAD_VALUE (Bitfield-Mask: 0xffff)                */


/* =========================================================================================================================== */
/* ================                                       SLEEP_TIMERS                                        ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define SLEEP_TIMERS_CTRL_HALT_TIMERS_Pos (0UL)                     /*!< HALT_TIMERS (Bit 0)                                   */
#define SLEEP_TIMERS_CTRL_HALT_TIMERS_Msk (0x1UL)                   /*!< HALT_TIMERS (Bitfield-Mask: 0x01)                     */
#define SLEEP_TIMERS_CTRL_RECOVER_TIMERS_Pos (1UL)                  /*!< RECOVER_TIMERS (Bit 1)                                */
#define SLEEP_TIMERS_CTRL_RECOVER_TIMERS_Msk (0x2UL)                /*!< RECOVER_TIMERS (Bitfield-Mask: 0x01)                  */
#define SLEEP_TIMERS_CTRL_STALL_TIMERS_Pos (2UL)                    /*!< STALL_TIMERS (Bit 2)                                  */
#define SLEEP_TIMERS_CTRL_STALL_TIMERS_Msk (0x4UL)                  /*!< STALL_TIMERS (Bitfield-Mask: 0x01)                    */
#define SLEEP_TIMERS_CTRL_TIMERS_HALT_DONE_Pos (3UL)                /*!< TIMERS_HALT_DONE (Bit 3)                              */
#define SLEEP_TIMERS_CTRL_TIMERS_HALT_DONE_Msk (0x8UL)              /*!< TIMERS_HALT_DONE (Bitfield-Mask: 0x01)                */
#define SLEEP_TIMERS_CTRL_TIMERS_RECOVER_DONE_Pos (4UL)             /*!< TIMERS_RECOVER_DONE (Bit 4)                           */
#define SLEEP_TIMERS_CTRL_TIMERS_RECOVER_DONE_Msk (0x10UL)          /*!< TIMERS_RECOVER_DONE (Bitfield-Mask: 0x01)             */
/* =======================================================  MASK_CTRL  ======================================================= */
#define SLEEP_TIMERS_MASK_CTRL_MCU_TIMERS_MASK_Pos (0UL)            /*!< MCU_TIMERS_MASK (Bit 0)                               */
#define SLEEP_TIMERS_MASK_CTRL_MCU_TIMERS_MASK_Msk (0x3UL)          /*!< MCU_TIMERS_MASK (Bitfield-Mask: 0x03)                 */


/* =========================================================================================================================== */
/* ================                                      SLOW_IF_CLKOUT                                       ================ */
/* =========================================================================================================================== */

/* ======================================================  CLKOUT_CFG  ======================================================= */
#define SLOW_IF_CLKOUT_CLKOUT_CFG_SLOW_IF_CLKOUT_DEFAULT_HIGH_Pos (1UL) /*!< SLOW_IF_CLKOUT_DEFAULT_HIGH (Bit 1)               */
#define SLOW_IF_CLKOUT_CLKOUT_CFG_SLOW_IF_CLKOUT_DEFAULT_HIGH_Msk (0x2UL) /*!< SLOW_IF_CLKOUT_DEFAULT_HIGH (Bitfield-Mask: 0x01) */
#define SLOW_IF_CLKOUT_CLKOUT_CFG_SLOW_IF_CLKOUT_GRACEFUL_STOP_EN_Pos (0UL) /*!< SLOW_IF_CLKOUT_GRACEFUL_STOP_EN (Bit 0)       */
#define SLOW_IF_CLKOUT_CLKOUT_CFG_SLOW_IF_CLKOUT_GRACEFUL_STOP_EN_Msk (0x1UL) /*!< SLOW_IF_CLKOUT_GRACEFUL_STOP_EN (Bitfield-Mask: 0x01) */
/* =======================================================  CLKOUT_EN  ======================================================= */
#define SLOW_IF_CLKOUT_CLKOUT_EN_CLKOUT_EN_Pos (0UL)                /*!< CLKOUT_EN (Bit 0)                                     */
#define SLOW_IF_CLKOUT_CLKOUT_EN_CLKOUT_EN_Msk (0x1UL)              /*!< CLKOUT_EN (Bitfield-Mask: 0x01)                       */
/* ====================================================  CLKOUT_MAX_CNT  ===================================================== */
#define SLOW_IF_CLKOUT_CLKOUT_MAX_CNT_CLKOUT_MAX_CNT_Pos (0UL)      /*!< CLKOUT_MAX_CNT (Bit 0)                                */
#define SLOW_IF_CLKOUT_CLKOUT_MAX_CNT_CLKOUT_MAX_CNT_Msk (0xffffffffUL) /*!< CLKOUT_MAX_CNT (Bitfield-Mask: 0xffffffff)        */
/* ======================================================  CLKOUT_RATE  ====================================================== */
#define SLOW_IF_CLKOUT_CLKOUT_RATE_CLKOUT_RATE_Pos (0UL)            /*!< CLKOUT_RATE (Bit 0)                                   */
#define SLOW_IF_CLKOUT_CLKOUT_RATE_CLKOUT_RATE_Msk (0xffffffffUL)   /*!< CLKOUT_RATE (Bitfield-Mask: 0xffffffff)               */
/* ======================================================  SEL_EXT_CLK  ====================================================== */
#define SLOW_IF_CLKOUT_SEL_EXT_CLK_SEL_EXT_CLK_Pos (0UL)            /*!< SEL_EXT_CLK (Bit 0)                                   */
#define SLOW_IF_CLKOUT_SEL_EXT_CLK_SEL_EXT_CLK_Msk (0x1UL)          /*!< SEL_EXT_CLK (Bitfield-Mask: 0x01)                     */


/* =========================================================================================================================== */
/* ================                                        USER_TIMERS                                        ================ */
/* =========================================================================================================================== */

/* ===================================================  IDCODE_PERIPHERAL  =================================================== */
#define USER_TIMERS_IDCODE_PERIPHERAL_IDCODE_PERIPHERAL_Pos (0UL)   /*!< IDCODE_PERIPHERAL (Bit 0)                             */
#define USER_TIMERS_IDCODE_PERIPHERAL_IDCODE_PERIPHERAL_Msk (0xffffffffUL) /*!< IDCODE_PERIPHERAL (Bitfield-Mask: 0xffffffff)  */
/* ====================================================  IDCODE_INSTANCE  ==================================================== */
#define USER_TIMERS_IDCODE_INSTANCE_IDCODE_INSTANCE_Pos (0UL)       /*!< IDCODE_INSTANCE (Bit 0)                               */
#define USER_TIMERS_IDCODE_INSTANCE_IDCODE_INSTANCE_Msk (0xffffffffUL) /*!< IDCODE_INSTANCE (Bitfield-Mask: 0xffffffff)        */
/* ====================================================  IDCODE_REVISION  ==================================================== */
#define USER_TIMERS_IDCODE_REVISION_USER_TIMER_IDCODE_REVISION_MAIN_Pos (16UL) /*!< USER_TIMER_IDCODE_REVISION_MAIN (Bit 16)   */
#define USER_TIMERS_IDCODE_REVISION_USER_TIMER_IDCODE_REVISION_MAIN_Msk (0xffff0000UL) /*!< USER_TIMER_IDCODE_REVISION_MAIN (Bitfield-Mask: 0xffff) */
#define USER_TIMERS_IDCODE_REVISION_USER_TIMER_IDCODE_REVISION_SUB_Pos (0UL) /*!< USER_TIMER_IDCODE_REVISION_SUB (Bit 0)       */
#define USER_TIMERS_IDCODE_REVISION_USER_TIMER_IDCODE_REVISION_SUB_Msk (0xffffUL) /*!< USER_TIMER_IDCODE_REVISION_SUB (Bitfield-Mask: 0xffff) */
/* ======================================================  IDCODE_SVN  ======================================================= */
#define USER_TIMERS_IDCODE_SVN_IDCODE_SVN_Pos (0UL)                 /*!< IDCODE_SVN (Bit 0)                                    */
#define USER_TIMERS_IDCODE_SVN_IDCODE_SVN_Msk (0xffffffffUL)        /*!< IDCODE_SVN (Bitfield-Mask: 0xffffffff)                */
/* ====================================================  CONTROL_CONFIG  ===================================================== */
#define USER_TIMERS_CONTROL_CONFIG_CONTROL_CONFIG_LOOP_MODE_Pos (0UL) /*!< CONTROL_CONFIG_LOOP_MODE (Bit 0)                    */
#define USER_TIMERS_CONTROL_CONFIG_CONTROL_CONFIG_LOOP_MODE_Msk (0x1UL) /*!< CONTROL_CONFIG_LOOP_MODE (Bitfield-Mask: 0x01)    */
/* ====================================================  CONTROL_OR_OUT0  ==================================================== */
#define USER_TIMERS_CONTROL_OR_OUT0_CONTROL_OR_OUT0_Pos (0UL)       /*!< CONTROL_OR_OUT0 (Bit 0)                               */
#define USER_TIMERS_CONTROL_OR_OUT0_CONTROL_OR_OUT0_Msk (0xfUL)     /*!< CONTROL_OR_OUT0 (Bitfield-Mask: 0x0f)                 */
/* ====================================================  CONTROL_OR_OUT1  ==================================================== */
#define USER_TIMERS_CONTROL_OR_OUT1_CONTROL_OR_OUT1_Pos (0UL)       /*!< CONTROL_OR_OUT1 (Bit 0)                               */
#define USER_TIMERS_CONTROL_OR_OUT1_CONTROL_OR_OUT1_Msk (0xfUL)     /*!< CONTROL_OR_OUT1 (Bitfield-Mask: 0x0f)                 */
/* ====================================================  CONTROL_OR_OUT2  ==================================================== */
#define USER_TIMERS_CONTROL_OR_OUT2_CONTROL_OR_OUT2_Pos (0UL)       /*!< CONTROL_OR_OUT2 (Bit 0)                               */
#define USER_TIMERS_CONTROL_OR_OUT2_CONTROL_OR_OUT2_Msk (0xfUL)     /*!< CONTROL_OR_OUT2 (Bitfield-Mask: 0x0f)                 */
/* ====================================================  CONTROL_OR_OUT3  ==================================================== */
#define USER_TIMERS_CONTROL_OR_OUT3_CONTROL_OR_OUT3_Pos (0UL)       /*!< CONTROL_OR_OUT3 (Bit 0)                               */
#define USER_TIMERS_CONTROL_OR_OUT3_CONTROL_OR_OUT3_Msk (0xfUL)     /*!< CONTROL_OR_OUT3 (Bitfield-Mask: 0x0f)                 */
/* ================================================  CONTROL_DEBOUNCE_INPUT0  ================================================ */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT0_USER_TIMER_CONTROL_DEBOUNCE_INPUT0_CLOCK_Pos (16UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT0_CLOCK (Bit 16) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT0_USER_TIMER_CONTROL_DEBOUNCE_INPUT0_CLOCK_Msk (0x30000UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT0_CLOCK (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT0_USER_TIMER_CONTROL_DEBOUNCE_INPUT0_LEVEL_Pos (0UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT0_LEVEL (Bit 0) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT0_USER_TIMER_CONTROL_DEBOUNCE_INPUT0_LEVEL_Msk (0x7UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT0_LEVEL (Bitfield-Mask: 0x07) */
/* ================================================  CONTROL_DEBOUNCE_INPUT1  ================================================ */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT1_USER_TIMER_CONTROL_DEBOUNCE_INPUT1_CLOCK_Pos (16UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT1_CLOCK (Bit 16) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT1_USER_TIMER_CONTROL_DEBOUNCE_INPUT1_CLOCK_Msk (0x30000UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT1_CLOCK (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT1_USER_TIMER_CONTROL_DEBOUNCE_INPUT1_LEVEL_Pos (0UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT1_LEVEL (Bit 0) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT1_USER_TIMER_CONTROL_DEBOUNCE_INPUT1_LEVEL_Msk (0x7UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT1_LEVEL (Bitfield-Mask: 0x07) */
/* ================================================  CONTROL_DEBOUNCE_INPUT2  ================================================ */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT2_USER_TIMER_CONTROL_DEBOUNCE_INPUT2_CLOCK_Pos (16UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT2_CLOCK (Bit 16) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT2_USER_TIMER_CONTROL_DEBOUNCE_INPUT2_CLOCK_Msk (0x30000UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT2_CLOCK (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT2_USER_TIMER_CONTROL_DEBOUNCE_INPUT2_LEVEL_Pos (0UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT2_LEVEL (Bit 0) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT2_USER_TIMER_CONTROL_DEBOUNCE_INPUT2_LEVEL_Msk (0x7UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT2_LEVEL (Bitfield-Mask: 0x07) */
/* ================================================  CONTROL_DEBOUNCE_INPUT3  ================================================ */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT3_USER_TIMER_CONTROL_DEBOUNCE_INPUT3_CLOCK_Pos (16UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT3_CLOCK (Bit 16) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT3_USER_TIMER_CONTROL_DEBOUNCE_INPUT3_CLOCK_Msk (0x30000UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT3_CLOCK (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT3_USER_TIMER_CONTROL_DEBOUNCE_INPUT3_LEVEL_Pos (0UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT3_LEVEL (Bit 0) */
#define USER_TIMERS_CONTROL_DEBOUNCE_INPUT3_USER_TIMER_CONTROL_DEBOUNCE_INPUT3_LEVEL_Msk (0x7UL) /*!< USER_TIMER_CONTROL_DEBOUNCE_INPUT3_LEVEL (Bitfield-Mask: 0x07) */
/* ======================================================  TIMER0_CTRL  ====================================================== */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_LOAD_TIMER_Pos (0UL) /*!< USER_TIMER_TIMER0_CTRL_LOAD_TIMER (Bit 0)     */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_LOAD_TIMER_Msk (0x1UL) /*!< USER_TIMER_TIMER0_CTRL_LOAD_TIMER (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_ENABLE_Pos (1UL) /*!< USER_TIMER_TIMER0_CTRL_ENABLE (Bit 1)             */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_ENABLE_Msk (0x2UL) /*!< USER_TIMER_TIMER0_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_TIMER_MODE_Pos (2UL) /*!< USER_TIMER_TIMER0_CTRL_TIMER_MODE (Bit 2)     */
#define USER_TIMERS_TIMER0_CTRL_USER_TIMER_TIMER0_CTRL_TIMER_MODE_Msk (0xcUL) /*!< USER_TIMER_TIMER0_CTRL_TIMER_MODE (Bitfield-Mask: 0x03) */
/* ====================================================  TIMER0_COUNTER  ===================================================== */
#define USER_TIMERS_TIMER0_COUNTER_TIMER0_COUNTER_Pos (0UL)         /*!< TIMER0_COUNTER (Bit 0)                                */
#define USER_TIMERS_TIMER0_COUNTER_TIMER0_COUNTER_Msk (0xffffUL)    /*!< TIMER0_COUNTER (Bitfield-Mask: 0xffff)                */
/* ===================================================  TIMER0_PRESCALER  ==================================================== */
#define USER_TIMERS_TIMER0_PRESCALER_TIMER0_PRESCALER_Pos (0UL)     /*!< TIMER0_PRESCALER (Bit 0)                              */
#define USER_TIMERS_TIMER0_PRESCALER_TIMER0_PRESCALER_Msk (0xffffUL) /*!< TIMER0_PRESCALER (Bitfield-Mask: 0xffff)             */
/* =====================================================  TIMER0_SW_IT  ====================================================== */
#define USER_TIMERS_TIMER0_SW_IT_TIMER0_SW_IT_Pos (0UL)             /*!< TIMER0_SW_IT (Bit 0)                                  */
#define USER_TIMERS_TIMER0_SW_IT_TIMER0_SW_IT_Msk (0xffffffffUL)    /*!< TIMER0_SW_IT (Bitfield-Mask: 0xffffffff)              */
/* =====================================================  TIMER0_TIMER  ====================================================== */
#define USER_TIMERS_TIMER0_TIMER_TIMER0_TIMER_Pos (0UL)             /*!< TIMER0_TIMER (Bit 0)                                  */
#define USER_TIMERS_TIMER0_TIMER_TIMER0_TIMER_Msk (0xffffffffUL)    /*!< TIMER0_TIMER (Bitfield-Mask: 0xffffffff)              */
/* ======================================================  TIMER1_CTRL  ====================================================== */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_LOAD_TIMER_Pos (0UL) /*!< USER_TIMER_TIMER1_CTRL_LOAD_TIMER (Bit 0)     */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_LOAD_TIMER_Msk (0x1UL) /*!< USER_TIMER_TIMER1_CTRL_LOAD_TIMER (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_ENABLE_Pos (1UL) /*!< USER_TIMER_TIMER1_CTRL_ENABLE (Bit 1)             */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_ENABLE_Msk (0x2UL) /*!< USER_TIMER_TIMER1_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_TIMER_MODE_Pos (2UL) /*!< USER_TIMER_TIMER1_CTRL_TIMER_MODE (Bit 2)     */
#define USER_TIMERS_TIMER1_CTRL_USER_TIMER_TIMER1_CTRL_TIMER_MODE_Msk (0xcUL) /*!< USER_TIMER_TIMER1_CTRL_TIMER_MODE (Bitfield-Mask: 0x03) */
/* ====================================================  TIMER1_COUNTER  ===================================================== */
#define USER_TIMERS_TIMER1_COUNTER_TIMER1_COUNTER_Pos (0UL)         /*!< TIMER1_COUNTER (Bit 0)                                */
#define USER_TIMERS_TIMER1_COUNTER_TIMER1_COUNTER_Msk (0xffffUL)    /*!< TIMER1_COUNTER (Bitfield-Mask: 0xffff)                */
/* ===================================================  TIMER1_PRESCALER  ==================================================== */
#define USER_TIMERS_TIMER1_PRESCALER_TIMER1_PRESCALER_Pos (0UL)     /*!< TIMER1_PRESCALER (Bit 0)                              */
#define USER_TIMERS_TIMER1_PRESCALER_TIMER1_PRESCALER_Msk (0xffffUL) /*!< TIMER1_PRESCALER (Bitfield-Mask: 0xffff)             */
/* =====================================================  TIMER1_SW_IT  ====================================================== */
#define USER_TIMERS_TIMER1_SW_IT_TIMER1_SW_IT_Pos (0UL)             /*!< TIMER1_SW_IT (Bit 0)                                  */
#define USER_TIMERS_TIMER1_SW_IT_TIMER1_SW_IT_Msk (0xffffffffUL)    /*!< TIMER1_SW_IT (Bitfield-Mask: 0xffffffff)              */
/* =====================================================  TIMER1_TIMER  ====================================================== */
#define USER_TIMERS_TIMER1_TIMER_TIMER1_TIMER_Pos (0UL)             /*!< TIMER1_TIMER (Bit 0)                                  */
#define USER_TIMERS_TIMER1_TIMER_TIMER1_TIMER_Msk (0xffffffffUL)    /*!< TIMER1_TIMER (Bitfield-Mask: 0xffffffff)              */
/* ======================================================  TIMER2_CTRL  ====================================================== */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_LOAD_TIMER_Pos (0UL) /*!< USER_TIMER_TIMER2_CTRL_LOAD_TIMER (Bit 0)     */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_LOAD_TIMER_Msk (0x1UL) /*!< USER_TIMER_TIMER2_CTRL_LOAD_TIMER (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_ENABLE_Pos (1UL) /*!< USER_TIMER_TIMER2_CTRL_ENABLE (Bit 1)             */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_ENABLE_Msk (0x2UL) /*!< USER_TIMER_TIMER2_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_TIMER_MODE_Pos (2UL) /*!< USER_TIMER_TIMER2_CTRL_TIMER_MODE (Bit 2)     */
#define USER_TIMERS_TIMER2_CTRL_USER_TIMER_TIMER2_CTRL_TIMER_MODE_Msk (0xcUL) /*!< USER_TIMER_TIMER2_CTRL_TIMER_MODE (Bitfield-Mask: 0x03) */
/* ====================================================  TIMER2_COUNTER  ===================================================== */
#define USER_TIMERS_TIMER2_COUNTER_TIMER2_COUNTER_Pos (0UL)         /*!< TIMER2_COUNTER (Bit 0)                                */
#define USER_TIMERS_TIMER2_COUNTER_TIMER2_COUNTER_Msk (0xffffUL)    /*!< TIMER2_COUNTER (Bitfield-Mask: 0xffff)                */
/* ===================================================  TIMER2_PRESCALER  ==================================================== */
#define USER_TIMERS_TIMER2_PRESCALER_TIMER2_PRESCALER_Pos (0UL)     /*!< TIMER2_PRESCALER (Bit 0)                              */
#define USER_TIMERS_TIMER2_PRESCALER_TIMER2_PRESCALER_Msk (0xffffUL) /*!< TIMER2_PRESCALER (Bitfield-Mask: 0xffff)             */
/* =====================================================  TIMER2_SW_IT  ====================================================== */
#define USER_TIMERS_TIMER2_SW_IT_TIMER2_SW_IT_Pos (0UL)             /*!< TIMER2_SW_IT (Bit 0)                                  */
#define USER_TIMERS_TIMER2_SW_IT_TIMER2_SW_IT_Msk (0xffffffffUL)    /*!< TIMER2_SW_IT (Bitfield-Mask: 0xffffffff)              */
/* =====================================================  TIMER2_TIMER  ====================================================== */
#define USER_TIMERS_TIMER2_TIMER_TIMER2_TIMER_Pos (0UL)             /*!< TIMER2_TIMER (Bit 0)                                  */
#define USER_TIMERS_TIMER2_TIMER_TIMER2_TIMER_Msk (0xffffffffUL)    /*!< TIMER2_TIMER (Bitfield-Mask: 0xffffffff)              */
/* ======================================================  TIMER3_CTRL  ====================================================== */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_LOAD_TIMER_Pos (0UL) /*!< USER_TIMER_TIMER3_CTRL_LOAD_TIMER (Bit 0)     */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_LOAD_TIMER_Msk (0x1UL) /*!< USER_TIMER_TIMER3_CTRL_LOAD_TIMER (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_ENABLE_Pos (1UL) /*!< USER_TIMER_TIMER3_CTRL_ENABLE (Bit 1)             */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_ENABLE_Msk (0x2UL) /*!< USER_TIMER_TIMER3_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_TIMER_MODE_Pos (2UL) /*!< USER_TIMER_TIMER3_CTRL_TIMER_MODE (Bit 2)     */
#define USER_TIMERS_TIMER3_CTRL_USER_TIMER_TIMER3_CTRL_TIMER_MODE_Msk (0xcUL) /*!< USER_TIMER_TIMER3_CTRL_TIMER_MODE (Bitfield-Mask: 0x03) */
/* ====================================================  TIMER3_COUNTER  ===================================================== */
#define USER_TIMERS_TIMER3_COUNTER_TIMER3_COUNTER_Pos (0UL)         /*!< TIMER3_COUNTER (Bit 0)                                */
#define USER_TIMERS_TIMER3_COUNTER_TIMER3_COUNTER_Msk (0xffffUL)    /*!< TIMER3_COUNTER (Bitfield-Mask: 0xffff)                */
/* ===================================================  TIMER3_PRESCALER  ==================================================== */
#define USER_TIMERS_TIMER3_PRESCALER_TIMER3_PRESCALER_Pos (0UL)     /*!< TIMER3_PRESCALER (Bit 0)                              */
#define USER_TIMERS_TIMER3_PRESCALER_TIMER3_PRESCALER_Msk (0xffffUL) /*!< TIMER3_PRESCALER (Bitfield-Mask: 0xffff)             */
/* =====================================================  TIMER3_SW_IT  ====================================================== */
#define USER_TIMERS_TIMER3_SW_IT_TIMER3_SW_IT_Pos (0UL)             /*!< TIMER3_SW_IT (Bit 0)                                  */
#define USER_TIMERS_TIMER3_SW_IT_TIMER3_SW_IT_Msk (0xffffffffUL)    /*!< TIMER3_SW_IT (Bitfield-Mask: 0xffffffff)              */
/* =====================================================  TIMER3_TIMER  ====================================================== */
#define USER_TIMERS_TIMER3_TIMER_TIMER3_TIMER_Pos (0UL)             /*!< TIMER3_TIMER (Bit 0)                                  */
#define USER_TIMERS_TIMER3_TIMER_TIMER3_TIMER_Msk (0xffffffffUL)    /*!< TIMER3_TIMER (Bitfield-Mask: 0xffffffff)              */
/* =================================================  COMPARE0_COMPARE_CTRL  ================================================= */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_SELECT_POLARITY_Pos (0UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_SELECT_POLARITY (Bit 0) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_SELECT_POLARITY_Msk (0x1UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_SELECT_POLARITY (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_DEDICATED_2TIMER_Pos (1UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_DEDICATED_2TIMER (Bit 1) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_DEDICATED_2TIMER_Msk (0x6UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_LOAD_VALUE_Pos (4UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_LOAD_VALUE (Bit 4) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_LOAD_VALUE_Msk (0x10UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_LOAD_VALUE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_ENABLE_Pos (3UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_ENABLE (Bit 3) */
#define USER_TIMERS_COMPARE0_COMPARE_CTRL_USER_TIMER_COMPARE0_COMPARE_CTRL_ENABLE_Msk (0x8UL) /*!< USER_TIMER_COMPARE0_COMPARE_CTRL_ENABLE (Bitfield-Mask: 0x01) */
/* ================================================  COMPARE0_COUNTER_START  ================================================= */
#define USER_TIMERS_COMPARE0_COUNTER_START_COMPARE0_COUNTER_START_Pos (0UL) /*!< COMPARE0_COUNTER_START (Bit 0)                */
#define USER_TIMERS_COMPARE0_COUNTER_START_COMPARE0_COUNTER_START_Msk (0xffffUL) /*!< COMPARE0_COUNTER_START (Bitfield-Mask: 0xffff) */
/* =================================================  COMPARE0_COUNTER_STOP  ================================================= */
#define USER_TIMERS_COMPARE0_COUNTER_STOP_COMPARE0_COUNTER_STOP_Pos (0UL) /*!< COMPARE0_COUNTER_STOP (Bit 0)                   */
#define USER_TIMERS_COMPARE0_COUNTER_STOP_COMPARE0_COUNTER_STOP_Msk (0xffffUL) /*!< COMPARE0_COUNTER_STOP (Bitfield-Mask: 0xffff) */
/* ===============================================  COMPARE0_PRESCALER_START  ================================================ */
#define USER_TIMERS_COMPARE0_PRESCALER_START_COMPARE0_PRESCALER_START_Pos (0UL) /*!< COMPARE0_PRESCALER_START (Bit 0)          */
#define USER_TIMERS_COMPARE0_PRESCALER_START_COMPARE0_PRESCALER_START_Msk (0xffffUL) /*!< COMPARE0_PRESCALER_START (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE0_PRESCALER_STOP  ================================================ */
#define USER_TIMERS_COMPARE0_PRESCALER_STOP_COMPARE0_PRESCALER_STOP_Pos (0UL) /*!< COMPARE0_PRESCALER_STOP (Bit 0)             */
#define USER_TIMERS_COMPARE0_PRESCALER_STOP_COMPARE0_PRESCALER_STOP_Msk (0xffffUL) /*!< COMPARE0_PRESCALER_STOP (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE0_CYCLE_COMPARE  ================================================= */
#define USER_TIMERS_COMPARE0_CYCLE_COMPARE_COMPARE0_CYCLE_COMPARE_Pos (0UL) /*!< COMPARE0_CYCLE_COMPARE (Bit 0)                */
#define USER_TIMERS_COMPARE0_CYCLE_COMPARE_COMPARE0_CYCLE_COMPARE_Msk (0xffUL) /*!< COMPARE0_CYCLE_COMPARE (Bitfield-Mask: 0xff) */
/* =================================================  COMPARE1_COMPARE_CTRL  ================================================= */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_SELECT_POLARITY_Pos (0UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_SELECT_POLARITY (Bit 0) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_SELECT_POLARITY_Msk (0x1UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_SELECT_POLARITY (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_DEDICATED_2TIMER_Pos (1UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_DEDICATED_2TIMER (Bit 1) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_DEDICATED_2TIMER_Msk (0x6UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_LOAD_VALUE_Pos (4UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_LOAD_VALUE (Bit 4) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_LOAD_VALUE_Msk (0x10UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_LOAD_VALUE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_ENABLE_Pos (3UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_ENABLE (Bit 3) */
#define USER_TIMERS_COMPARE1_COMPARE_CTRL_USER_TIMER_COMPARE1_COMPARE_CTRL_ENABLE_Msk (0x8UL) /*!< USER_TIMER_COMPARE1_COMPARE_CTRL_ENABLE (Bitfield-Mask: 0x01) */
/* ================================================  COMPARE1_COUNTER_START  ================================================= */
#define USER_TIMERS_COMPARE1_COUNTER_START_COMPARE1_COUNTER_START_Pos (0UL) /*!< COMPARE1_COUNTER_START (Bit 0)                */
#define USER_TIMERS_COMPARE1_COUNTER_START_COMPARE1_COUNTER_START_Msk (0xffffUL) /*!< COMPARE1_COUNTER_START (Bitfield-Mask: 0xffff) */
/* =================================================  COMPARE1_COUNTER_STOP  ================================================= */
#define USER_TIMERS_COMPARE1_COUNTER_STOP_COMPARE1_COUNTER_STOP_Pos (0UL) /*!< COMPARE1_COUNTER_STOP (Bit 0)                   */
#define USER_TIMERS_COMPARE1_COUNTER_STOP_COMPARE1_COUNTER_STOP_Msk (0xffffUL) /*!< COMPARE1_COUNTER_STOP (Bitfield-Mask: 0xffff) */
/* ===============================================  COMPARE1_PRESCALER_START  ================================================ */
#define USER_TIMERS_COMPARE1_PRESCALER_START_COMPARE1_PRESCALER_START_Pos (0UL) /*!< COMPARE1_PRESCALER_START (Bit 0)          */
#define USER_TIMERS_COMPARE1_PRESCALER_START_COMPARE1_PRESCALER_START_Msk (0xffffUL) /*!< COMPARE1_PRESCALER_START (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE1_PRESCALER_STOP  ================================================ */
#define USER_TIMERS_COMPARE1_PRESCALER_STOP_COMPARE1_PRESCALER_STOP_Pos (0UL) /*!< COMPARE1_PRESCALER_STOP (Bit 0)             */
#define USER_TIMERS_COMPARE1_PRESCALER_STOP_COMPARE1_PRESCALER_STOP_Msk (0xffffUL) /*!< COMPARE1_PRESCALER_STOP (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE1_CYCLE_COMPARE  ================================================= */
#define USER_TIMERS_COMPARE1_CYCLE_COMPARE_COMPARE1_CYCLE_COMPARE_Pos (0UL) /*!< COMPARE1_CYCLE_COMPARE (Bit 0)                */
#define USER_TIMERS_COMPARE1_CYCLE_COMPARE_COMPARE1_CYCLE_COMPARE_Msk (0xffUL) /*!< COMPARE1_CYCLE_COMPARE (Bitfield-Mask: 0xff) */
/* =================================================  COMPARE2_COMPARE_CTRL  ================================================= */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_SELECT_POLARITY_Pos (0UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_SELECT_POLARITY (Bit 0) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_SELECT_POLARITY_Msk (0x1UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_SELECT_POLARITY (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_DEDICATED_2TIMER_Pos (1UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_DEDICATED_2TIMER (Bit 1) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_DEDICATED_2TIMER_Msk (0x6UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_LOAD_VALUE_Pos (4UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_LOAD_VALUE (Bit 4) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_LOAD_VALUE_Msk (0x10UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_LOAD_VALUE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_ENABLE_Pos (3UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_ENABLE (Bit 3) */
#define USER_TIMERS_COMPARE2_COMPARE_CTRL_USER_TIMER_COMPARE2_COMPARE_CTRL_ENABLE_Msk (0x8UL) /*!< USER_TIMER_COMPARE2_COMPARE_CTRL_ENABLE (Bitfield-Mask: 0x01) */
/* ================================================  COMPARE2_COUNTER_START  ================================================= */
#define USER_TIMERS_COMPARE2_COUNTER_START_COMPARE2_COUNTER_START_Pos (0UL) /*!< COMPARE2_COUNTER_START (Bit 0)                */
#define USER_TIMERS_COMPARE2_COUNTER_START_COMPARE2_COUNTER_START_Msk (0xffffUL) /*!< COMPARE2_COUNTER_START (Bitfield-Mask: 0xffff) */
/* =================================================  COMPARE2_COUNTER_STOP  ================================================= */
#define USER_TIMERS_COMPARE2_COUNTER_STOP_COMPARE2_COUNTER_STOP_Pos (0UL) /*!< COMPARE2_COUNTER_STOP (Bit 0)                   */
#define USER_TIMERS_COMPARE2_COUNTER_STOP_COMPARE2_COUNTER_STOP_Msk (0xffffUL) /*!< COMPARE2_COUNTER_STOP (Bitfield-Mask: 0xffff) */
/* ===============================================  COMPARE2_PRESCALER_START  ================================================ */
#define USER_TIMERS_COMPARE2_PRESCALER_START_COMPARE2_PRESCALER_START_Pos (0UL) /*!< COMPARE2_PRESCALER_START (Bit 0)          */
#define USER_TIMERS_COMPARE2_PRESCALER_START_COMPARE2_PRESCALER_START_Msk (0xffffUL) /*!< COMPARE2_PRESCALER_START (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE2_PRESCALER_STOP  ================================================ */
#define USER_TIMERS_COMPARE2_PRESCALER_STOP_COMPARE2_PRESCALER_STOP_Pos (0UL) /*!< COMPARE2_PRESCALER_STOP (Bit 0)             */
#define USER_TIMERS_COMPARE2_PRESCALER_STOP_COMPARE2_PRESCALER_STOP_Msk (0xffffUL) /*!< COMPARE2_PRESCALER_STOP (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE2_CYCLE_COMPARE  ================================================= */
#define USER_TIMERS_COMPARE2_CYCLE_COMPARE_COMPARE2_CYCLE_COMPARE_Pos (0UL) /*!< COMPARE2_CYCLE_COMPARE (Bit 0)                */
#define USER_TIMERS_COMPARE2_CYCLE_COMPARE_COMPARE2_CYCLE_COMPARE_Msk (0xffUL) /*!< COMPARE2_CYCLE_COMPARE (Bitfield-Mask: 0xff) */
/* =================================================  COMPARE3_COMPARE_CTRL  ================================================= */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_SELECT_POLARITY_Pos (0UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_SELECT_POLARITY (Bit 0) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_SELECT_POLARITY_Msk (0x1UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_SELECT_POLARITY (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_DEDICATED_2TIMER_Pos (1UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_DEDICATED_2TIMER (Bit 1) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_DEDICATED_2TIMER_Msk (0x6UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_LOAD_VALUE_Pos (4UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_LOAD_VALUE (Bit 4) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_LOAD_VALUE_Msk (0x10UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_LOAD_VALUE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_ENABLE_Pos (3UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_ENABLE (Bit 3) */
#define USER_TIMERS_COMPARE3_COMPARE_CTRL_USER_TIMER_COMPARE3_COMPARE_CTRL_ENABLE_Msk (0x8UL) /*!< USER_TIMER_COMPARE3_COMPARE_CTRL_ENABLE (Bitfield-Mask: 0x01) */
/* ================================================  COMPARE3_COUNTER_START  ================================================= */
#define USER_TIMERS_COMPARE3_COUNTER_START_COMPARE3_COUNTER_START_Pos (0UL) /*!< COMPARE3_COUNTER_START (Bit 0)                */
#define USER_TIMERS_COMPARE3_COUNTER_START_COMPARE3_COUNTER_START_Msk (0xffffUL) /*!< COMPARE3_COUNTER_START (Bitfield-Mask: 0xffff) */
/* =================================================  COMPARE3_COUNTER_STOP  ================================================= */
#define USER_TIMERS_COMPARE3_COUNTER_STOP_COMPARE3_COUNTER_STOP_Pos (0UL) /*!< COMPARE3_COUNTER_STOP (Bit 0)                   */
#define USER_TIMERS_COMPARE3_COUNTER_STOP_COMPARE3_COUNTER_STOP_Msk (0xffffUL) /*!< COMPARE3_COUNTER_STOP (Bitfield-Mask: 0xffff) */
/* ===============================================  COMPARE3_PRESCALER_START  ================================================ */
#define USER_TIMERS_COMPARE3_PRESCALER_START_COMPARE3_PRESCALER_START_Pos (0UL) /*!< COMPARE3_PRESCALER_START (Bit 0)          */
#define USER_TIMERS_COMPARE3_PRESCALER_START_COMPARE3_PRESCALER_START_Msk (0xffffUL) /*!< COMPARE3_PRESCALER_START (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE3_PRESCALER_STOP  ================================================ */
#define USER_TIMERS_COMPARE3_PRESCALER_STOP_COMPARE3_PRESCALER_STOP_Pos (0UL) /*!< COMPARE3_PRESCALER_STOP (Bit 0)             */
#define USER_TIMERS_COMPARE3_PRESCALER_STOP_COMPARE3_PRESCALER_STOP_Msk (0xffffUL) /*!< COMPARE3_PRESCALER_STOP (Bitfield-Mask: 0xffff) */
/* ================================================  COMPARE3_CYCLE_COMPARE  ================================================= */
#define USER_TIMERS_COMPARE3_CYCLE_COMPARE_COMPARE3_CYCLE_COMPARE_Pos (0UL) /*!< COMPARE3_CYCLE_COMPARE (Bit 0)                */
#define USER_TIMERS_COMPARE3_CYCLE_COMPARE_COMPARE3_CYCLE_COMPARE_Msk (0xffUL) /*!< COMPARE3_CYCLE_COMPARE (Bitfield-Mask: 0xff) */
/* =======================================================  CRT_VALUE  ======================================================= */
#define USER_TIMERS_CRT_VALUE_CRT_VALUE_Pos (0UL)                   /*!< CRT_VALUE (Bit 0)                                     */
#define USER_TIMERS_CRT_VALUE_CRT_VALUE_Msk (0xffUL)                /*!< CRT_VALUE (Bitfield-Mask: 0xff)                       */
/* ======================================================  CRT_CONTROL  ====================================================== */
#define USER_TIMERS_CRT_CONTROL_USER_TIMER_CRT_CONTROL_DEDICATED_TIMER_Pos (8UL) /*!< USER_TIMER_CRT_CONTROL_DEDICATED_TIMER (Bit 8) */
#define USER_TIMERS_CRT_CONTROL_USER_TIMER_CRT_CONTROL_DEDICATED_TIMER_Msk (0x300UL) /*!< USER_TIMER_CRT_CONTROL_DEDICATED_TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CRT_CONTROL_USER_TIMER_CRT_CONTROL_OUTPUT_SELECT_Pos (16UL) /*!< USER_TIMER_CRT_CONTROL_OUTPUT_SELECT (Bit 16) */
#define USER_TIMERS_CRT_CONTROL_USER_TIMER_CRT_CONTROL_OUTPUT_SELECT_Msk (0xf0000UL) /*!< USER_TIMER_CRT_CONTROL_OUTPUT_SELECT (Bitfield-Mask: 0x0f) */
/* =====================================================  CAPTURE0_CTRL  ===================================================== */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_SELECT_DATA_Pos (0UL) /*!< USER_TIMER_CAPTURE0_CTRL_SELECT_DATA (Bit 0) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_SELECT_DATA_Msk (0x3UL) /*!< USER_TIMER_CAPTURE0_CTRL_SELECT_DATA (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_DEDICATED_2TIMER_Pos (8UL) /*!< USER_TIMER_CAPTURE0_CTRL_DEDICATED_2TIMER (Bit 8) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_DEDICATED_2TIMER_Msk (0x300UL) /*!< USER_TIMER_CAPTURE0_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_STOP_CONDITION_Pos (16UL) /*!< USER_TIMER_CAPTURE0_CTRL_STOP_CONDITION (Bit 16) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_STOP_CONDITION_Msk (0x10000UL) /*!< USER_TIMER_CAPTURE0_CTRL_STOP_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_TIMEOUT_Pos (17UL) /*!< USER_TIMER_CAPTURE0_CTRL_TIMEOUT (Bit 17)   */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_TIMEOUT_Msk (0x20000UL) /*!< USER_TIMER_CAPTURE0_CTRL_TIMEOUT (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_MODE_Pos (18UL) /*!< USER_TIMER_CAPTURE0_CTRL_MODE (Bit 18)         */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_MODE_Msk (0x40000UL) /*!< USER_TIMER_CAPTURE0_CTRL_MODE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_START_RF_EDGE_Pos (19UL) /*!< USER_TIMER_CAPTURE0_CTRL_START_RF_EDGE (Bit 19) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_START_RF_EDGE_Msk (0x80000UL) /*!< USER_TIMER_CAPTURE0_CTRL_START_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_STOP_RF_EDGE_Pos (20UL) /*!< USER_TIMER_CAPTURE0_CTRL_STOP_RF_EDGE (Bit 20) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_STOP_RF_EDGE_Msk (0x100000UL) /*!< USER_TIMER_CAPTURE0_CTRL_STOP_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ENABLE_Pos (21UL) /*!< USER_TIMER_CAPTURE0_CTRL_ENABLE (Bit 21)     */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ENABLE_Msk (0x200000UL) /*!< USER_TIMER_CAPTURE0_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_CONDITION_Pos (22UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_CONDITION (Bit 22) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_CONDITION_Msk (0x400000UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_CONDITION_Pos (23UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_CONDITION (Bit 23) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_CONDITION_Msk (0x1800000UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_CONDITION (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_OPERATOR_Pos (25UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_OPERATOR (Bit 25) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_OPERATOR_Msk (0x2000000UL) /*!< USER_TIMER_CAPTURE0_CTRL_ALARM_PRESCALER_OPERATOR (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_CAPTURE_UNIT_REINIT_Pos (26UL) /*!< USER_TIMER_CAPTURE0_CTRL_CAPTURE_UNIT_REINIT (Bit 26) */
#define USER_TIMERS_CAPTURE0_CTRL_USER_TIMER_CAPTURE0_CTRL_CAPTURE_UNIT_REINIT_Msk (0x4000000UL) /*!< USER_TIMER_CAPTURE0_CTRL_CAPTURE_UNIT_REINIT (Bitfield-Mask: 0x01) */
/* ================================================  CAPTURE0_TIMEOUT_DELAY  ================================================= */
#define USER_TIMERS_CAPTURE0_TIMEOUT_DELAY_CAPTURE0_TIMEOUT_DELAY_Pos (0UL) /*!< CAPTURE0_TIMEOUT_DELAY (Bit 0)                */
#define USER_TIMERS_CAPTURE0_TIMEOUT_DELAY_CAPTURE0_TIMEOUT_DELAY_Msk (0xffffffffUL) /*!< CAPTURE0_TIMEOUT_DELAY (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE0_STOP_N_OCCURRENCE  =============================================== */
#define USER_TIMERS_CAPTURE0_STOP_N_OCCURRENCE_CAPTURE0_STOP_N_OCCURRENCE_Pos (0UL) /*!< CAPTURE0_STOP_N_OCCURRENCE (Bit 0)    */
#define USER_TIMERS_CAPTURE0_STOP_N_OCCURRENCE_CAPTURE0_STOP_N_OCCURRENCE_Msk (0xffffUL) /*!< CAPTURE0_STOP_N_OCCURRENCE (Bitfield-Mask: 0xffff) */
/* ==============================================  CAPTURE0_START_TIME_CAPTURE  ============================================== */
#define USER_TIMERS_CAPTURE0_START_TIME_CAPTURE_CAPTURE0_START_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE0_START_TIME_CAPTURE (Bit 0) */
#define USER_TIMERS_CAPTURE0_START_TIME_CAPTURE_CAPTURE0_START_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE0_START_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE0_STOP_TIME_CAPTURE  =============================================== */
#define USER_TIMERS_CAPTURE0_STOP_TIME_CAPTURE_CAPTURE0_STOP_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE0_STOP_TIME_CAPTURE (Bit 0)    */
#define USER_TIMERS_CAPTURE0_STOP_TIME_CAPTURE_CAPTURE0_STOP_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE0_STOP_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ===============================================  CAPTURE0_ALARM_THRESHOLD  ================================================ */
#define USER_TIMERS_CAPTURE0_ALARM_THRESHOLD_CAPTURE0_ALARM_THRESHOLD_Pos (0UL) /*!< CAPTURE0_ALARM_THRESHOLD (Bit 0)          */
#define USER_TIMERS_CAPTURE0_ALARM_THRESHOLD_CAPTURE0_ALARM_THRESHOLD_Msk (0xffffffffUL) /*!< CAPTURE0_ALARM_THRESHOLD (Bitfield-Mask: 0xffffffff) */
/* =====================================================  CAPTURE1_CTRL  ===================================================== */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_SELECT_DATA_Pos (0UL) /*!< USER_TIMER_CAPTURE1_CTRL_SELECT_DATA (Bit 0) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_SELECT_DATA_Msk (0x3UL) /*!< USER_TIMER_CAPTURE1_CTRL_SELECT_DATA (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_DEDICATED_2TIMER_Pos (8UL) /*!< USER_TIMER_CAPTURE1_CTRL_DEDICATED_2TIMER (Bit 8) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_DEDICATED_2TIMER_Msk (0x300UL) /*!< USER_TIMER_CAPTURE1_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_STOP_CONDITION_Pos (16UL) /*!< USER_TIMER_CAPTURE1_CTRL_STOP_CONDITION (Bit 16) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_STOP_CONDITION_Msk (0x10000UL) /*!< USER_TIMER_CAPTURE1_CTRL_STOP_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_TIMEOUT_Pos (17UL) /*!< USER_TIMER_CAPTURE1_CTRL_TIMEOUT (Bit 17)   */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_TIMEOUT_Msk (0x20000UL) /*!< USER_TIMER_CAPTURE1_CTRL_TIMEOUT (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_MODE_Pos (18UL) /*!< USER_TIMER_CAPTURE1_CTRL_MODE (Bit 18)         */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_MODE_Msk (0x40000UL) /*!< USER_TIMER_CAPTURE1_CTRL_MODE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_START_RF_EDGE_Pos (19UL) /*!< USER_TIMER_CAPTURE1_CTRL_START_RF_EDGE (Bit 19) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_START_RF_EDGE_Msk (0x80000UL) /*!< USER_TIMER_CAPTURE1_CTRL_START_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_STOP_RF_EDGE_Pos (20UL) /*!< USER_TIMER_CAPTURE1_CTRL_STOP_RF_EDGE (Bit 20) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_STOP_RF_EDGE_Msk (0x100000UL) /*!< USER_TIMER_CAPTURE1_CTRL_STOP_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ENABLE_Pos (21UL) /*!< USER_TIMER_CAPTURE1_CTRL_ENABLE (Bit 21)     */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ENABLE_Msk (0x200000UL) /*!< USER_TIMER_CAPTURE1_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_CONDITION_Pos (22UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_CONDITION (Bit 22) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_CONDITION_Msk (0x400000UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_CONDITION_Pos (23UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_CONDITION (Bit 23) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_CONDITION_Msk (0x1800000UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_CONDITION (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_OPERATOR_Pos (25UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_OPERATOR (Bit 25) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_OPERATOR_Msk (0x2000000UL) /*!< USER_TIMER_CAPTURE1_CTRL_ALARM_PRESCALER_OPERATOR (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_CAPTURE_UNIT_REINIT_Pos (26UL) /*!< USER_TIMER_CAPTURE1_CTRL_CAPTURE_UNIT_REINIT (Bit 26) */
#define USER_TIMERS_CAPTURE1_CTRL_USER_TIMER_CAPTURE1_CTRL_CAPTURE_UNIT_REINIT_Msk (0x4000000UL) /*!< USER_TIMER_CAPTURE1_CTRL_CAPTURE_UNIT_REINIT (Bitfield-Mask: 0x01) */
/* ================================================  CAPTURE1_TIMEOUT_DELAY  ================================================= */
#define USER_TIMERS_CAPTURE1_TIMEOUT_DELAY_CAPTURE1_TIMEOUT_DELAY_Pos (0UL) /*!< CAPTURE1_TIMEOUT_DELAY (Bit 0)                */
#define USER_TIMERS_CAPTURE1_TIMEOUT_DELAY_CAPTURE1_TIMEOUT_DELAY_Msk (0xffffffffUL) /*!< CAPTURE1_TIMEOUT_DELAY (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE1_STOP_N_OCCURRENCE  =============================================== */
#define USER_TIMERS_CAPTURE1_STOP_N_OCCURRENCE_CAPTURE1_STOP_N_OCCURRENCE_Pos (0UL) /*!< CAPTURE1_STOP_N_OCCURRENCE (Bit 0)    */
#define USER_TIMERS_CAPTURE1_STOP_N_OCCURRENCE_CAPTURE1_STOP_N_OCCURRENCE_Msk (0xffffUL) /*!< CAPTURE1_STOP_N_OCCURRENCE (Bitfield-Mask: 0xffff) */
/* ==============================================  CAPTURE1_START_TIME_CAPTURE  ============================================== */
#define USER_TIMERS_CAPTURE1_START_TIME_CAPTURE_CAPTURE1_START_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE1_START_TIME_CAPTURE (Bit 0) */
#define USER_TIMERS_CAPTURE1_START_TIME_CAPTURE_CAPTURE1_START_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE1_START_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE1_STOP_TIME_CAPTURE  =============================================== */
#define USER_TIMERS_CAPTURE1_STOP_TIME_CAPTURE_CAPTURE1_STOP_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE1_STOP_TIME_CAPTURE (Bit 0)    */
#define USER_TIMERS_CAPTURE1_STOP_TIME_CAPTURE_CAPTURE1_STOP_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE1_STOP_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ===============================================  CAPTURE1_ALARM_THRESHOLD  ================================================ */
#define USER_TIMERS_CAPTURE1_ALARM_THRESHOLD_CAPTURE1_ALARM_THRESHOLD_Pos (0UL) /*!< CAPTURE1_ALARM_THRESHOLD (Bit 0)          */
#define USER_TIMERS_CAPTURE1_ALARM_THRESHOLD_CAPTURE1_ALARM_THRESHOLD_Msk (0xffffffffUL) /*!< CAPTURE1_ALARM_THRESHOLD (Bitfield-Mask: 0xffffffff) */
/* =====================================================  CAPTURE2_CTRL  ===================================================== */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_SELECT_DATA_Pos (0UL) /*!< USER_TIMER_CAPTURE2_CTRL_SELECT_DATA (Bit 0) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_SELECT_DATA_Msk (0x3UL) /*!< USER_TIMER_CAPTURE2_CTRL_SELECT_DATA (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_DEDICATED_2TIMER_Pos (8UL) /*!< USER_TIMER_CAPTURE2_CTRL_DEDICATED_2TIMER (Bit 8) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_DEDICATED_2TIMER_Msk (0x300UL) /*!< USER_TIMER_CAPTURE2_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_STOP_CONDITION_Pos (16UL) /*!< USER_TIMER_CAPTURE2_CTRL_STOP_CONDITION (Bit 16) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_STOP_CONDITION_Msk (0x10000UL) /*!< USER_TIMER_CAPTURE2_CTRL_STOP_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_TIMEOUT_Pos (17UL) /*!< USER_TIMER_CAPTURE2_CTRL_TIMEOUT (Bit 17)   */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_TIMEOUT_Msk (0x20000UL) /*!< USER_TIMER_CAPTURE2_CTRL_TIMEOUT (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_MODE_Pos (18UL) /*!< USER_TIMER_CAPTURE2_CTRL_MODE (Bit 18)         */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_MODE_Msk (0x40000UL) /*!< USER_TIMER_CAPTURE2_CTRL_MODE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_START_RF_EDGE_Pos (19UL) /*!< USER_TIMER_CAPTURE2_CTRL_START_RF_EDGE (Bit 19) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_START_RF_EDGE_Msk (0x80000UL) /*!< USER_TIMER_CAPTURE2_CTRL_START_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_STOP_RF_EDGE_Pos (20UL) /*!< USER_TIMER_CAPTURE2_CTRL_STOP_RF_EDGE (Bit 20) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_STOP_RF_EDGE_Msk (0x100000UL) /*!< USER_TIMER_CAPTURE2_CTRL_STOP_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ENABLE_Pos (21UL) /*!< USER_TIMER_CAPTURE2_CTRL_ENABLE (Bit 21)     */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ENABLE_Msk (0x200000UL) /*!< USER_TIMER_CAPTURE2_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_CONDITION_Pos (22UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_CONDITION (Bit 22) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_CONDITION_Msk (0x400000UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_CONDITION_Pos (23UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_CONDITION (Bit 23) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_CONDITION_Msk (0x1800000UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_CONDITION (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_OPERATOR_Pos (25UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_OPERATOR (Bit 25) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_OPERATOR_Msk (0x2000000UL) /*!< USER_TIMER_CAPTURE2_CTRL_ALARM_PRESCALER_OPERATOR (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_CAPTURE_UNIT_REINIT_Pos (26UL) /*!< USER_TIMER_CAPTURE2_CTRL_CAPTURE_UNIT_REINIT (Bit 26) */
#define USER_TIMERS_CAPTURE2_CTRL_USER_TIMER_CAPTURE2_CTRL_CAPTURE_UNIT_REINIT_Msk (0x4000000UL) /*!< USER_TIMER_CAPTURE2_CTRL_CAPTURE_UNIT_REINIT (Bitfield-Mask: 0x01) */
/* ================================================  CAPTURE2_TIMEOUT_DELAY  ================================================= */
#define USER_TIMERS_CAPTURE2_TIMEOUT_DELAY_CAPTURE2_TIMEOUT_DELAY_Pos (0UL) /*!< CAPTURE2_TIMEOUT_DELAY (Bit 0)                */
#define USER_TIMERS_CAPTURE2_TIMEOUT_DELAY_CAPTURE2_TIMEOUT_DELAY_Msk (0xffffffffUL) /*!< CAPTURE2_TIMEOUT_DELAY (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE2_STOP_N_OCCURRENCE  =============================================== */
#define USER_TIMERS_CAPTURE2_STOP_N_OCCURRENCE_CAPTURE2_STOP_N_OCCURRENCE_Pos (0UL) /*!< CAPTURE2_STOP_N_OCCURRENCE (Bit 0)    */
#define USER_TIMERS_CAPTURE2_STOP_N_OCCURRENCE_CAPTURE2_STOP_N_OCCURRENCE_Msk (0xffffUL) /*!< CAPTURE2_STOP_N_OCCURRENCE (Bitfield-Mask: 0xffff) */
/* ==============================================  CAPTURE2_START_TIME_CAPTURE  ============================================== */
#define USER_TIMERS_CAPTURE2_START_TIME_CAPTURE_CAPTURE2_START_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE2_START_TIME_CAPTURE (Bit 0) */
#define USER_TIMERS_CAPTURE2_START_TIME_CAPTURE_CAPTURE2_START_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE2_START_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE2_STOP_TIME_CAPTURE  =============================================== */
#define USER_TIMERS_CAPTURE2_STOP_TIME_CAPTURE_CAPTURE2_STOP_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE2_STOP_TIME_CAPTURE (Bit 0)    */
#define USER_TIMERS_CAPTURE2_STOP_TIME_CAPTURE_CAPTURE2_STOP_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE2_STOP_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ===============================================  CAPTURE2_ALARM_THRESHOLD  ================================================ */
#define USER_TIMERS_CAPTURE2_ALARM_THRESHOLD_CAPTURE2_ALARM_THRESHOLD_Pos (0UL) /*!< CAPTURE2_ALARM_THRESHOLD (Bit 0)          */
#define USER_TIMERS_CAPTURE2_ALARM_THRESHOLD_CAPTURE2_ALARM_THRESHOLD_Msk (0xffffffffUL) /*!< CAPTURE2_ALARM_THRESHOLD (Bitfield-Mask: 0xffffffff) */
/* =====================================================  CAPTURE3_CTRL  ===================================================== */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_SELECT_DATA_Pos (0UL) /*!< USER_TIMER_CAPTURE3_CTRL_SELECT_DATA (Bit 0) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_SELECT_DATA_Msk (0x3UL) /*!< USER_TIMER_CAPTURE3_CTRL_SELECT_DATA (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_DEDICATED_2TIMER_Pos (8UL) /*!< USER_TIMER_CAPTURE3_CTRL_DEDICATED_2TIMER (Bit 8) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_DEDICATED_2TIMER_Msk (0x300UL) /*!< USER_TIMER_CAPTURE3_CTRL_DEDICATED_2TIMER (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_STOP_CONDITION_Pos (16UL) /*!< USER_TIMER_CAPTURE3_CTRL_STOP_CONDITION (Bit 16) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_STOP_CONDITION_Msk (0x10000UL) /*!< USER_TIMER_CAPTURE3_CTRL_STOP_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_TIMEOUT_Pos (17UL) /*!< USER_TIMER_CAPTURE3_CTRL_TIMEOUT (Bit 17)   */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_TIMEOUT_Msk (0x20000UL) /*!< USER_TIMER_CAPTURE3_CTRL_TIMEOUT (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_MODE_Pos (18UL) /*!< USER_TIMER_CAPTURE3_CTRL_MODE (Bit 18)         */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_MODE_Msk (0x40000UL) /*!< USER_TIMER_CAPTURE3_CTRL_MODE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_START_RF_EDGE_Pos (19UL) /*!< USER_TIMER_CAPTURE3_CTRL_START_RF_EDGE (Bit 19) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_START_RF_EDGE_Msk (0x80000UL) /*!< USER_TIMER_CAPTURE3_CTRL_START_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_STOP_RF_EDGE_Pos (20UL) /*!< USER_TIMER_CAPTURE3_CTRL_STOP_RF_EDGE (Bit 20) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_STOP_RF_EDGE_Msk (0x100000UL) /*!< USER_TIMER_CAPTURE3_CTRL_STOP_RF_EDGE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ENABLE_Pos (21UL) /*!< USER_TIMER_CAPTURE3_CTRL_ENABLE (Bit 21)     */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ENABLE_Msk (0x200000UL) /*!< USER_TIMER_CAPTURE3_CTRL_ENABLE (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_CONDITION_Pos (22UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_CONDITION (Bit 22) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_CONDITION_Msk (0x400000UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_CONDITION (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_CONDITION_Pos (23UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_CONDITION (Bit 23) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_CONDITION_Msk (0x1800000UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_CONDITION (Bitfield-Mask: 0x03) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_OPERATOR_Pos (25UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_OPERATOR (Bit 25) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_OPERATOR_Msk (0x2000000UL) /*!< USER_TIMER_CAPTURE3_CTRL_ALARM_PRESCALER_OPERATOR (Bitfield-Mask: 0x01) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_CAPTURE_UNIT_REINIT_Pos (26UL) /*!< USER_TIMER_CAPTURE3_CTRL_CAPTURE_UNIT_REINIT (Bit 26) */
#define USER_TIMERS_CAPTURE3_CTRL_USER_TIMER_CAPTURE3_CTRL_CAPTURE_UNIT_REINIT_Msk (0x4000000UL) /*!< USER_TIMER_CAPTURE3_CTRL_CAPTURE_UNIT_REINIT (Bitfield-Mask: 0x01) */
/* ================================================  CAPTURE3_TIMEOUT_DELAY  ================================================= */
#define USER_TIMERS_CAPTURE3_TIMEOUT_DELAY_CAPTURE3_TIMEOUT_DELAY_Pos (0UL) /*!< CAPTURE3_TIMEOUT_DELAY (Bit 0)                */
#define USER_TIMERS_CAPTURE3_TIMEOUT_DELAY_CAPTURE3_TIMEOUT_DELAY_Msk (0xffffffffUL) /*!< CAPTURE3_TIMEOUT_DELAY (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE3_STOP_N_OCCURRENCE  =============================================== */
#define USER_TIMERS_CAPTURE3_STOP_N_OCCURRENCE_CAPTURE3_STOP_N_OCCURRENCE_Pos (0UL) /*!< CAPTURE3_STOP_N_OCCURRENCE (Bit 0)    */
#define USER_TIMERS_CAPTURE3_STOP_N_OCCURRENCE_CAPTURE3_STOP_N_OCCURRENCE_Msk (0xffffUL) /*!< CAPTURE3_STOP_N_OCCURRENCE (Bitfield-Mask: 0xffff) */
/* ==============================================  CAPTURE3_START_TIME_CAPTURE  ============================================== */
#define USER_TIMERS_CAPTURE3_START_TIME_CAPTURE_CAPTURE3_START_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE3_START_TIME_CAPTURE (Bit 0) */
#define USER_TIMERS_CAPTURE3_START_TIME_CAPTURE_CAPTURE3_START_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE3_START_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ==============================================  CAPTURE3_STOP_TIME_CAPTURE  =============================================== */
#define USER_TIMERS_CAPTURE3_STOP_TIME_CAPTURE_CAPTURE3_STOP_TIME_CAPTURE_Pos (0UL) /*!< CAPTURE3_STOP_TIME_CAPTURE (Bit 0)    */
#define USER_TIMERS_CAPTURE3_STOP_TIME_CAPTURE_CAPTURE3_STOP_TIME_CAPTURE_Msk (0xffffffffUL) /*!< CAPTURE3_STOP_TIME_CAPTURE (Bitfield-Mask: 0xffffffff) */
/* ===============================================  CAPTURE3_ALARM_THRESHOLD  ================================================ */
#define USER_TIMERS_CAPTURE3_ALARM_THRESHOLD_CAPTURE3_ALARM_THRESHOLD_Pos (0UL) /*!< CAPTURE3_ALARM_THRESHOLD (Bit 0)          */
#define USER_TIMERS_CAPTURE3_ALARM_THRESHOLD_CAPTURE3_ALARM_THRESHOLD_Msk (0xffffffffUL) /*!< CAPTURE3_ALARM_THRESHOLD (Bitfield-Mask: 0xffffffff) */
/* ===============================================  TIMER0_INTERRUPT_CPU_MASK  =============================================== */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_MASK_TIMER0_INTERRUPT_CPU_MASK_Pos (0UL) /*!< TIMER0_INTERRUPT_CPU_MASK (Bit 0)       */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_MASK_TIMER0_INTERRUPT_CPU_MASK_Msk (0xfUL) /*!< TIMER0_INTERRUPT_CPU_MASK (Bitfield-Mask: 0x0f) */
/* ==============================================  TIMER0_INTERRUPT_CPU_STATUS  ============================================== */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_STATUS_TIMER0_INTERRUPT_CPU_STATUS_Pos (0UL) /*!< TIMER0_INTERRUPT_CPU_STATUS (Bit 0) */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_STATUS_TIMER0_INTERRUPT_CPU_STATUS_Msk (0xfUL) /*!< TIMER0_INTERRUPT_CPU_STATUS (Bitfield-Mask: 0x0f) */
/* ============================================  TIMER0_INTERRUPT_CPU_RAW_STATUS  ============================================ */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_RAW_STATUS_TIMER0_INTERRUPT_CPU_RAW_STATUS_Pos (0UL) /*!< TIMER0_INTERRUPT_CPU_RAW_STATUS (Bit 0) */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_RAW_STATUS_TIMER0_INTERRUPT_CPU_RAW_STATUS_Msk (0xfUL) /*!< TIMER0_INTERRUPT_CPU_RAW_STATUS (Bitfield-Mask: 0x0f) */
/* ===========================================  TIMER0_INTERRUPT_CPU_STATUS_CLEAR  =========================================== */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_STATUS_CLEAR_TIMER0_INTERRUPT_CPU_STATUS_CLEAR_Pos (0UL) /*!< TIMER0_INTERRUPT_CPU_STATUS_CLEAR (Bit 0) */
#define USER_TIMERS_TIMER0_INTERRUPT_CPU_STATUS_CLEAR_TIMER0_INTERRUPT_CPU_STATUS_CLEAR_Msk (0xfUL) /*!< TIMER0_INTERRUPT_CPU_STATUS_CLEAR (Bitfield-Mask: 0x0f) */
/* ===============================================  TIMER1_INTERRUPT_CPU_MASK  =============================================== */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_MASK_TIMER1_INTERRUPT_CPU_MASK_Pos (0UL) /*!< TIMER1_INTERRUPT_CPU_MASK (Bit 0)       */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_MASK_TIMER1_INTERRUPT_CPU_MASK_Msk (0xfUL) /*!< TIMER1_INTERRUPT_CPU_MASK (Bitfield-Mask: 0x0f) */
/* ==============================================  TIMER1_INTERRUPT_CPU_STATUS  ============================================== */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_STATUS_TIMER1_INTERRUPT_CPU_STATUS_Pos (0UL) /*!< TIMER1_INTERRUPT_CPU_STATUS (Bit 0) */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_STATUS_TIMER1_INTERRUPT_CPU_STATUS_Msk (0xfUL) /*!< TIMER1_INTERRUPT_CPU_STATUS (Bitfield-Mask: 0x0f) */
/* ============================================  TIMER1_INTERRUPT_CPU_RAW_STATUS  ============================================ */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_RAW_STATUS_TIMER1_INTERRUPT_CPU_RAW_STATUS_Pos (0UL) /*!< TIMER1_INTERRUPT_CPU_RAW_STATUS (Bit 0) */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_RAW_STATUS_TIMER1_INTERRUPT_CPU_RAW_STATUS_Msk (0xfUL) /*!< TIMER1_INTERRUPT_CPU_RAW_STATUS (Bitfield-Mask: 0x0f) */
/* ===========================================  TIMER1_INTERRUPT_CPU_STATUS_CLEAR  =========================================== */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_STATUS_CLEAR_TIMER1_INTERRUPT_CPU_STATUS_CLEAR_Pos (0UL) /*!< TIMER1_INTERRUPT_CPU_STATUS_CLEAR (Bit 0) */
#define USER_TIMERS_TIMER1_INTERRUPT_CPU_STATUS_CLEAR_TIMER1_INTERRUPT_CPU_STATUS_CLEAR_Msk (0xfUL) /*!< TIMER1_INTERRUPT_CPU_STATUS_CLEAR (Bitfield-Mask: 0x0f) */
/* ===============================================  TIMER2_INTERRUPT_CPU_MASK  =============================================== */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_MASK_TIMER2_INTERRUPT_CPU_MASK_Pos (0UL) /*!< TIMER2_INTERRUPT_CPU_MASK (Bit 0)       */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_MASK_TIMER2_INTERRUPT_CPU_MASK_Msk (0xfUL) /*!< TIMER2_INTERRUPT_CPU_MASK (Bitfield-Mask: 0x0f) */
/* ==============================================  TIMER2_INTERRUPT_CPU_STATUS  ============================================== */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_STATUS_TIMER2_INTERRUPT_CPU_STATUS_Pos (0UL) /*!< TIMER2_INTERRUPT_CPU_STATUS (Bit 0) */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_STATUS_TIMER2_INTERRUPT_CPU_STATUS_Msk (0xfUL) /*!< TIMER2_INTERRUPT_CPU_STATUS (Bitfield-Mask: 0x0f) */
/* ============================================  TIMER2_INTERRUPT_CPU_RAW_STATUS  ============================================ */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_RAW_STATUS_TIMER2_INTERRUPT_CPU_RAW_STATUS_Pos (0UL) /*!< TIMER2_INTERRUPT_CPU_RAW_STATUS (Bit 0) */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_RAW_STATUS_TIMER2_INTERRUPT_CPU_RAW_STATUS_Msk (0xfUL) /*!< TIMER2_INTERRUPT_CPU_RAW_STATUS (Bitfield-Mask: 0x0f) */
/* ===========================================  TIMER2_INTERRUPT_CPU_STATUS_CLEAR  =========================================== */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_STATUS_CLEAR_TIMER2_INTERRUPT_CPU_STATUS_CLEAR_Pos (0UL) /*!< TIMER2_INTERRUPT_CPU_STATUS_CLEAR (Bit 0) */
#define USER_TIMERS_TIMER2_INTERRUPT_CPU_STATUS_CLEAR_TIMER2_INTERRUPT_CPU_STATUS_CLEAR_Msk (0xfUL) /*!< TIMER2_INTERRUPT_CPU_STATUS_CLEAR (Bitfield-Mask: 0x0f) */
/* ===============================================  TIMER3_INTERRUPT_CPU_MASK  =============================================== */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_MASK_TIMER3_INTERRUPT_CPU_MASK_Pos (0UL) /*!< TIMER3_INTERRUPT_CPU_MASK (Bit 0)       */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_MASK_TIMER3_INTERRUPT_CPU_MASK_Msk (0xfUL) /*!< TIMER3_INTERRUPT_CPU_MASK (Bitfield-Mask: 0x0f) */
/* ==============================================  TIMER3_INTERRUPT_CPU_STATUS  ============================================== */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_STATUS_TIMER3_INTERRUPT_CPU_STATUS_Pos (0UL) /*!< TIMER3_INTERRUPT_CPU_STATUS (Bit 0) */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_STATUS_TIMER3_INTERRUPT_CPU_STATUS_Msk (0xfUL) /*!< TIMER3_INTERRUPT_CPU_STATUS (Bitfield-Mask: 0x0f) */
/* ============================================  TIMER3_INTERRUPT_CPU_RAW_STATUS  ============================================ */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_RAW_STATUS_TIMER3_INTERRUPT_CPU_RAW_STATUS_Pos (0UL) /*!< TIMER3_INTERRUPT_CPU_RAW_STATUS (Bit 0) */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_RAW_STATUS_TIMER3_INTERRUPT_CPU_RAW_STATUS_Msk (0xfUL) /*!< TIMER3_INTERRUPT_CPU_RAW_STATUS (Bitfield-Mask: 0x0f) */
/* ===========================================  TIMER3_INTERRUPT_CPU_STATUS_CLEAR  =========================================== */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_STATUS_CLEAR_TIMER3_INTERRUPT_CPU_STATUS_CLEAR_Pos (0UL) /*!< TIMER3_INTERRUPT_CPU_STATUS_CLEAR (Bit 0) */
#define USER_TIMERS_TIMER3_INTERRUPT_CPU_STATUS_CLEAR_TIMER3_INTERRUPT_CPU_STATUS_CLEAR_Msk (0xfUL) /*!< TIMER3_INTERRUPT_CPU_STATUS_CLEAR (Bitfield-Mask: 0x0f) */
/* =========================================================  SPARE  ========================================================= */
#define USER_TIMERS_SPARE_SPARE_Pos       (0UL)                     /*!< SPARE (Bit 0)                                         */
#define USER_TIMERS_SPARE_SPARE_Msk       (0xfUL)                   /*!< SPARE (Bitfield-Mask: 0x0f)                           */


/* =========================================================================================================================== */
/* ================                                            PCM                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  TIMING_CFG  ======================================================= */
#define PCM_TIMING_CFG_PCM_OUT_ON_RISING_Pos (29UL)                 /*!< PCM_OUT_ON_RISING (Bit 29)                            */
#define PCM_TIMING_CFG_PCM_OUT_ON_RISING_Msk (0x20000000UL)         /*!< PCM_OUT_ON_RISING (Bitfield-Mask: 0x01)               */
#define PCM_TIMING_CFG_PCM_IN_ON_RISING_Pos (28UL)                  /*!< PCM_IN_ON_RISING (Bit 28)                             */
#define PCM_TIMING_CFG_PCM_IN_ON_RISING_Msk (0x10000000UL)          /*!< PCM_IN_ON_RISING (Bitfield-Mask: 0x01)                */
#define PCM_TIMING_CFG_FS_ON_RISING_Pos   (27UL)                    /*!< FS_ON_RISING (Bit 27)                                 */
#define PCM_TIMING_CFG_FS_ON_RISING_Msk   (0x8000000UL)             /*!< FS_ON_RISING (Bitfield-Mask: 0x01)                    */
#define PCM_TIMING_CFG_FS2PCM_IN_PCLK_CYCLES_Pos (24UL)             /*!< FS2PCM_IN_PCLK_CYCLES (Bit 24)                        */
#define PCM_TIMING_CFG_FS2PCM_IN_PCLK_CYCLES_Msk (0x7000000UL)      /*!< FS2PCM_IN_PCLK_CYCLES (Bitfield-Mask: 0x07)           */
#define PCM_TIMING_CFG_FS2PCM_OUT_PCLK_CYCLES_Pos (21UL)            /*!< FS2PCM_OUT_PCLK_CYCLES (Bit 21)                       */
#define PCM_TIMING_CFG_FS2PCM_OUT_PCLK_CYCLES_Msk (0xe00000UL)      /*!< FS2PCM_OUT_PCLK_CYCLES (Bitfield-Mask: 0x07)          */
#define PCM_TIMING_CFG_PCLK2FS_FCLK_CYCLES_Pos (14UL)               /*!< PCLK2FS_FCLK_CYCLES (Bit 14)                          */
#define PCM_TIMING_CFG_PCLK2FS_FCLK_CYCLES_Msk (0x1fc000UL)         /*!< PCLK2FS_FCLK_CYCLES (Bitfield-Mask: 0x7f)             */
#define PCM_TIMING_CFG_PCLK2PCM_IN_FCLK_CYCLES_Pos (7UL)            /*!< PCLK2PCM_IN_FCLK_CYCLES (Bit 7)                       */
#define PCM_TIMING_CFG_PCLK2PCM_IN_FCLK_CYCLES_Msk (0x3f80UL)       /*!< PCLK2PCM_IN_FCLK_CYCLES (Bitfield-Mask: 0x7f)         */
#define PCM_TIMING_CFG_PCLK2PCM_OUT_FCLK_CYCLES_Pos (0UL)           /*!< PCLK2PCM_OUT_FCLK_CYCLES (Bit 0)                      */
#define PCM_TIMING_CFG_PCLK2PCM_OUT_FCLK_CYCLES_Msk (0x7fUL)        /*!< PCLK2PCM_OUT_FCLK_CYCLES (Bitfield-Mask: 0x7f)        */
/* ======================================================  GLOBAL_CFG  ======================================================= */
#define PCM_GLOBAL_CFG_FIFO_HALF_WORD_SWAP_Pos (29UL)               /*!< FIFO_HALF_WORD_SWAP (Bit 29)                          */
#define PCM_GLOBAL_CFG_FIFO_HALF_WORD_SWAP_Msk (0x20000000UL)       /*!< FIFO_HALF_WORD_SWAP (Bitfield-Mask: 0x01)             */
#define PCM_GLOBAL_CFG_FIFO_ACCESS_BIG_ENDIAN_Pos (27UL)            /*!< FIFO_ACCESS_BIG_ENDIAN (Bit 27)                       */
#define PCM_GLOBAL_CFG_FIFO_ACCESS_BIG_ENDIAN_Msk (0x8000000UL)     /*!< FIFO_ACCESS_BIG_ENDIAN (Bitfield-Mask: 0x01)          */
#define PCM_GLOBAL_CFG_FIFO_SINGLE_MODE_Pos (26UL)                  /*!< FIFO_SINGLE_MODE (Bit 26)                             */
#define PCM_GLOBAL_CFG_FIFO_SINGLE_MODE_Msk (0x4000000UL)           /*!< FIFO_SINGLE_MODE (Bitfield-Mask: 0x01)                */
#define PCM_GLOBAL_CFG_FIFO_ACCESS_WORD_Pos (25UL)                  /*!< FIFO_ACCESS_WORD (Bit 25)                             */
#define PCM_GLOBAL_CFG_FIFO_ACCESS_WORD_Msk (0x2000000UL)           /*!< FIFO_ACCESS_WORD (Bitfield-Mask: 0x01)                */
#define PCM_GLOBAL_CFG_I2S_FS_INV_Pos     (24UL)                    /*!< I2S_FS_INV (Bit 24)                                   */
#define PCM_GLOBAL_CFG_I2S_FS_INV_Msk     (0x1000000UL)             /*!< I2S_FS_INV (Bitfield-Mask: 0x01)                      */
#define PCM_GLOBAL_CFG_I2S_FS_MODE_Pos    (23UL)                    /*!< I2S_FS_MODE (Bit 23)                                  */
#define PCM_GLOBAL_CFG_I2S_FS_MODE_Msk    (0x800000UL)              /*!< I2S_FS_MODE (Bitfield-Mask: 0x01)                     */
#define PCM_GLOBAL_CFG_PCM_TS0_16BITS_Pos (22UL)                    /*!< PCM_TS0_16BITS (Bit 22)                               */
#define PCM_GLOBAL_CFG_PCM_TS0_16BITS_Msk (0x400000UL)              /*!< PCM_TS0_16BITS (Bitfield-Mask: 0x01)                  */
#define PCM_GLOBAL_CFG_PCM_TS1_16BITS_Pos (21UL)                    /*!< PCM_TS1_16BITS (Bit 21)                               */
#define PCM_GLOBAL_CFG_PCM_TS1_16BITS_Msk (0x200000UL)              /*!< PCM_TS1_16BITS (Bitfield-Mask: 0x01)                  */
#define PCM_GLOBAL_CFG_OCP_BYTE_ENABLE_Pos (19UL)                   /*!< OCP_BYTE_ENABLE (Bit 19)                              */
#define PCM_GLOBAL_CFG_OCP_BYTE_ENABLE_Msk (0x180000UL)             /*!< OCP_BYTE_ENABLE (Bitfield-Mask: 0x03)                 */
#define PCM_GLOBAL_CFG_NUM_OF_TS_Pos      (14UL)                    /*!< NUM_OF_TS (Bit 14)                                    */
#define PCM_GLOBAL_CFG_NUM_OF_TS_Msk      (0x7c000UL)               /*!< NUM_OF_TS (Bitfield-Mask: 0x1f)                       */
#define PCM_GLOBAL_CFG_TS1_DISABLE_Pos    (13UL)                    /*!< TS1_DISABLE (Bit 13)                                  */
#define PCM_GLOBAL_CFG_TS1_DISABLE_Msk    (0x2000UL)                /*!< TS1_DISABLE (Bitfield-Mask: 0x01)                     */
#define PCM_GLOBAL_CFG_PCM_IN_LSB_FIRST_Pos (12UL)                  /*!< PCM_IN_LSB_FIRST (Bit 12)                             */
#define PCM_GLOBAL_CFG_PCM_IN_LSB_FIRST_Msk (0x1000UL)              /*!< PCM_IN_LSB_FIRST (Bitfield-Mask: 0x01)                */
#define PCM_GLOBAL_CFG_PCM_OUT_LSB_FIRST_Pos (11UL)                 /*!< PCM_OUT_LSB_FIRST (Bit 11)                            */
#define PCM_GLOBAL_CFG_PCM_OUT_LSB_FIRST_Msk (0x800UL)              /*!< PCM_OUT_LSB_FIRST (Bitfield-Mask: 0x01)               */
#define PCM_GLOBAL_CFG_PCM_TS1_Pos        (6UL)                     /*!< PCM_TS1 (Bit 6)                                       */
#define PCM_GLOBAL_CFG_PCM_TS1_Msk        (0x7c0UL)                 /*!< PCM_TS1 (Bitfield-Mask: 0x1f)                         */
#define PCM_GLOBAL_CFG_PCM_TS0_Pos        (1UL)                     /*!< PCM_TS0 (Bit 1)                                       */
#define PCM_GLOBAL_CFG_PCM_TS0_Msk        (0x3eUL)                  /*!< PCM_TS0 (Bitfield-Mask: 0x1f)                         */
#define PCM_GLOBAL_CFG_PCM_ENABLE_Pos     (0UL)                     /*!< PCM_ENABLE (Bit 0)                                    */
#define PCM_GLOBAL_CFG_PCM_ENABLE_Msk     (0x1UL)                   /*!< PCM_ENABLE (Bitfield-Mask: 0x01)                      */
/* ======================================================  NCO_RATIO_L  ====================================================== */
#define PCM_NCO_RATIO_L_RATIO_REGISTER_L_Pos (0UL)                  /*!< RATIO_REGISTER_L (Bit 0)                              */
#define PCM_NCO_RATIO_L_RATIO_REGISTER_L_Msk (0xffffffffUL)         /*!< RATIO_REGISTER_L (Bitfield-Mask: 0xffffffff)          */
/* ======================================================  NCO_RATIO_H  ====================================================== */
#define PCM_NCO_RATIO_H_RATIO_REGISTER_H_Pos (0UL)                  /*!< RATIO_REGISTER_H (Bit 0)                              */
#define PCM_NCO_RATIO_H_RATIO_REGISTER_H_Msk (0xffffUL)             /*!< RATIO_REGISTER_H (Bitfield-Mask: 0xffff)              */
/* ======================================================  NCO_DRATIO  ======================================================= */
#define PCM_NCO_DRATIO_DELTA_RATIO_Pos    (0UL)                     /*!< DELTA_RATIO (Bit 0)                                   */
#define PCM_NCO_DRATIO_DELTA_RATIO_Msk    (0xffffffffUL)            /*!< DELTA_RATIO (Bitfield-Mask: 0xffffffff)               */
/* =====================================================  FIFO_TX_STAT  ====================================================== */
#define PCM_FIFO_TX_STAT_FIFO_TX_TS1_DATA_CNT_Pos (16UL)            /*!< FIFO_TX_TS1_DATA_CNT (Bit 16)                         */
#define PCM_FIFO_TX_STAT_FIFO_TX_TS1_DATA_CNT_Msk (0x3ff0000UL)     /*!< FIFO_TX_TS1_DATA_CNT (Bitfield-Mask: 0x3ff)           */
#define PCM_FIFO_TX_STAT_FIFO_TX_TS0_DATA_CNT_Pos (0UL)             /*!< FIFO_TX_TS0_DATA_CNT (Bit 0)                          */
#define PCM_FIFO_TX_STAT_FIFO_TX_TS0_DATA_CNT_Msk (0x3ffUL)         /*!< FIFO_TX_TS0_DATA_CNT (Bitfield-Mask: 0x3ff)           */
/* =====================================================  FIFO_RX_STAT  ====================================================== */
#define PCM_FIFO_RX_STAT_FIFO_RX_TS1_DATA_CNT_Pos (16UL)            /*!< FIFO_RX_TS1_DATA_CNT (Bit 16)                         */
#define PCM_FIFO_RX_STAT_FIFO_RX_TS1_DATA_CNT_Msk (0x3ff0000UL)     /*!< FIFO_RX_TS1_DATA_CNT (Bitfield-Mask: 0x3ff)           */
#define PCM_FIFO_RX_STAT_FIFO_RX_TS0_DATA_CNT_Pos (0UL)             /*!< FIFO_RX_TS0_DATA_CNT (Bit 0)                          */
#define PCM_FIFO_RX_STAT_FIFO_RX_TS0_DATA_CNT_Msk (0x3ffUL)         /*!< FIFO_RX_TS0_DATA_CNT (Bitfield-Mask: 0x3ff)           */
/* ===================================================  FIFO_TX_ERR_STAT  ==================================================== */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS0_UFLOW_CNT_Pos (24UL)       /*!< FIFO_TX_TS0_UFLOW_CNT (Bit 24)                        */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS0_UFLOW_CNT_Msk (0xff000000UL) /*!< FIFO_TX_TS0_UFLOW_CNT (Bitfield-Mask: 0xff)         */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS0_OFLOW_CNT_Pos (16UL)       /*!< FIFO_TX_TS0_OFLOW_CNT (Bit 16)                        */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS0_OFLOW_CNT_Msk (0xff0000UL) /*!< FIFO_TX_TS0_OFLOW_CNT (Bitfield-Mask: 0xff)           */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS1_UFLOW_CNT_Pos (8UL)        /*!< FIFO_TX_TS1_UFLOW_CNT (Bit 8)                         */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS1_UFLOW_CNT_Msk (0xff00UL)   /*!< FIFO_TX_TS1_UFLOW_CNT (Bitfield-Mask: 0xff)           */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS1_OFLOW_CNT_Pos (0UL)        /*!< FIFO_TX_TS1_OFLOW_CNT (Bit 0)                         */
#define PCM_FIFO_TX_ERR_STAT_FIFO_TX_TS1_OFLOW_CNT_Msk (0xffUL)     /*!< FIFO_TX_TS1_OFLOW_CNT (Bitfield-Mask: 0xff)           */
/* ===================================================  FIFO_RX_ERR_STAT  ==================================================== */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS0_UFLOW_CNT_Pos (24UL)       /*!< FIFO_RX_TS0_UFLOW_CNT (Bit 24)                        */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS0_UFLOW_CNT_Msk (0xff000000UL) /*!< FIFO_RX_TS0_UFLOW_CNT (Bitfield-Mask: 0xff)         */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS0_OFLOW_CNT_Pos (16UL)       /*!< FIFO_RX_TS0_OFLOW_CNT (Bit 16)                        */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS0_OFLOW_CNT_Msk (0xff0000UL) /*!< FIFO_RX_TS0_OFLOW_CNT (Bitfield-Mask: 0xff)           */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS1_UFLOW_CNT_Pos (8UL)        /*!< FIFO_RX_TS1_UFLOW_CNT (Bit 8)                         */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS1_UFLOW_CNT_Msk (0xff00UL)   /*!< FIFO_RX_TS1_UFLOW_CNT (Bitfield-Mask: 0xff)           */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS1_OFLOW_CNT_Pos (0UL)        /*!< FIFO_RX_TS1_OFLOW_CNT (Bit 0)                         */
#define PCM_FIFO_RX_ERR_STAT_FIFO_RX_TS1_OFLOW_CNT_Msk (0xffUL)     /*!< FIFO_RX_TS1_OFLOW_CNT (Bitfield-Mask: 0xff)           */
/* ==================================================  FIFO_TX_TS0_THR_INT  ================================================== */
#define PCM_FIFO_TX_TS0_THR_INT_TX_TS0_THR_HI_Pos (16UL)            /*!< TX_TS0_THR_HI (Bit 16)                                */
#define PCM_FIFO_TX_TS0_THR_INT_TX_TS0_THR_HI_Msk (0x7ff0000UL)     /*!< TX_TS0_THR_HI (Bitfield-Mask: 0x7ff)                  */
#define PCM_FIFO_TX_TS0_THR_INT_TX_TS0_THR_LO_Pos (0UL)             /*!< TX_TS0_THR_LO (Bit 0)                                 */
#define PCM_FIFO_TX_TS0_THR_INT_TX_TS0_THR_LO_Msk (0x7ffUL)         /*!< TX_TS0_THR_LO (Bitfield-Mask: 0x7ff)                  */
/* ==================================================  FIFO_TX_TS1_THR_INT  ================================================== */
#define PCM_FIFO_TX_TS1_THR_INT_TX_TS1_THR_HI_Pos (16UL)            /*!< TX_TS1_THR_HI (Bit 16)                                */
#define PCM_FIFO_TX_TS1_THR_INT_TX_TS1_THR_HI_Msk (0x7ff0000UL)     /*!< TX_TS1_THR_HI (Bitfield-Mask: 0x7ff)                  */
#define PCM_FIFO_TX_TS1_THR_INT_TX_TS1_THR_LO_Pos (0UL)             /*!< TX_TS1_THR_LO (Bit 0)                                 */
#define PCM_FIFO_TX_TS1_THR_INT_TX_TS1_THR_LO_Msk (0x7ffUL)         /*!< TX_TS1_THR_LO (Bitfield-Mask: 0x7ff)                  */
/* ==================================================  FIFO_RX_TS0_THR_INT  ================================================== */
#define PCM_FIFO_RX_TS0_THR_INT_RX_TS0_THR_HI_Pos (16UL)            /*!< RX_TS0_THR_HI (Bit 16)                                */
#define PCM_FIFO_RX_TS0_THR_INT_RX_TS0_THR_HI_Msk (0x7ff0000UL)     /*!< RX_TS0_THR_HI (Bitfield-Mask: 0x7ff)                  */
#define PCM_FIFO_RX_TS0_THR_INT_RX_TS0_THR_LO_Pos (0UL)             /*!< RX_TS0_THR_LO (Bit 0)                                 */
#define PCM_FIFO_RX_TS0_THR_INT_RX_TS0_THR_LO_Msk (0x7ffUL)         /*!< RX_TS0_THR_LO (Bitfield-Mask: 0x7ff)                  */
/* ==================================================  FIFO_RX_TS1_THR_INT  ================================================== */
#define PCM_FIFO_RX_TS1_THR_INT_RX_TS1_THR_HI_Pos (16UL)            /*!< RX_TS1_THR_HI (Bit 16)                                */
#define PCM_FIFO_RX_TS1_THR_INT_RX_TS1_THR_HI_Msk (0x7ff0000UL)     /*!< RX_TS1_THR_HI (Bitfield-Mask: 0x7ff)                  */
#define PCM_FIFO_RX_TS1_THR_INT_RX_TS1_THR_LO_Pos (0UL)             /*!< RX_TS1_THR_LO (Bit 0)                                 */
#define PCM_FIFO_RX_TS1_THR_INT_RX_TS1_THR_LO_Msk (0x7ffUL)         /*!< RX_TS1_THR_LO (Bitfield-Mask: 0x7ff)                  */
/* ======================================================  THR_INT_CFG  ====================================================== */
#define PCM_THR_INT_CFG_TX_TS0_CROSS_THR_HI_INT_EN_Pos (15UL)       /*!< TX_TS0_CROSS_THR_HI_INT_EN (Bit 15)                   */
#define PCM_THR_INT_CFG_TX_TS0_CROSS_THR_HI_INT_EN_Msk (0x8000UL)   /*!< TX_TS0_CROSS_THR_HI_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_TX_TS0_CROSS_THR_LO_INT_EN_Pos (14UL)       /*!< TX_TS0_CROSS_THR_LO_INT_EN (Bit 14)                   */
#define PCM_THR_INT_CFG_TX_TS0_CROSS_THR_LO_INT_EN_Msk (0x4000UL)   /*!< TX_TS0_CROSS_THR_LO_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_TX_TS1_CROSS_THR_HI_INT_EN_Pos (13UL)       /*!< TX_TS1_CROSS_THR_HI_INT_EN (Bit 13)                   */
#define PCM_THR_INT_CFG_TX_TS1_CROSS_THR_HI_INT_EN_Msk (0x2000UL)   /*!< TX_TS1_CROSS_THR_HI_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_TX_TS1_CROSS_THR_LO_INT_EN_Pos (12UL)       /*!< TX_TS1_CROSS_THR_LO_INT_EN (Bit 12)                   */
#define PCM_THR_INT_CFG_TX_TS1_CROSS_THR_LO_INT_EN_Msk (0x1000UL)   /*!< TX_TS1_CROSS_THR_LO_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_RX_TS0_CROSS_THR_HI_INT_EN_Pos (11UL)       /*!< RX_TS0_CROSS_THR_HI_INT_EN (Bit 11)                   */
#define PCM_THR_INT_CFG_RX_TS0_CROSS_THR_HI_INT_EN_Msk (0x800UL)    /*!< RX_TS0_CROSS_THR_HI_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_RX_TS0_CROSS_THR_LO_INT_EN_Pos (10UL)       /*!< RX_TS0_CROSS_THR_LO_INT_EN (Bit 10)                   */
#define PCM_THR_INT_CFG_RX_TS0_CROSS_THR_LO_INT_EN_Msk (0x400UL)    /*!< RX_TS0_CROSS_THR_LO_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_RX_TS1_CROSS_THR_HI_INT_EN_Pos (9UL)        /*!< RX_TS1_CROSS_THR_HI_INT_EN (Bit 9)                    */
#define PCM_THR_INT_CFG_RX_TS1_CROSS_THR_HI_INT_EN_Msk (0x200UL)    /*!< RX_TS1_CROSS_THR_HI_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_RX_TS1_CROSS_THR_LO_INT_EN_Pos (8UL)        /*!< RX_TS1_CROSS_THR_LO_INT_EN (Bit 8)                    */
#define PCM_THR_INT_CFG_RX_TS1_CROSS_THR_LO_INT_EN_Msk (0x100UL)    /*!< RX_TS1_CROSS_THR_LO_INT_EN (Bitfield-Mask: 0x01)      */
#define PCM_THR_INT_CFG_TX_TS0_THR_HI_INT_MSK_Pos (7UL)             /*!< TX_TS0_THR_HI_INT_MSK (Bit 7)                         */
#define PCM_THR_INT_CFG_TX_TS0_THR_HI_INT_MSK_Msk (0x80UL)          /*!< TX_TS0_THR_HI_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_TX_TS0_THR_LO_INT_MSK_Pos (6UL)             /*!< TX_TS0_THR_LO_INT_MSK (Bit 6)                         */
#define PCM_THR_INT_CFG_TX_TS0_THR_LO_INT_MSK_Msk (0x40UL)          /*!< TX_TS0_THR_LO_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_TX_TS1_THR_HI_INT_MSK_Pos (5UL)             /*!< TX_TS1_THR_HI_INT_MSK (Bit 5)                         */
#define PCM_THR_INT_CFG_TX_TS1_THR_HI_INT_MSK_Msk (0x20UL)          /*!< TX_TS1_THR_HI_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_TX_TS1_THR_LO_INT_MSK_Pos (4UL)             /*!< TX_TS1_THR_LO_INT_MSK (Bit 4)                         */
#define PCM_THR_INT_CFG_TX_TS1_THR_LO_INT_MSK_Msk (0x10UL)          /*!< TX_TS1_THR_LO_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_RX_TS0_THR_HI_INT_MSK_Pos (3UL)             /*!< RX_TS0_THR_HI_INT_MSK (Bit 3)                         */
#define PCM_THR_INT_CFG_RX_TS0_THR_HI_INT_MSK_Msk (0x8UL)           /*!< RX_TS0_THR_HI_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_RX_TS0_THR_LO_INT_MSK_Pos (2UL)             /*!< RX_TS0_THR_LO_INT_MSK (Bit 2)                         */
#define PCM_THR_INT_CFG_RX_TS0_THR_LO_INT_MSK_Msk (0x4UL)           /*!< RX_TS0_THR_LO_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_RX_TS1_THR_HI_INT_MSK_Pos (1UL)             /*!< RX_TS1_THR_HI_INT_MSK (Bit 1)                         */
#define PCM_THR_INT_CFG_RX_TS1_THR_HI_INT_MSK_Msk (0x2UL)           /*!< RX_TS1_THR_HI_INT_MSK (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CFG_RX_TS1_THR_LO_INT_MSK_Pos (0UL)             /*!< RX_TS1_THR_LO_INT_MSK (Bit 0)                         */
#define PCM_THR_INT_CFG_RX_TS1_THR_LO_INT_MSK_Msk (0x1UL)           /*!< RX_TS1_THR_LO_INT_MSK (Bitfield-Mask: 0x01)           */
/* ======================================================  THR_INT_CSE  ====================================================== */
#define PCM_THR_INT_CSE_TX_TS0_THR_HI_INT_CSE_Pos (7UL)             /*!< TX_TS0_THR_HI_INT_CSE (Bit 7)                         */
#define PCM_THR_INT_CSE_TX_TS0_THR_HI_INT_CSE_Msk (0x80UL)          /*!< TX_TS0_THR_HI_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_TX_TS0_THR_LO_INT_CSE_Pos (6UL)             /*!< TX_TS0_THR_LO_INT_CSE (Bit 6)                         */
#define PCM_THR_INT_CSE_TX_TS0_THR_LO_INT_CSE_Msk (0x40UL)          /*!< TX_TS0_THR_LO_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_TX_TS1_THR_HI_INT_CSE_Pos (5UL)             /*!< TX_TS1_THR_HI_INT_CSE (Bit 5)                         */
#define PCM_THR_INT_CSE_TX_TS1_THR_HI_INT_CSE_Msk (0x20UL)          /*!< TX_TS1_THR_HI_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_TX_TS1_THR_LO_INT_CSE_Pos (4UL)             /*!< TX_TS1_THR_LO_INT_CSE (Bit 4)                         */
#define PCM_THR_INT_CSE_TX_TS1_THR_LO_INT_CSE_Msk (0x10UL)          /*!< TX_TS1_THR_LO_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_RX_TS0_THR_HI_INT_CSE_Pos (3UL)             /*!< RX_TS0_THR_HI_INT_CSE (Bit 3)                         */
#define PCM_THR_INT_CSE_RX_TS0_THR_HI_INT_CSE_Msk (0x8UL)           /*!< RX_TS0_THR_HI_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_RX_TS0_THR_LO_INT_CSE_Pos (2UL)             /*!< RX_TS0_THR_LO_INT_CSE (Bit 2)                         */
#define PCM_THR_INT_CSE_RX_TS0_THR_LO_INT_CSE_Msk (0x4UL)           /*!< RX_TS0_THR_LO_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_RX_TS1_THR_HI_INT_CSE_Pos (1UL)             /*!< RX_TS1_THR_HI_INT_CSE (Bit 1)                         */
#define PCM_THR_INT_CSE_RX_TS1_THR_HI_INT_CSE_Msk (0x2UL)           /*!< RX_TS1_THR_HI_INT_CSE (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_CSE_RX_TS1_THR_LO_INT_CSE_Pos (0UL)             /*!< RX_TS1_THR_LO_INT_CSE (Bit 0)                         */
#define PCM_THR_INT_CSE_RX_TS1_THR_LO_INT_CSE_Msk (0x1UL)           /*!< RX_TS1_THR_LO_INT_CSE (Bitfield-Mask: 0x01)           */
/* ======================================================  THR_INT_SRC  ====================================================== */
#define PCM_THR_INT_SRC_TX_TS0_THR_HI_INT_SRC_Pos (7UL)             /*!< TX_TS0_THR_HI_INT_SRC (Bit 7)                         */
#define PCM_THR_INT_SRC_TX_TS0_THR_HI_INT_SRC_Msk (0x80UL)          /*!< TX_TS0_THR_HI_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_TX_TS0_THR_LO_INT_SRC_Pos (6UL)             /*!< TX_TS0_THR_LO_INT_SRC (Bit 6)                         */
#define PCM_THR_INT_SRC_TX_TS0_THR_LO_INT_SRC_Msk (0x40UL)          /*!< TX_TS0_THR_LO_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_TX_TS1_THR_HI_INT_SRC_Pos (5UL)             /*!< TX_TS1_THR_HI_INT_SRC (Bit 5)                         */
#define PCM_THR_INT_SRC_TX_TS1_THR_HI_INT_SRC_Msk (0x20UL)          /*!< TX_TS1_THR_HI_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_TX_TS1_THR_LO_INT_SRC_Pos (4UL)             /*!< TX_TS1_THR_LO_INT_SRC (Bit 4)                         */
#define PCM_THR_INT_SRC_TX_TS1_THR_LO_INT_SRC_Msk (0x10UL)          /*!< TX_TS1_THR_LO_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_RX_TS0_THR_HI_INT_SRC_Pos (3UL)             /*!< RX_TS0_THR_HI_INT_SRC (Bit 3)                         */
#define PCM_THR_INT_SRC_RX_TS0_THR_HI_INT_SRC_Msk (0x8UL)           /*!< RX_TS0_THR_HI_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_RX_TS0_THR_LO_INT_SRC_Pos (2UL)             /*!< RX_TS0_THR_LO_INT_SRC (Bit 2)                         */
#define PCM_THR_INT_SRC_RX_TS0_THR_LO_INT_SRC_Msk (0x4UL)           /*!< RX_TS0_THR_LO_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_RX_TS1_THR_HI_INT_SRC_Pos (1UL)             /*!< RX_TS1_THR_HI_INT_SRC (Bit 1)                         */
#define PCM_THR_INT_SRC_RX_TS1_THR_HI_INT_SRC_Msk (0x2UL)           /*!< RX_TS1_THR_HI_INT_SRC (Bitfield-Mask: 0x01)           */
#define PCM_THR_INT_SRC_RX_TS1_THR_LO_INT_SRC_Pos (0UL)             /*!< RX_TS1_THR_LO_INT_SRC (Bit 0)                         */
#define PCM_THR_INT_SRC_RX_TS1_THR_LO_INT_SRC_Msk (0x1UL)           /*!< RX_TS1_THR_LO_INT_SRC (Bitfield-Mask: 0x01)           */
/* ======================================================  ERR_INT_CFG  ====================================================== */
#define PCM_ERR_INT_CFG_FIFO_TX_TS0_UFLOW_INT_MSK_Pos (7UL)         /*!< FIFO_TX_TS0_UFLOW_INT_MSK (Bit 7)                     */
#define PCM_ERR_INT_CFG_FIFO_TX_TS0_UFLOW_INT_MSK_Msk (0x80UL)      /*!< FIFO_TX_TS0_UFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_TX_TS0_OFLOW_INT_MSK_Pos (6UL)         /*!< FIFO_TX_TS0_OFLOW_INT_MSK (Bit 6)                     */
#define PCM_ERR_INT_CFG_FIFO_TX_TS0_OFLOW_INT_MSK_Msk (0x40UL)      /*!< FIFO_TX_TS0_OFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_TX_TS1_UFLOW_INT_MSK_Pos (5UL)         /*!< FIFO_TX_TS1_UFLOW_INT_MSK (Bit 5)                     */
#define PCM_ERR_INT_CFG_FIFO_TX_TS1_UFLOW_INT_MSK_Msk (0x20UL)      /*!< FIFO_TX_TS1_UFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_TX_TS1_OFLOW_INT_MSK_Pos (4UL)         /*!< FIFO_TX_TS1_OFLOW_INT_MSK (Bit 4)                     */
#define PCM_ERR_INT_CFG_FIFO_TX_TS1_OFLOW_INT_MSK_Msk (0x10UL)      /*!< FIFO_TX_TS1_OFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_RX_TS0_UFLOW_INT_MSK_Pos (3UL)         /*!< FIFO_RX_TS0_UFLOW_INT_MSK (Bit 3)                     */
#define PCM_ERR_INT_CFG_FIFO_RX_TS0_UFLOW_INT_MSK_Msk (0x8UL)       /*!< FIFO_RX_TS0_UFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_RX_TS0_OFLOW_INT_MSK_Pos (2UL)         /*!< FIFO_RX_TS0_OFLOW_INT_MSK (Bit 2)                     */
#define PCM_ERR_INT_CFG_FIFO_RX_TS0_OFLOW_INT_MSK_Msk (0x4UL)       /*!< FIFO_RX_TS0_OFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_RX_TS1_UFLOW_INT_MSK_Pos (1UL)         /*!< FIFO_RX_TS1_UFLOW_INT_MSK (Bit 1)                     */
#define PCM_ERR_INT_CFG_FIFO_RX_TS1_UFLOW_INT_MSK_Msk (0x2UL)       /*!< FIFO_RX_TS1_UFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CFG_FIFO_RX_TS1_OFLOW_INT_MSK_Pos (0UL)         /*!< FIFO_RX_TS1_OFLOW_INT_MSK (Bit 0)                     */
#define PCM_ERR_INT_CFG_FIFO_RX_TS1_OFLOW_INT_MSK_Msk (0x1UL)       /*!< FIFO_RX_TS1_OFLOW_INT_MSK (Bitfield-Mask: 0x01)       */
/* ======================================================  ERR_INT_CSE  ====================================================== */
#define PCM_ERR_INT_CSE_FIFO_TX_TS0_UFLOW_INT_CSE_Pos (7UL)         /*!< FIFO_TX_TS0_UFLOW_INT_CSE (Bit 7)                     */
#define PCM_ERR_INT_CSE_FIFO_TX_TS0_UFLOW_INT_CSE_Msk (0x80UL)      /*!< FIFO_TX_TS0_UFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_TX_TS0_OFLOW_INT_CSE_Pos (6UL)         /*!< FIFO_TX_TS0_OFLOW_INT_CSE (Bit 6)                     */
#define PCM_ERR_INT_CSE_FIFO_TX_TS0_OFLOW_INT_CSE_Msk (0x40UL)      /*!< FIFO_TX_TS0_OFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_TX_TS1_UFLOW_INT_CSE_Pos (5UL)         /*!< FIFO_TX_TS1_UFLOW_INT_CSE (Bit 5)                     */
#define PCM_ERR_INT_CSE_FIFO_TX_TS1_UFLOW_INT_CSE_Msk (0x20UL)      /*!< FIFO_TX_TS1_UFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_TX_TS1_OFLOW_INT_CSE_Pos (4UL)         /*!< FIFO_TX_TS1_OFLOW_INT_CSE (Bit 4)                     */
#define PCM_ERR_INT_CSE_FIFO_TX_TS1_OFLOW_INT_CSE_Msk (0x10UL)      /*!< FIFO_TX_TS1_OFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_RX_TS0_UFLOW_INT_CSE_Pos (3UL)         /*!< FIFO_RX_TS0_UFLOW_INT_CSE (Bit 3)                     */
#define PCM_ERR_INT_CSE_FIFO_RX_TS0_UFLOW_INT_CSE_Msk (0x8UL)       /*!< FIFO_RX_TS0_UFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_RX_TS0_OFLOW_INT_CSE_Pos (2UL)         /*!< FIFO_RX_TS0_OFLOW_INT_CSE (Bit 2)                     */
#define PCM_ERR_INT_CSE_FIFO_RX_TS0_OFLOW_INT_CSE_Msk (0x4UL)       /*!< FIFO_RX_TS0_OFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_RX_TS1_UFLOW_INT_CSE_Pos (1UL)         /*!< FIFO_RX_TS1_UFLOW_INT_CSE (Bit 1)                     */
#define PCM_ERR_INT_CSE_FIFO_RX_TS1_UFLOW_INT_CSE_Msk (0x2UL)       /*!< FIFO_RX_TS1_UFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
#define PCM_ERR_INT_CSE_FIFO_RX_TS1_OFLOW_INT_CSE_Pos (0UL)         /*!< FIFO_RX_TS1_OFLOW_INT_CSE (Bit 0)                     */
#define PCM_ERR_INT_CSE_FIFO_RX_TS1_OFLOW_INT_CSE_Msk (0x1UL)       /*!< FIFO_RX_TS1_OFLOW_INT_CSE (Bitfield-Mask: 0x01)       */
/* ======================================================  TS0_THR_DMA  ====================================================== */
#define PCM_TS0_THR_DMA_DMA_RX_TS0_THR_HI_Pos (16UL)                /*!< DMA_RX_TS0_THR_HI (Bit 16)                            */
#define PCM_TS0_THR_DMA_DMA_RX_TS0_THR_HI_Msk (0x7ff0000UL)         /*!< DMA_RX_TS0_THR_HI (Bitfield-Mask: 0x7ff)              */
#define PCM_TS0_THR_DMA_DMA_TX_TS0_THR_LO_Pos (0UL)                 /*!< DMA_TX_TS0_THR_LO (Bit 0)                             */
#define PCM_TS0_THR_DMA_DMA_TX_TS0_THR_LO_Msk (0x7ffUL)             /*!< DMA_TX_TS0_THR_LO (Bitfield-Mask: 0x7ff)              */
/* ======================================================  TS1_THR_DMA  ====================================================== */
#define PCM_TS1_THR_DMA_DMA_RX_TS1_THR_HI_Pos (16UL)                /*!< DMA_RX_TS1_THR_HI (Bit 16)                            */
#define PCM_TS1_THR_DMA_DMA_RX_TS1_THR_HI_Msk (0x7ff0000UL)         /*!< DMA_RX_TS1_THR_HI (Bitfield-Mask: 0x7ff)              */
#define PCM_TS1_THR_DMA_DMA_TX_TS1_THR_LO_Pos (0UL)                 /*!< DMA_TX_TS1_THR_LO (Bit 0)                             */
#define PCM_TS1_THR_DMA_DMA_TX_TS1_THR_LO_Msk (0x7ffUL)             /*!< DMA_TX_TS1_THR_LO (Bitfield-Mask: 0x7ff)              */
/* =======================================================  PCM_STAT  ======================================================== */
#define PCM_PCM_STAT_PCM_CLK_RUN_Pos      (0UL)                     /*!< PCM_CLK_RUN (Bit 0)                                   */
#define PCM_PCM_STAT_PCM_CLK_RUN_Msk      (0x1UL)                   /*!< PCM_CLK_RUN (Bitfield-Mask: 0x01)                     */
/* ======================================================  FIFO_CLEAR  ======================================================= */
#define PCM_FIFO_CLEAR_TX_Pos             (1UL)                     /*!< TX (Bit 1)                                            */
#define PCM_FIFO_CLEAR_TX_Msk             (0x2UL)                   /*!< TX (Bitfield-Mask: 0x01)                              */
#define PCM_FIFO_CLEAR_RX_Pos             (0UL)                     /*!< RX (Bit 0)                                            */
#define PCM_FIFO_CLEAR_RX_Msk             (0x1UL)                   /*!< RX (Bitfield-Mask: 0x01)                              */
/* ================================================  FIFO_TX_TS0_RD_HALT_THR  ================================================ */
#define PCM_FIFO_TX_TS0_RD_HALT_THR_RD_HALT_THR_Pos (0UL)           /*!< RD_HALT_THR (Bit 0)                                   */
#define PCM_FIFO_TX_TS0_RD_HALT_THR_RD_HALT_THR_Msk (0x7ffUL)       /*!< RD_HALT_THR (Bitfield-Mask: 0x7ff)                    */
/* ================================================  FIFO_TX_TS1_RD_HALT_THR  ================================================ */
#define PCM_FIFO_TX_TS1_RD_HALT_THR_RD_HALT_THR_Pos (0UL)           /*!< RD_HALT_THR (Bit 0)                                   */
#define PCM_FIFO_TX_TS1_RD_HALT_THR_RD_HALT_THR_Msk (0x7ffUL)       /*!< RD_HALT_THR (Bitfield-Mask: 0x7ff)                    */
/* =====================================================  SIDETONE_CFG  ====================================================== */
#define PCM_SIDETONE_CFG_RX_TS0_SIDETONE_VOLUME_Pos (0UL)           /*!< RX_TS0_SIDETONE_VOLUME (Bit 0)                        */
#define PCM_SIDETONE_CFG_RX_TS0_SIDETONE_VOLUME_Msk (0xfUL)         /*!< RX_TS0_SIDETONE_VOLUME (Bitfield-Mask: 0x0f)          */
#define PCM_SIDETONE_CFG_TS0_SIDETONE_SRC_SEL_Pos (4UL)             /*!< TS0_SIDETONE_SRC_SEL (Bit 4)                          */
#define PCM_SIDETONE_CFG_TS0_SIDETONE_SRC_SEL_Msk (0x30UL)          /*!< TS0_SIDETONE_SRC_SEL (Bitfield-Mask: 0x03)            */
#define PCM_SIDETONE_CFG_TS0_SIDETONE_EN_Pos (8UL)                  /*!< TS0_SIDETONE_EN (Bit 8)                               */
#define PCM_SIDETONE_CFG_TS0_SIDETONE_EN_Msk (0x100UL)              /*!< TS0_SIDETONE_EN (Bitfield-Mask: 0x01)                 */
#define PCM_SIDETONE_CFG_RX_TS1_SIDETONE_VOLUME_Pos (12UL)          /*!< RX_TS1_SIDETONE_VOLUME (Bit 12)                       */
#define PCM_SIDETONE_CFG_RX_TS1_SIDETONE_VOLUME_Msk (0xf000UL)      /*!< RX_TS1_SIDETONE_VOLUME (Bitfield-Mask: 0x0f)          */
#define PCM_SIDETONE_CFG_TS1_SIDETONE_SRC_SEL_Pos (16UL)            /*!< TS1_SIDETONE_SRC_SEL (Bit 16)                         */
#define PCM_SIDETONE_CFG_TS1_SIDETONE_SRC_SEL_Msk (0x30000UL)       /*!< TS1_SIDETONE_SRC_SEL (Bitfield-Mask: 0x03)            */
#define PCM_SIDETONE_CFG_TS1_SIDETONE_EN_Pos (20UL)                 /*!< TS1_SIDETONE_EN (Bit 20)                              */
#define PCM_SIDETONE_CFG_TS1_SIDETONE_EN_Msk (0x100000UL)           /*!< TS1_SIDETONE_EN (Bitfield-Mask: 0x01)                 */
#define PCM_SIDETONE_CFG_SIDETONE_SIGNED_Pos (24UL)                 /*!< SIDETONE_SIGNED (Bit 24)                              */
#define PCM_SIDETONE_CFG_SIDETONE_SIGNED_Msk (0x1000000UL)          /*!< SIDETONE_SIGNED (Bitfield-Mask: 0x01)                 */
/* ======================================================  FIFO_TX_TS0  ====================================================== */
#define PCM_FIFO_TX_TS0_FIFO_TX_TS0_DATA_Pos (0UL)                  /*!< FIFO_TX_TS0_DATA (Bit 0)                              */
#define PCM_FIFO_TX_TS0_FIFO_TX_TS0_DATA_Msk (0xffffffffUL)         /*!< FIFO_TX_TS0_DATA (Bitfield-Mask: 0xffffffff)          */
/* ======================================================  FIFO_TX_TS1  ====================================================== */
#define PCM_FIFO_TX_TS1_FIFO_TX_TS1_DATA_Pos (0UL)                  /*!< FIFO_TX_TS1_DATA (Bit 0)                              */
#define PCM_FIFO_TX_TS1_FIFO_TX_TS1_DATA_Msk (0xffffffffUL)         /*!< FIFO_TX_TS1_DATA (Bitfield-Mask: 0xffffffff)          */
/* ======================================================  FIFO_RX_TS0  ====================================================== */
#define PCM_FIFO_RX_TS0_FIFO_RX_TS0_Q_Pos (0UL)                     /*!< FIFO_RX_TS0_Q (Bit 0)                                 */
#define PCM_FIFO_RX_TS0_FIFO_RX_TS0_Q_Msk (0xffffffffUL)            /*!< FIFO_RX_TS0_Q (Bitfield-Mask: 0xffffffff)             */
/* ======================================================  FIFO_RX_TS1  ====================================================== */
#define PCM_FIFO_RX_TS1_FIFO_RX_TS1_Q_Pos (0UL)                     /*!< FIFO_RX_TS1_Q (Bit 0)                                 */
#define PCM_FIFO_RX_TS1_FIFO_RX_TS1_Q_Msk (0xffffffffUL)            /*!< FIFO_RX_TS1_Q (Bitfield-Mask: 0xffffffff)             */


/* =========================================================================================================================== */
/* ================                                          PWM_DAC                                          ================ */
/* =========================================================================================================================== */

/* =======================================================  OP_RATE0  ======================================================== */
#define PWM_DAC_OP_RATE0_MASK_HW_DISABLE_Pos (6UL)                  /*!< MASK_HW_DISABLE (Bit 6)                               */
#define PWM_DAC_OP_RATE0_MASK_HW_DISABLE_Msk (0x40UL)               /*!< MASK_HW_DISABLE (Bitfield-Mask: 0x01)                 */
#define PWM_DAC_OP_RATE0_DISABLE_VAL_Pos  (5UL)                     /*!< DISABLE_VAL (Bit 5)                                   */
#define PWM_DAC_OP_RATE0_DISABLE_VAL_Msk  (0x20UL)                  /*!< DISABLE_VAL (Bitfield-Mask: 0x01)                     */
#define PWM_DAC_OP_RATE0_EN_Pos           (4UL)                     /*!< EN (Bit 4)                                            */
#define PWM_DAC_OP_RATE0_EN_Msk           (0x10UL)                  /*!< EN (Bitfield-Mask: 0x01)                              */
#define PWM_DAC_OP_RATE0_OP_RATE_Pos      (0UL)                     /*!< OP_RATE (Bit 0)                                       */
#define PWM_DAC_OP_RATE0_OP_RATE_Msk      (0xfUL)                   /*!< OP_RATE (Bitfield-Mask: 0x0f)                         */
/* =========================================================  RATE0  ========================================================= */
#define PWM_DAC_RATE0_RATE_Pos            (0UL)                     /*!< RATE (Bit 0)                                          */
#define PWM_DAC_RATE0_RATE_Msk            (0x3ffUL)                 /*!< RATE (Bitfield-Mask: 0x3ff)                           */
/* =======================================================  OP_RATE1  ======================================================== */
#define PWM_DAC_OP_RATE1_MASK_HW_DISABLE_Pos (6UL)                  /*!< MASK_HW_DISABLE (Bit 6)                               */
#define PWM_DAC_OP_RATE1_MASK_HW_DISABLE_Msk (0x40UL)               /*!< MASK_HW_DISABLE (Bitfield-Mask: 0x01)                 */
#define PWM_DAC_OP_RATE1_DISABLE_VAL_Pos  (5UL)                     /*!< DISABLE_VAL (Bit 5)                                   */
#define PWM_DAC_OP_RATE1_DISABLE_VAL_Msk  (0x20UL)                  /*!< DISABLE_VAL (Bitfield-Mask: 0x01)                     */
#define PWM_DAC_OP_RATE1_EN_Pos           (4UL)                     /*!< EN (Bit 4)                                            */
#define PWM_DAC_OP_RATE1_EN_Msk           (0x10UL)                  /*!< EN (Bitfield-Mask: 0x01)                              */
#define PWM_DAC_OP_RATE1_OP_RATE_Pos      (0UL)                     /*!< OP_RATE (Bit 0)                                       */
#define PWM_DAC_OP_RATE1_OP_RATE_Msk      (0xfUL)                   /*!< OP_RATE (Bitfield-Mask: 0x0f)                         */
/* =========================================================  RATE1  ========================================================= */
#define PWM_DAC_RATE1_RATE_Pos            (0UL)                     /*!< RATE (Bit 0)                                          */
#define PWM_DAC_RATE1_RATE_Msk            (0x3ffUL)                 /*!< RATE (Bitfield-Mask: 0x3ff)                           */
/* =======================================================  OP_RATE2  ======================================================== */
#define PWM_DAC_OP_RATE2_MASK_HW_DISABLE_Pos (6UL)                  /*!< MASK_HW_DISABLE (Bit 6)                               */
#define PWM_DAC_OP_RATE2_MASK_HW_DISABLE_Msk (0x40UL)               /*!< MASK_HW_DISABLE (Bitfield-Mask: 0x01)                 */
#define PWM_DAC_OP_RATE2_DISABLE_VAL_Pos  (5UL)                     /*!< DISABLE_VAL (Bit 5)                                   */
#define PWM_DAC_OP_RATE2_DISABLE_VAL_Msk  (0x20UL)                  /*!< DISABLE_VAL (Bitfield-Mask: 0x01)                     */
#define PWM_DAC_OP_RATE2_EN_Pos           (4UL)                     /*!< EN (Bit 4)                                            */
#define PWM_DAC_OP_RATE2_EN_Msk           (0x10UL)                  /*!< EN (Bitfield-Mask: 0x01)                              */
#define PWM_DAC_OP_RATE2_OP_RATE_Pos      (0UL)                     /*!< OP_RATE (Bit 0)                                       */
#define PWM_DAC_OP_RATE2_OP_RATE_Msk      (0xfUL)                   /*!< OP_RATE (Bitfield-Mask: 0x0f)                         */
/* =========================================================  RATE2  ========================================================= */
#define PWM_DAC_RATE2_RATE_Pos            (0UL)                     /*!< RATE (Bit 0)                                          */
#define PWM_DAC_RATE2_RATE_Msk            (0x3ffUL)                 /*!< RATE (Bitfield-Mask: 0x3ff)                           */
/* =======================================================  OP_RATE3  ======================================================== */
#define PWM_DAC_OP_RATE3_MASK_HW_DISABLE_Pos (6UL)                  /*!< MASK_HW_DISABLE (Bit 6)                               */
#define PWM_DAC_OP_RATE3_MASK_HW_DISABLE_Msk (0x40UL)               /*!< MASK_HW_DISABLE (Bitfield-Mask: 0x01)                 */
#define PWM_DAC_OP_RATE3_DISABLE_VAL_Pos  (5UL)                     /*!< DISABLE_VAL (Bit 5)                                   */
#define PWM_DAC_OP_RATE3_DISABLE_VAL_Msk  (0x20UL)                  /*!< DISABLE_VAL (Bitfield-Mask: 0x01)                     */
#define PWM_DAC_OP_RATE3_EN_Pos           (4UL)                     /*!< EN (Bit 4)                                            */
#define PWM_DAC_OP_RATE3_EN_Msk           (0x10UL)                  /*!< EN (Bitfield-Mask: 0x01)                              */
#define PWM_DAC_OP_RATE3_OP_RATE_Pos      (0UL)                     /*!< OP_RATE (Bit 0)                                       */
#define PWM_DAC_OP_RATE3_OP_RATE_Msk      (0xfUL)                   /*!< OP_RATE (Bitfield-Mask: 0x0f)                         */
/* =========================================================  RATE3  ========================================================= */
#define PWM_DAC_RATE3_RATE_Pos            (0UL)                     /*!< RATE (Bit 0)                                          */
#define PWM_DAC_RATE3_RATE_Msk            (0x3ffUL)                 /*!< RATE (Bitfield-Mask: 0x3ff)                           */


/* =========================================================================================================================== */
/* ================                                        PMP_IO_CFG                                         ================ */
/* =========================================================================================================================== */

/* =========================================================  CS_N0  ========================================================= */
#define PMP_IO_CFG_CS_N0_IO_CFG_IE_FLASH0_CS_N0_Pos (6UL)           /*!< IO_CFG_IE_FLASH0_CS_N0 (Bit 6)                        */
#define PMP_IO_CFG_CS_N0_IO_CFG_IE_FLASH0_CS_N0_Msk (0x40UL)        /*!< IO_CFG_IE_FLASH0_CS_N0 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N0_IO_CFG_IS_FLASH0_CS_N0_Pos (5UL)           /*!< IO_CFG_IS_FLASH0_CS_N0 (Bit 5)                        */
#define PMP_IO_CFG_CS_N0_IO_CFG_IS_FLASH0_CS_N0_Msk (0x20UL)        /*!< IO_CFG_IS_FLASH0_CS_N0 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N0_IO_CFG_SR_FLASH0_CS_N0_Pos (4UL)           /*!< IO_CFG_SR_FLASH0_CS_N0 (Bit 4)                        */
#define PMP_IO_CFG_CS_N0_IO_CFG_SR_FLASH0_CS_N0_Msk (0x10UL)        /*!< IO_CFG_SR_FLASH0_CS_N0 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N0_IO_CFG_PE_FLASH0_CS_N0_Pos (3UL)           /*!< IO_CFG_PE_FLASH0_CS_N0 (Bit 3)                        */
#define PMP_IO_CFG_CS_N0_IO_CFG_PE_FLASH0_CS_N0_Msk (0x8UL)         /*!< IO_CFG_PE_FLASH0_CS_N0 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N0_IO_CFG_PS_FLASH0_CS_N0_Pos (2UL)           /*!< IO_CFG_PS_FLASH0_CS_N0 (Bit 2)                        */
#define PMP_IO_CFG_CS_N0_IO_CFG_PS_FLASH0_CS_N0_Msk (0x4UL)         /*!< IO_CFG_PS_FLASH0_CS_N0 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N0_IO_CFG_DS0_FLASH0_CS_N0_Pos (1UL)          /*!< IO_CFG_DS0_FLASH0_CS_N0 (Bit 1)                       */
#define PMP_IO_CFG_CS_N0_IO_CFG_DS0_FLASH0_CS_N0_Msk (0x2UL)        /*!< IO_CFG_DS0_FLASH0_CS_N0 (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_CS_N0_IO_CFG_DS1_FLASH0_CS_N0_Pos (0UL)          /*!< IO_CFG_DS1_FLASH0_CS_N0 (Bit 0)                       */
#define PMP_IO_CFG_CS_N0_IO_CFG_DS1_FLASH0_CS_N0_Msk (0x1UL)        /*!< IO_CFG_DS1_FLASH0_CS_N0 (Bitfield-Mask: 0x01)         */
/* =========================================================  CS_N1  ========================================================= */
#define PMP_IO_CFG_CS_N1_IO_CFG_IE_FLASH0_CS_N1_Pos (6UL)           /*!< IO_CFG_IE_FLASH0_CS_N1 (Bit 6)                        */
#define PMP_IO_CFG_CS_N1_IO_CFG_IE_FLASH0_CS_N1_Msk (0x40UL)        /*!< IO_CFG_IE_FLASH0_CS_N1 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N1_IO_CFG_IS_FLASH0_CS_N1_Pos (5UL)           /*!< IO_CFG_IS_FLASH0_CS_N1 (Bit 5)                        */
#define PMP_IO_CFG_CS_N1_IO_CFG_IS_FLASH0_CS_N1_Msk (0x20UL)        /*!< IO_CFG_IS_FLASH0_CS_N1 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N1_IO_CFG_SR_FLASH0_CS_N1_Pos (4UL)           /*!< IO_CFG_SR_FLASH0_CS_N1 (Bit 4)                        */
#define PMP_IO_CFG_CS_N1_IO_CFG_SR_FLASH0_CS_N1_Msk (0x10UL)        /*!< IO_CFG_SR_FLASH0_CS_N1 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N1_IO_CFG_PE_FLASH0_CS_N1_Pos (3UL)           /*!< IO_CFG_PE_FLASH0_CS_N1 (Bit 3)                        */
#define PMP_IO_CFG_CS_N1_IO_CFG_PE_FLASH0_CS_N1_Msk (0x8UL)         /*!< IO_CFG_PE_FLASH0_CS_N1 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N1_IO_CFG_PS_FLASH0_CS_N1_Pos (2UL)           /*!< IO_CFG_PS_FLASH0_CS_N1 (Bit 2)                        */
#define PMP_IO_CFG_CS_N1_IO_CFG_PS_FLASH0_CS_N1_Msk (0x4UL)         /*!< IO_CFG_PS_FLASH0_CS_N1 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N1_IO_CFG_DS0_FLASH0_CS_N1_Pos (1UL)          /*!< IO_CFG_DS0_FLASH0_CS_N1 (Bit 1)                       */
#define PMP_IO_CFG_CS_N1_IO_CFG_DS0_FLASH0_CS_N1_Msk (0x2UL)        /*!< IO_CFG_DS0_FLASH0_CS_N1 (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_CS_N1_IO_CFG_DS1_FLASH0_CS_N1_Pos (0UL)          /*!< IO_CFG_DS1_FLASH0_CS_N1 (Bit 0)                       */
#define PMP_IO_CFG_CS_N1_IO_CFG_DS1_FLASH0_CS_N1_Msk (0x1UL)        /*!< IO_CFG_DS1_FLASH0_CS_N1 (Bitfield-Mask: 0x01)         */
/* ==========================================================  SCK  ========================================================== */
#define PMP_IO_CFG_SCK_IO_CFG_IE_FLASH0_SCK_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_SCK (Bit 6)                          */
#define PMP_IO_CFG_SCK_IO_CFG_IE_FLASH0_SCK_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_SCK (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_SCK_IO_CFG_IS_FLASH0_SCK_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_SCK (Bit 5)                          */
#define PMP_IO_CFG_SCK_IO_CFG_IS_FLASH0_SCK_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_SCK (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_SCK_IO_CFG_SR_FLASH0_SCK_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_SCK (Bit 4)                          */
#define PMP_IO_CFG_SCK_IO_CFG_SR_FLASH0_SCK_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_SCK (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_SCK_IO_CFG_PE_FLASH0_SCK_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_SCK (Bit 3)                          */
#define PMP_IO_CFG_SCK_IO_CFG_PE_FLASH0_SCK_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_SCK (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_SCK_IO_CFG_PS_FLASH0_SCK_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_SCK (Bit 2)                          */
#define PMP_IO_CFG_SCK_IO_CFG_PS_FLASH0_SCK_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_SCK (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_SCK_IO_CFG_DS0_FLASH0_SCK_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_SCK (Bit 1)                         */
#define PMP_IO_CFG_SCK_IO_CFG_DS0_FLASH0_SCK_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_SCK (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_SCK_IO_CFG_DS1_FLASH0_SCK_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_SCK (Bit 0)                         */
#define PMP_IO_CFG_SCK_IO_CFG_DS1_FLASH0_SCK_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_SCK (Bitfield-Mask: 0x01)           */
/* ========================================================  RESETN  ========================================================= */
#define PMP_IO_CFG_RESETN_IO_CFG_IE_FLASH0_RESETN_Pos (6UL)         /*!< IO_CFG_IE_FLASH0_RESETN (Bit 6)                       */
#define PMP_IO_CFG_RESETN_IO_CFG_IE_FLASH0_RESETN_Msk (0x40UL)      /*!< IO_CFG_IE_FLASH0_RESETN (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_RESETN_IO_CFG_IS_FLASH0_RESETN_Pos (5UL)         /*!< IO_CFG_IS_FLASH0_RESETN (Bit 5)                       */
#define PMP_IO_CFG_RESETN_IO_CFG_IS_FLASH0_RESETN_Msk (0x20UL)      /*!< IO_CFG_IS_FLASH0_RESETN (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_RESETN_IO_CFG_SR_FLASH0_RESETN_Pos (4UL)         /*!< IO_CFG_SR_FLASH0_RESETN (Bit 4)                       */
#define PMP_IO_CFG_RESETN_IO_CFG_SR_FLASH0_RESETN_Msk (0x10UL)      /*!< IO_CFG_SR_FLASH0_RESETN (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_RESETN_IO_CFG_PE_FLASH0_RESETN_Pos (3UL)         /*!< IO_CFG_PE_FLASH0_RESETN (Bit 3)                       */
#define PMP_IO_CFG_RESETN_IO_CFG_PE_FLASH0_RESETN_Msk (0x8UL)       /*!< IO_CFG_PE_FLASH0_RESETN (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_RESETN_IO_CFG_PS_FLASH0_RESETN_Pos (2UL)         /*!< IO_CFG_PS_FLASH0_RESETN (Bit 2)                       */
#define PMP_IO_CFG_RESETN_IO_CFG_PS_FLASH0_RESETN_Msk (0x4UL)       /*!< IO_CFG_PS_FLASH0_RESETN (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_RESETN_IO_CFG_DS0_FLASH0_RESETN_Pos (1UL)        /*!< IO_CFG_DS0_FLASH0_RESETN (Bit 1)                      */
#define PMP_IO_CFG_RESETN_IO_CFG_DS0_FLASH0_RESETN_Msk (0x2UL)      /*!< IO_CFG_DS0_FLASH0_RESETN (Bitfield-Mask: 0x01)        */
#define PMP_IO_CFG_RESETN_IO_CFG_DS1_FLASH0_RESETN_Pos (0UL)        /*!< IO_CFG_DS1_FLASH0_RESETN (Bit 0)                      */
#define PMP_IO_CFG_RESETN_IO_CFG_DS1_FLASH0_RESETN_Msk (0x1UL)      /*!< IO_CFG_DS1_FLASH0_RESETN (Bitfield-Mask: 0x01)        */
/* ==========================================================  DQS  ========================================================== */
#define PMP_IO_CFG_DQS_IO_CFG_IE_FLASH0_DQS_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_DQS (Bit 6)                          */
#define PMP_IO_CFG_DQS_IO_CFG_IE_FLASH0_DQS_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_DQS (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_DQS_IO_CFG_IS_FLASH0_DQS_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_DQS (Bit 5)                          */
#define PMP_IO_CFG_DQS_IO_CFG_IS_FLASH0_DQS_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_DQS (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_DQS_IO_CFG_SR_FLASH0_DQS_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_DQS (Bit 4)                          */
#define PMP_IO_CFG_DQS_IO_CFG_SR_FLASH0_DQS_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_DQS (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_DQS_IO_CFG_PE_FLASH0_DQS_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_DQS (Bit 3)                          */
#define PMP_IO_CFG_DQS_IO_CFG_PE_FLASH0_DQS_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_DQS (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_DQS_IO_CFG_PS_FLASH0_DQS_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_DQS (Bit 2)                          */
#define PMP_IO_CFG_DQS_IO_CFG_PS_FLASH0_DQS_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_DQS (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_DQS_IO_CFG_DS0_FLASH0_DQS_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_DQS (Bit 1)                         */
#define PMP_IO_CFG_DQS_IO_CFG_DS0_FLASH0_DQS_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_DQS (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_DQS_IO_CFG_DS1_FLASH0_DQS_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_DQS (Bit 0)                         */
#define PMP_IO_CFG_DQS_IO_CFG_DS1_FLASH0_DQS_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_DQS (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO0  ========================================================== */
#define PMP_IO_CFG_IO0_IO_CFG_IE_FLASH0_IO0_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO0 (Bit 6)                          */
#define PMP_IO_CFG_IO0_IO_CFG_IE_FLASH0_IO0_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO0 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO0_IO_CFG_IS_FLASH0_IO0_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO0 (Bit 5)                          */
#define PMP_IO_CFG_IO0_IO_CFG_IS_FLASH0_IO0_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO0 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO0_IO_CFG_SR_FLASH0_IO0_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO0 (Bit 4)                          */
#define PMP_IO_CFG_IO0_IO_CFG_SR_FLASH0_IO0_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO0 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO0_IO_CFG_PE_FLASH0_IO0_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO0 (Bit 3)                          */
#define PMP_IO_CFG_IO0_IO_CFG_PE_FLASH0_IO0_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO0 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO0_IO_CFG_PS_FLASH0_IO0_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO0 (Bit 2)                          */
#define PMP_IO_CFG_IO0_IO_CFG_PS_FLASH0_IO0_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO0 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO0_IO_CFG_DS0_FLASH0_IO0_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO0 (Bit 1)                         */
#define PMP_IO_CFG_IO0_IO_CFG_DS0_FLASH0_IO0_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO0 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO0_IO_CFG_DS1_FLASH0_IO0_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO0 (Bit 0)                         */
#define PMP_IO_CFG_IO0_IO_CFG_DS1_FLASH0_IO0_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO0 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO1  ========================================================== */
#define PMP_IO_CFG_IO1_IO_CFG_IE_FLASH0_IO1_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO1 (Bit 6)                          */
#define PMP_IO_CFG_IO1_IO_CFG_IE_FLASH0_IO1_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO1 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO1_IO_CFG_IS_FLASH0_IO1_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO1 (Bit 5)                          */
#define PMP_IO_CFG_IO1_IO_CFG_IS_FLASH0_IO1_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO1 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO1_IO_CFG_SR_FLASH0_IO1_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO1 (Bit 4)                          */
#define PMP_IO_CFG_IO1_IO_CFG_SR_FLASH0_IO1_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO1 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO1_IO_CFG_PE_FLASH0_IO1_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO1 (Bit 3)                          */
#define PMP_IO_CFG_IO1_IO_CFG_PE_FLASH0_IO1_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO1 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO1_IO_CFG_PS_FLASH0_IO1_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO1 (Bit 2)                          */
#define PMP_IO_CFG_IO1_IO_CFG_PS_FLASH0_IO1_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO1 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO1_IO_CFG_DS0_FLASH0_IO1_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO1 (Bit 1)                         */
#define PMP_IO_CFG_IO1_IO_CFG_DS0_FLASH0_IO1_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO1 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO1_IO_CFG_DS1_FLASH0_IO1_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO1 (Bit 0)                         */
#define PMP_IO_CFG_IO1_IO_CFG_DS1_FLASH0_IO1_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO1 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO2  ========================================================== */
#define PMP_IO_CFG_IO2_IO_CFG_IE_FLASH0_IO2_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO2 (Bit 6)                          */
#define PMP_IO_CFG_IO2_IO_CFG_IE_FLASH0_IO2_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO2 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO2_IO_CFG_IS_FLASH0_IO2_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO2 (Bit 5)                          */
#define PMP_IO_CFG_IO2_IO_CFG_IS_FLASH0_IO2_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO2 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO2_IO_CFG_SR_FLASH0_IO2_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO2 (Bit 4)                          */
#define PMP_IO_CFG_IO2_IO_CFG_SR_FLASH0_IO2_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO2 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO2_IO_CFG_PE_FLASH0_IO2_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO2 (Bit 3)                          */
#define PMP_IO_CFG_IO2_IO_CFG_PE_FLASH0_IO2_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO2 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO2_IO_CFG_PS_FLASH0_IO2_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO2 (Bit 2)                          */
#define PMP_IO_CFG_IO2_IO_CFG_PS_FLASH0_IO2_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO2 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO2_IO_CFG_DS0_FLASH0_IO2_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO2 (Bit 1)                         */
#define PMP_IO_CFG_IO2_IO_CFG_DS0_FLASH0_IO2_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO2 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO2_IO_CFG_DS1_FLASH0_IO2_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO2 (Bit 0)                         */
#define PMP_IO_CFG_IO2_IO_CFG_DS1_FLASH0_IO2_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO2 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO3  ========================================================== */
#define PMP_IO_CFG_IO3_IO_CFG_IE_FLASH0_IO3_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO3 (Bit 6)                          */
#define PMP_IO_CFG_IO3_IO_CFG_IE_FLASH0_IO3_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO3 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO3_IO_CFG_IS_FLASH0_IO3_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO3 (Bit 5)                          */
#define PMP_IO_CFG_IO3_IO_CFG_IS_FLASH0_IO3_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO3 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO3_IO_CFG_SR_FLASH0_IO3_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO3 (Bit 4)                          */
#define PMP_IO_CFG_IO3_IO_CFG_SR_FLASH0_IO3_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO3 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO3_IO_CFG_PE_FLASH0_IO3_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO3 (Bit 3)                          */
#define PMP_IO_CFG_IO3_IO_CFG_PE_FLASH0_IO3_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO3 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO3_IO_CFG_PS_FLASH0_IO3_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO3 (Bit 2)                          */
#define PMP_IO_CFG_IO3_IO_CFG_PS_FLASH0_IO3_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO3 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO3_IO_CFG_DS0_FLASH0_IO3_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO3 (Bit 1)                         */
#define PMP_IO_CFG_IO3_IO_CFG_DS0_FLASH0_IO3_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO3 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO3_IO_CFG_DS1_FLASH0_IO3_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO3 (Bit 0)                         */
#define PMP_IO_CFG_IO3_IO_CFG_DS1_FLASH0_IO3_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO3 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO4  ========================================================== */
#define PMP_IO_CFG_IO4_IO_CFG_IE_FLASH0_IO4_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO4 (Bit 6)                          */
#define PMP_IO_CFG_IO4_IO_CFG_IE_FLASH0_IO4_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO4 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO4_IO_CFG_IS_FLASH0_IO4_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO4 (Bit 5)                          */
#define PMP_IO_CFG_IO4_IO_CFG_IS_FLASH0_IO4_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO4 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO4_IO_CFG_SR_FLASH0_IO4_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO4 (Bit 4)                          */
#define PMP_IO_CFG_IO4_IO_CFG_SR_FLASH0_IO4_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO4 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO4_IO_CFG_PE_FLASH0_IO4_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO4 (Bit 3)                          */
#define PMP_IO_CFG_IO4_IO_CFG_PE_FLASH0_IO4_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO4 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO4_IO_CFG_PS_FLASH0_IO4_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO4 (Bit 2)                          */
#define PMP_IO_CFG_IO4_IO_CFG_PS_FLASH0_IO4_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO4 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO4_IO_CFG_DS0_FLASH0_IO4_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO4 (Bit 1)                         */
#define PMP_IO_CFG_IO4_IO_CFG_DS0_FLASH0_IO4_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO4 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO4_IO_CFG_DS1_FLASH0_IO4_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO4 (Bit 0)                         */
#define PMP_IO_CFG_IO4_IO_CFG_DS1_FLASH0_IO4_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO4 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO5  ========================================================== */
#define PMP_IO_CFG_IO5_IO_CFG_IE_FLASH0_IO5_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO5 (Bit 6)                          */
#define PMP_IO_CFG_IO5_IO_CFG_IE_FLASH0_IO5_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO5 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO5_IO_CFG_IS_FLASH0_IO5_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO5 (Bit 5)                          */
#define PMP_IO_CFG_IO5_IO_CFG_IS_FLASH0_IO5_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO5 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO5_IO_CFG_SR_FLASH0_IO5_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO5 (Bit 4)                          */
#define PMP_IO_CFG_IO5_IO_CFG_SR_FLASH0_IO5_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO5 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO5_IO_CFG_PE_FLASH0_IO5_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO5 (Bit 3)                          */
#define PMP_IO_CFG_IO5_IO_CFG_PE_FLASH0_IO5_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO5 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO5_IO_CFG_PS_FLASH0_IO5_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO5 (Bit 2)                          */
#define PMP_IO_CFG_IO5_IO_CFG_PS_FLASH0_IO5_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO5 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO5_IO_CFG_DS0_FLASH0_IO5_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO5 (Bit 1)                         */
#define PMP_IO_CFG_IO5_IO_CFG_DS0_FLASH0_IO5_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO5 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO5_IO_CFG_DS1_FLASH0_IO5_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO5 (Bit 0)                         */
#define PMP_IO_CFG_IO5_IO_CFG_DS1_FLASH0_IO5_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO5 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO6  ========================================================== */
#define PMP_IO_CFG_IO6_IO_CFG_IE_FLASH0_IO6_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO6 (Bit 6)                          */
#define PMP_IO_CFG_IO6_IO_CFG_IE_FLASH0_IO6_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO6 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO6_IO_CFG_IS_FLASH0_IO6_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO6 (Bit 5)                          */
#define PMP_IO_CFG_IO6_IO_CFG_IS_FLASH0_IO6_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO6 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO6_IO_CFG_SR_FLASH0_IO6_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO6 (Bit 4)                          */
#define PMP_IO_CFG_IO6_IO_CFG_SR_FLASH0_IO6_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO6 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO6_IO_CFG_PE_FLASH0_IO6_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO6 (Bit 3)                          */
#define PMP_IO_CFG_IO6_IO_CFG_PE_FLASH0_IO6_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO6 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO6_IO_CFG_PS_FLASH0_IO6_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO6 (Bit 2)                          */
#define PMP_IO_CFG_IO6_IO_CFG_PS_FLASH0_IO6_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO6 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO6_IO_CFG_DS0_FLASH0_IO6_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO6 (Bit 1)                         */
#define PMP_IO_CFG_IO6_IO_CFG_DS0_FLASH0_IO6_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO6 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO6_IO_CFG_DS1_FLASH0_IO6_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO6 (Bit 0)                         */
#define PMP_IO_CFG_IO6_IO_CFG_DS1_FLASH0_IO6_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO6 (Bitfield-Mask: 0x01)           */
/* ==========================================================  IO7  ========================================================== */
#define PMP_IO_CFG_IO7_IO_CFG_IE_FLASH0_IO7_Pos (6UL)               /*!< IO_CFG_IE_FLASH0_IO7 (Bit 6)                          */
#define PMP_IO_CFG_IO7_IO_CFG_IE_FLASH0_IO7_Msk (0x40UL)            /*!< IO_CFG_IE_FLASH0_IO7 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO7_IO_CFG_IS_FLASH0_IO7_Pos (5UL)               /*!< IO_CFG_IS_FLASH0_IO7 (Bit 5)                          */
#define PMP_IO_CFG_IO7_IO_CFG_IS_FLASH0_IO7_Msk (0x20UL)            /*!< IO_CFG_IS_FLASH0_IO7 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO7_IO_CFG_SR_FLASH0_IO7_Pos (4UL)               /*!< IO_CFG_SR_FLASH0_IO7 (Bit 4)                          */
#define PMP_IO_CFG_IO7_IO_CFG_SR_FLASH0_IO7_Msk (0x10UL)            /*!< IO_CFG_SR_FLASH0_IO7 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO7_IO_CFG_PE_FLASH0_IO7_Pos (3UL)               /*!< IO_CFG_PE_FLASH0_IO7 (Bit 3)                          */
#define PMP_IO_CFG_IO7_IO_CFG_PE_FLASH0_IO7_Msk (0x8UL)             /*!< IO_CFG_PE_FLASH0_IO7 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO7_IO_CFG_PS_FLASH0_IO7_Pos (2UL)               /*!< IO_CFG_PS_FLASH0_IO7 (Bit 2)                          */
#define PMP_IO_CFG_IO7_IO_CFG_PS_FLASH0_IO7_Msk (0x4UL)             /*!< IO_CFG_PS_FLASH0_IO7 (Bitfield-Mask: 0x01)            */
#define PMP_IO_CFG_IO7_IO_CFG_DS0_FLASH0_IO7_Pos (1UL)              /*!< IO_CFG_DS0_FLASH0_IO7 (Bit 1)                         */
#define PMP_IO_CFG_IO7_IO_CFG_DS0_FLASH0_IO7_Msk (0x2UL)            /*!< IO_CFG_DS0_FLASH0_IO7 (Bitfield-Mask: 0x01)           */
#define PMP_IO_CFG_IO7_IO_CFG_DS1_FLASH0_IO7_Pos (0UL)              /*!< IO_CFG_DS1_FLASH0_IO7 (Bit 0)                         */
#define PMP_IO_CFG_IO7_IO_CFG_DS1_FLASH0_IO7_Msk (0x1UL)            /*!< IO_CFG_DS1_FLASH0_IO7 (Bitfield-Mask: 0x01)           */
/* =========================================================  CS_N2  ========================================================= */
#define PMP_IO_CFG_CS_N2_IO_CFG_IE_FLASH0_CS_N2_Pos (6UL)           /*!< IO_CFG_IE_FLASH0_CS_N2 (Bit 6)                        */
#define PMP_IO_CFG_CS_N2_IO_CFG_IE_FLASH0_CS_N2_Msk (0x40UL)        /*!< IO_CFG_IE_FLASH0_CS_N2 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N2_IO_CFG_IS_FLASH0_CS_N2_Pos (5UL)           /*!< IO_CFG_IS_FLASH0_CS_N2 (Bit 5)                        */
#define PMP_IO_CFG_CS_N2_IO_CFG_IS_FLASH0_CS_N2_Msk (0x20UL)        /*!< IO_CFG_IS_FLASH0_CS_N2 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N2_IO_CFG_SR_FLASH0_CS_N2_Pos (4UL)           /*!< IO_CFG_SR_FLASH0_CS_N2 (Bit 4)                        */
#define PMP_IO_CFG_CS_N2_IO_CFG_SR_FLASH0_CS_N2_Msk (0x10UL)        /*!< IO_CFG_SR_FLASH0_CS_N2 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N2_IO_CFG_PE_FLASH0_CS_N2_Pos (3UL)           /*!< IO_CFG_PE_FLASH0_CS_N2 (Bit 3)                        */
#define PMP_IO_CFG_CS_N2_IO_CFG_PE_FLASH0_CS_N2_Msk (0x8UL)         /*!< IO_CFG_PE_FLASH0_CS_N2 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N2_IO_CFG_PS_FLASH0_CS_N2_Pos (2UL)           /*!< IO_CFG_PS_FLASH0_CS_N2 (Bit 2)                        */
#define PMP_IO_CFG_CS_N2_IO_CFG_PS_FLASH0_CS_N2_Msk (0x4UL)         /*!< IO_CFG_PS_FLASH0_CS_N2 (Bitfield-Mask: 0x01)          */
#define PMP_IO_CFG_CS_N2_IO_CFG_DS0_FLASH0_CS_N2_Pos (1UL)          /*!< IO_CFG_DS0_FLASH0_CS_N2 (Bit 1)                       */
#define PMP_IO_CFG_CS_N2_IO_CFG_DS0_FLASH0_CS_N2_Msk (0x2UL)        /*!< IO_CFG_DS0_FLASH0_CS_N2 (Bitfield-Mask: 0x01)         */
#define PMP_IO_CFG_CS_N2_IO_CFG_DS1_FLASH0_CS_N2_Pos (0UL)          /*!< IO_CFG_DS1_FLASH0_CS_N2 (Bit 0)                       */
#define PMP_IO_CFG_CS_N2_IO_CFG_DS1_FLASH0_CS_N2_Msk (0x1UL)        /*!< IO_CFG_DS1_FLASH0_CS_N2 (Bitfield-Mask: 0x01)         */


/* =========================================================================================================================== */
/* ================                                        PMP_IO_PAR                                         ================ */
/* =========================================================================================================================== */

/* =========================================================  CS_N0  ========================================================= */
#define PMP_IO_PAR_CS_N0_CS_N0_Pos        (0UL)                     /*!< CS_N0 (Bit 0)                                         */
#define PMP_IO_PAR_CS_N0_CS_N0_Msk        (0x3UL)                   /*!< CS_N0 (Bitfield-Mask: 0x03)                           */
/* =========================================================  CS_N1  ========================================================= */
#define PMP_IO_PAR_CS_N1_CS_N1_Pos        (0UL)                     /*!< CS_N1 (Bit 0)                                         */
#define PMP_IO_PAR_CS_N1_CS_N1_Msk        (0x3UL)                   /*!< CS_N1 (Bitfield-Mask: 0x03)                           */
/* ==========================================================  SCK  ========================================================== */
#define PMP_IO_PAR_SCK_SCK_Pos            (0UL)                     /*!< SCK (Bit 0)                                           */
#define PMP_IO_PAR_SCK_SCK_Msk            (0x3UL)                   /*!< SCK (Bitfield-Mask: 0x03)                             */
/* ========================================================  RESETN  ========================================================= */
#define PMP_IO_PAR_RESETN_RESETN_Pos      (0UL)                     /*!< RESETN (Bit 0)                                        */
#define PMP_IO_PAR_RESETN_RESETN_Msk      (0x3UL)                   /*!< RESETN (Bitfield-Mask: 0x03)                          */
/* ==========================================================  DQS  ========================================================== */
#define PMP_IO_PAR_DQS_DQS_Pos            (0UL)                     /*!< DQS (Bit 0)                                           */
#define PMP_IO_PAR_DQS_DQS_Msk            (0x3UL)                   /*!< DQS (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO0  ========================================================== */
#define PMP_IO_PAR_IO0_IO0_Pos            (0UL)                     /*!< IO0 (Bit 0)                                           */
#define PMP_IO_PAR_IO0_IO0_Msk            (0x3UL)                   /*!< IO0 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO1  ========================================================== */
#define PMP_IO_PAR_IO1_IO1_Pos            (0UL)                     /*!< IO1 (Bit 0)                                           */
#define PMP_IO_PAR_IO1_IO1_Msk            (0x3UL)                   /*!< IO1 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO2  ========================================================== */
#define PMP_IO_PAR_IO2_IO2_Pos            (0UL)                     /*!< IO2 (Bit 0)                                           */
#define PMP_IO_PAR_IO2_IO2_Msk            (0x3UL)                   /*!< IO2 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO3  ========================================================== */
#define PMP_IO_PAR_IO3_IO3_Pos            (0UL)                     /*!< IO3 (Bit 0)                                           */
#define PMP_IO_PAR_IO3_IO3_Msk            (0x3UL)                   /*!< IO3 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO4  ========================================================== */
#define PMP_IO_PAR_IO4_IO4_Pos            (0UL)                     /*!< IO4 (Bit 0)                                           */
#define PMP_IO_PAR_IO4_IO4_Msk            (0x3UL)                   /*!< IO4 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO5  ========================================================== */
#define PMP_IO_PAR_IO5_IO5_Pos            (0UL)                     /*!< IO5 (Bit 0)                                           */
#define PMP_IO_PAR_IO5_IO5_Msk            (0x3UL)                   /*!< IO5 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO6  ========================================================== */
#define PMP_IO_PAR_IO6_IO6_Pos            (0UL)                     /*!< IO6 (Bit 0)                                           */
#define PMP_IO_PAR_IO6_IO6_Msk            (0x3UL)                   /*!< IO6 (Bitfield-Mask: 0x03)                             */
/* ==========================================================  IO7  ========================================================== */
#define PMP_IO_PAR_IO7_IO7_Pos            (0UL)                     /*!< IO7 (Bit 0)                                           */
#define PMP_IO_PAR_IO7_IO7_Msk            (0x3UL)                   /*!< IO7 (Bitfield-Mask: 0x03)                             */
/* =========================================================  CS_N2  ========================================================= */
#define PMP_IO_PAR_CS_N2_CS_N2_Pos        (0UL)                     /*!< CS_N2 (Bit 0)                                         */
#define PMP_IO_PAR_CS_N2_CS_N2_Msk        (0x3UL)                   /*!< CS_N2 (Bitfield-Mask: 0x03)                           */


/* =========================================================================================================================== */
/* ================                                 SERIAL_FLASH_CTRL_MANUAL                                  ================ */
/* =========================================================================================================================== */

/* ========================================================  CS_SEL  ========================================================= */
#define SERIAL_FLASH_CTRL_MANUAL_CS_SEL_CS_BY_ADDR_Pos (1UL)        /*!< CS_BY_ADDR (Bit 1)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CS_SEL_CS_BY_ADDR_Msk (0x6UL)      /*!< CS_BY_ADDR (Bitfield-Mask: 0x03)                      */
#define SERIAL_FLASH_CTRL_MANUAL_CS_SEL_CS_SEL_Pos (0UL)            /*!< CS_SEL (Bit 0)                                        */
#define SERIAL_FLASH_CTRL_MANUAL_CS_SEL_CS_SEL_Msk (0x1UL)          /*!< CS_SEL (Bitfield-Mask: 0x01)                          */
/* ==========================================================  CMD  ========================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DIRECTION_Pos (15UL)           /*!< DIRECTION (Bit 15)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DIRECTION_Msk (0x8000UL)       /*!< DIRECTION (Bitfield-Mask: 0x01)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_INT_EN_Pos (14UL)              /*!< INT_EN (Bit 14)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_INT_EN_Msk (0x4000UL)          /*!< INT_EN (Bitfield-Mask: 0x01)                          */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DATA_SIZE_Pos (11UL)           /*!< DATA_SIZE (Bit 11)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DATA_SIZE_Msk (0x3800UL)       /*!< DATA_SIZE (Bitfield-Mask: 0x07)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_SIZE_Pos (8UL)            /*!< ADDR_SIZE (Bit 8)                                     */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_SIZE_Msk (0x700UL)        /*!< ADDR_SIZE (Bitfield-Mask: 0x07)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_CMD_OPCODE_Pos (0UL)           /*!< CMD_OPCODE (Bit 0)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_CMD_OPCODE_Msk (0xffUL)        /*!< CMD_OPCODE (Bitfield-Mask: 0xff)                      */
/* ========================================================  CMD_16  ========================================================= */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_DIRECTION_Pos (23UL)        /*!< DIRECTION (Bit 23)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_DIRECTION_Msk (0x800000UL)  /*!< DIRECTION (Bitfield-Mask: 0x01)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_INT_EN_Pos (22UL)           /*!< INT_EN (Bit 22)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_INT_EN_Msk (0x400000UL)     /*!< INT_EN (Bitfield-Mask: 0x01)                          */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_DATA_SIZE_Pos (19UL)        /*!< DATA_SIZE (Bit 19)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_DATA_SIZE_Msk (0x380000UL)  /*!< DATA_SIZE (Bitfield-Mask: 0x07)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_ADDR_SIZE_Pos (16UL)        /*!< ADDR_SIZE (Bit 16)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_ADDR_SIZE_Msk (0x70000UL)   /*!< ADDR_SIZE (Bitfield-Mask: 0x07)                       */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_CMD_OPCODE_Pos (0UL)        /*!< CMD_OPCODE (Bit 0)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_16_CMD_OPCODE_Msk (0xffffUL)   /*!< CMD_OPCODE (Bitfield-Mask: 0xffff)                    */
/* =======================================================  CMD_ADDR  ======================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_DATA_BYTE_EN_Pos (28UL) /*!< CMD_DATA_BYTE_EN (Bit 28)                           */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_DATA_BYTE_EN_Msk (0xf0000000UL) /*!< CMD_DATA_BYTE_EN (Bitfield-Mask: 0x0f)      */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_PSRAM_EN_Pos (27UL)   /*!< CMD_PSRAM_EN (Bit 27)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_PSRAM_EN_Msk (0x8000000UL) /*!< CMD_PSRAM_EN (Bitfield-Mask: 0x01)               */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_ADDR_Pos (0UL)        /*!< CMD_ADDR (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_ADDR_CMD_ADDR_Msk (0x3ffffffUL) /*!< CMD_ADDR (Bitfield-Mask: 0x3ffffff)                  */
/* =======================================================  CMD_DATA  ======================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DATA_CMD_DATA_Pos (0UL)        /*!< CMD_DATA (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_DATA_CMD_DATA_Msk (0xffffffffUL) /*!< CMD_DATA (Bitfield-Mask: 0xffffffff)                */
/* ======================================================  CMD_RESULT0  ====================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_RESULT0_CMD_RESULT0_Pos (0UL)  /*!< CMD_RESULT0 (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_RESULT0_CMD_RESULT0_Msk (0xffffffffUL) /*!< CMD_RESULT0 (Bitfield-Mask: 0xffffffff)       */
/* ======================================================  CMD_RESULT1  ====================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_RESULT1_CMD_RESULT1_Pos (0UL)  /*!< CMD_RESULT1 (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_MANUAL_CMD_RESULT1_CMD_RESULT1_Msk (0xffffffffUL) /*!< CMD_RESULT1 (Bitfield-Mask: 0xffffffff)       */
/* ====================================================  INT_DATA_VALUE  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_INT_DATA_VALUE_INT_DATA_VALUE_Pos (0UL) /*!< INT_DATA_VALUE (Bit 0)                           */
#define SERIAL_FLASH_CTRL_MANUAL_INT_DATA_VALUE_INT_DATA_VALUE_Msk (0xffffffffUL) /*!< INT_DATA_VALUE (Bitfield-Mask: 0xffffffff) */
/* =====================================================  INT_DATA_MASK  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_INT_DATA_MASK_INT_DATA_MASK_Pos (0UL) /*!< INT_DATA_MASK (Bit 0)                              */
#define SERIAL_FLASH_CTRL_MANUAL_INT_DATA_MASK_INT_DATA_MASK_Msk (0xffffffffUL) /*!< INT_DATA_MASK (Bitfield-Mask: 0xffffffff) */
/* ========================================================  XIP_PAT  ======================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_EN_Pos (31UL)          /*!< XIP_EN (Bit 31)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_EN_Msk (0x80000000UL)  /*!< XIP_EN (Bitfield-Mask: 0x01)                          */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_PAT_DURING_XIP_Pos (30UL) /*!< XIP_PAT_DURING_XIP (Bit 30)                        */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_PAT_DURING_XIP_Msk (0x40000000UL) /*!< XIP_PAT_DURING_XIP (Bitfield-Mask: 0x01)   */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_OUT_PAT_SIZE_Pos (24UL) /*!< XIP_OUT_PAT_SIZE (Bit 24)                            */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_OUT_PAT_SIZE_Msk (0x7000000UL) /*!< XIP_OUT_PAT_SIZE (Bitfield-Mask: 0x07)        */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_OUT_PATTERN_Pos (16UL) /*!< XIP_OUT_PATTERN (Bit 16)                              */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_OUT_PATTERN_Msk (0xff0000UL) /*!< XIP_OUT_PATTERN (Bitfield-Mask: 0xff)           */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_IN_PAT_SIZE_Pos (8UL)  /*!< XIP_IN_PAT_SIZE (Bit 8)                               */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_IN_PAT_SIZE_Msk (0x700UL) /*!< XIP_IN_PAT_SIZE (Bitfield-Mask: 0x07)              */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_IN_PATTERN_Pos (0UL)   /*!< XIP_IN_PATTERN (Bit 0)                                */
#define SERIAL_FLASH_CTRL_MANUAL_XIP_PAT_XIP_IN_PATTERN_Msk (0xffUL) /*!< XIP_IN_PATTERN (Bitfield-Mask: 0xff)                 */
/* ====================================================  INTERRUPT_MASK  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_PERF_CNTR_MSB_Pos (3UL) /*!< PERF_CNTR_MSB (Bit 3)                             */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_PERF_CNTR_MSB_Msk (0x8UL) /*!< PERF_CNTR_MSB (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_CMD_RESULT1_Pos (2UL) /*!< CMD_RESULT1 (Bit 2)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_CMD_RESULT1_Msk (0x4UL) /*!< CMD_RESULT1 (Bitfield-Mask: 0x01)                 */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_CMD_RESULT0_Pos (1UL) /*!< CMD_RESULT0 (Bit 1)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_CMD_RESULT0_Msk (0x2UL) /*!< CMD_RESULT0 (Bitfield-Mask: 0x01)                 */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_SFCI_INT_Pos (0UL)  /*!< SFCI_INT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_INTERRUPT_MASK_SFCI_INT_Msk (0x1UL) /*!< SFCI_INT (Bitfield-Mask: 0x01)                       */
/* =========================================================  HALT  ========================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_HALT_SEL_Pos (0UL)                 /*!< SEL (Bit 0)                                           */
#define SERIAL_FLASH_CTRL_MANUAL_HALT_SEL_Msk (0x1UL)               /*!< SEL (Bitfield-Mask: 0x01)                             */
/* =====================================================  DUMMY_PATTERN  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_DUMMY_PATTERN_DUMMY_PATTERN_Pos (0UL) /*!< DUMMY_PATTERN (Bit 0)                              */
#define SERIAL_FLASH_CTRL_MANUAL_DUMMY_PATTERN_DUMMY_PATTERN_Msk (0xffffffffUL) /*!< DUMMY_PATTERN (Bitfield-Mask: 0xffffffff) */
/* ========================================================  STATUS  ========================================================= */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ER_WR_ACTIVE_AGENT_Pos (29UL) /*!< ER_WR_ACTIVE_AGENT (Bit 29)                         */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ER_WR_ACTIVE_AGENT_Msk (0xe0000000UL) /*!< ER_WR_ACTIVE_AGENT (Bitfield-Mask: 0x07)    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ER_WR_ACTIVE_Pos (28UL)     /*!< ER_WR_ACTIVE (Bit 28)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ER_WR_ACTIVE_Msk (0x10000000UL) /*!< ER_WR_ACTIVE (Bitfield-Mask: 0x01)                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_SUSPEN_ACTIVE_Pos (27UL)    /*!< SUSPEN_ACTIVE (Bit 27)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_SUSPEN_ACTIVE_Msk (0x8000000UL) /*!< SUSPEN_ACTIVE (Bitfield-Mask: 0x01)               */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RESUME_ACTIVE_Pos (26UL)    /*!< RESUME_ACTIVE (Bit 26)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RESUME_ACTIVE_Msk (0x4000000UL) /*!< RESUME_ACTIVE (Bitfield-Mask: 0x01)               */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ERASE_ACTIVE_Pos (25UL)     /*!< ERASE_ACTIVE (Bit 25)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_ERASE_ACTIVE_Msk (0x2000000UL) /*!< ERASE_ACTIVE (Bitfield-Mask: 0x01)                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_ACTIVE_Pos (24UL)        /*!< WR_ACTIVE (Bit 24)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_ACTIVE_Msk (0x1000000UL) /*!< WR_ACTIVE (Bitfield-Mask: 0x01)                       */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_PERF_MSB_FLIP_Pos (23UL)    /*!< PERF_MSB_FLIP (Bit 23)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_PERF_MSB_FLIP_Msk (0x800000UL) /*!< PERF_MSB_FLIP (Bitfield-Mask: 0x01)                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_FIFO_EMPTY_Pos (18UL)    /*!< WR_FIFO_EMPTY (Bit 18)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_FIFO_EMPTY_Msk (0x7c0000UL) /*!< WR_FIFO_EMPTY (Bitfield-Mask: 0x1f)                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_FIFO_FULL_Pos (13UL)     /*!< WR_FIFO_FULL (Bit 13)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_WR_FIFO_FULL_Msk (0x3e000UL) /*!< WR_FIFO_FULL (Bitfield-Mask: 0x1f)                   */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_MAIN_SM_Pos (8UL)           /*!< MAIN_SM (Bit 8)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_MAIN_SM_Msk (0x1f00UL)      /*!< MAIN_SM (Bitfield-Mask: 0x1f)                         */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_SM_Pos (4UL)                /*!< SM (Bit 4)                                            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_SM_Msk (0xf0UL)             /*!< SM (Bitfield-Mask: 0x0f)                              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_HALT_ACTIVE_Pos (3UL)       /*!< HALT_ACTIVE (Bit 3)                                   */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_HALT_ACTIVE_Msk (0x8UL)     /*!< HALT_ACTIVE (Bitfield-Mask: 0x01)                     */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_CMD_RESULT0_VALID_Pos (2UL) /*!< CMD_RESULT0_VALID (Bit 2)                             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_CMD_RESULT0_VALID_Msk (0x4UL) /*!< CMD_RESULT0_VALID (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_CMD_RESULT1_VALID_Pos (1UL) /*!< CMD_RESULT1_VALID (Bit 1)                             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_CMD_RESULT1_VALID_Msk (0x2UL) /*!< CMD_RESULT1_VALID (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_INT_STAT_Pos (0UL)          /*!< INT_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_INT_STAT_Msk (0x1UL)        /*!< INT_STAT (Bitfield-Mask: 0x01)                        */
/* =======================================================  STATUS_RC  ======================================================= */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ER_WR_ACTIVE_AGENT_Pos (29UL) /*!< ER_WR_ACTIVE_AGENT (Bit 29)                      */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ER_WR_ACTIVE_AGENT_Msk (0xe0000000UL) /*!< ER_WR_ACTIVE_AGENT (Bitfield-Mask: 0x07) */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ER_WR_ACTIVE_Pos (28UL)  /*!< ER_WR_ACTIVE (Bit 28)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ER_WR_ACTIVE_Msk (0x10000000UL) /*!< ER_WR_ACTIVE (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_SUSPEN_ACTIVE_Pos (27UL) /*!< SUSPEN_ACTIVE (Bit 27)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_SUSPEN_ACTIVE_Msk (0x8000000UL) /*!< SUSPEN_ACTIVE (Bitfield-Mask: 0x01)            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_RESUME_ACTIVE_Pos (26UL) /*!< RESUME_ACTIVE (Bit 26)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_RESUME_ACTIVE_Msk (0x4000000UL) /*!< RESUME_ACTIVE (Bitfield-Mask: 0x01)            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ERASE_ACTIVE_Pos (25UL)  /*!< ERASE_ACTIVE (Bit 25)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_ERASE_ACTIVE_Msk (0x2000000UL) /*!< ERASE_ACTIVE (Bitfield-Mask: 0x01)              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_ACTIVE_Pos (24UL)     /*!< WR_ACTIVE (Bit 24)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_ACTIVE_Msk (0x1000000UL) /*!< WR_ACTIVE (Bitfield-Mask: 0x01)                    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_PERF_MSB_FLIP_Pos (23UL) /*!< PERF_MSB_FLIP (Bit 23)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_PERF_MSB_FLIP_Msk (0x800000UL) /*!< PERF_MSB_FLIP (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_FIFO_EMPTY_Pos (18UL) /*!< WR_FIFO_EMPTY (Bit 18)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_FIFO_EMPTY_Msk (0x7c0000UL) /*!< WR_FIFO_EMPTY (Bitfield-Mask: 0x1f)             */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_FIFO_FULL_Pos (13UL)  /*!< WR_FIFO_FULL (Bit 13)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_WR_FIFO_FULL_Msk (0x3e000UL) /*!< WR_FIFO_FULL (Bitfield-Mask: 0x1f)                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_MAIN_SM_Pos (8UL)        /*!< MAIN_SM (Bit 8)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_MAIN_SM_Msk (0x1f00UL)   /*!< MAIN_SM (Bitfield-Mask: 0x1f)                         */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_SM_Pos (4UL)             /*!< SM (Bit 4)                                            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_SM_Msk (0xf0UL)          /*!< SM (Bitfield-Mask: 0x0f)                              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_HALT_ACTIVE_Pos (3UL)    /*!< HALT_ACTIVE (Bit 3)                                   */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_HALT_ACTIVE_Msk (0x8UL)  /*!< HALT_ACTIVE (Bitfield-Mask: 0x01)                     */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_CMD_RESULT0_VALID_Pos (2UL) /*!< CMD_RESULT0_VALID (Bit 2)                          */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_CMD_RESULT0_VALID_Msk (0x4UL) /*!< CMD_RESULT0_VALID (Bitfield-Mask: 0x01)          */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_CMD_RESULT1_VALID_Pos (1UL) /*!< CMD_RESULT1_VALID (Bit 1)                          */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_CMD_RESULT1_VALID_Msk (0x2UL) /*!< CMD_RESULT1_VALID (Bitfield-Mask: 0x01)          */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_INT_STAT_Pos (0UL)       /*!< INT_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS_RC_INT_STAT_Msk (0x1UL)     /*!< INT_STAT (Bitfield-Mask: 0x01)                        */
/* ======================================================  ERR_STATUS  ======================================================= */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_AGENT_Pos (27UL) /*!< WR_ERROR_AGENT (Bit 27)                             */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_AGENT_Msk (0x38000000UL) /*!< WR_ERROR_AGENT (Bitfield-Mask: 0x07)        */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_FIRST_ADDR_Pos (3UL) /*!< WR_ERROR_FIRST_ADDR (Bit 3)                     */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_FIRST_ADDR_Msk (0x7fffff8UL) /*!< WR_ERROR_FIRST_ADDR (Bitfield-Mask: 0xffffff) */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_PP_ERROR_Pos (2UL)      /*!< PP_ERROR (Bit 2)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_PP_ERROR_Msk (0x4UL)    /*!< PP_ERROR (Bitfield-Mask: 0x01)                        */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_Pos (1UL)      /*!< WR_ERROR (Bit 1)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_WR_ERROR_Msk (0x2UL)    /*!< WR_ERROR (Bitfield-Mask: 0x01)                        */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_ERR_STAT_Pos (0UL)      /*!< ERR_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_ERR_STAT_Msk (0x1UL)    /*!< ERR_STAT (Bitfield-Mask: 0x01)                        */
/* =====================================================  ERR_STATUS_RC  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_AGENT_Pos (27UL) /*!< WR_ERROR_AGENT (Bit 27)                          */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_AGENT_Msk (0x38000000UL) /*!< WR_ERROR_AGENT (Bitfield-Mask: 0x07)     */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_FIRST_ADDR_Pos (3UL) /*!< WR_ERROR_FIRST_ADDR (Bit 3)                  */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_FIRST_ADDR_Msk (0x7fffff8UL) /*!< WR_ERROR_FIRST_ADDR (Bitfield-Mask: 0xffffff) */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_PP_ERROR_Pos (2UL)   /*!< PP_ERROR (Bit 2)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_PP_ERROR_Msk (0x4UL) /*!< PP_ERROR (Bitfield-Mask: 0x01)                        */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_Pos (1UL)   /*!< WR_ERROR (Bit 1)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_WR_ERROR_Msk (0x2UL) /*!< WR_ERROR (Bitfield-Mask: 0x01)                        */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_ERR_STAT_Pos (0UL)   /*!< ERR_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_ERR_STATUS_RC_ERR_STAT_Msk (0x1UL) /*!< ERR_STAT (Bitfield-Mask: 0x01)                        */
/* ===================================================  CUSTOM_OPCODE_EN  ==================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CUSTOM_OPCODE_EN_CUSTOM_OPCODE_EN_Pos (0UL) /*!< CUSTOM_OPCODE_EN (Bit 0)                     */
#define SERIAL_FLASH_CTRL_MANUAL_CUSTOM_OPCODE_EN_CUSTOM_OPCODE_EN_Msk (0x1UL) /*!< CUSTOM_OPCODE_EN (Bitfield-Mask: 0x01)     */
/* =====================================================  CUSTOM_OPCODE  ===================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_CUSTOM_OPCODE_CUSTOM_OPCODE_Pos (0UL) /*!< CUSTOM_OPCODE (Bit 0)                              */
#define SERIAL_FLASH_CTRL_MANUAL_CUSTOM_OPCODE_CUSTOM_OPCODE_Msk (0xffffffffUL) /*!< CUSTOM_OPCODE (Bitfield-Mask: 0xffffffff) */
/* ========================================================  STATUS2  ======================================================== */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ER_WR_ACTIVE_AGENT_Pos (29UL) /*!< ER_WR_ACTIVE_AGENT (Bit 29)                        */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ER_WR_ACTIVE_AGENT_Msk (0xe0000000UL) /*!< ER_WR_ACTIVE_AGENT (Bitfield-Mask: 0x07)   */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ER_WR_ACTIVE_Pos (28UL)    /*!< ER_WR_ACTIVE (Bit 28)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ER_WR_ACTIVE_Msk (0x10000000UL) /*!< ER_WR_ACTIVE (Bitfield-Mask: 0x01)               */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_SUSPEN_ACTIVE_Pos (27UL)   /*!< SUSPEN_ACTIVE (Bit 27)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_SUSPEN_ACTIVE_Msk (0x8000000UL) /*!< SUSPEN_ACTIVE (Bitfield-Mask: 0x01)              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_RESUME_ACTIVE_Pos (26UL)   /*!< RESUME_ACTIVE (Bit 26)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_RESUME_ACTIVE_Msk (0x4000000UL) /*!< RESUME_ACTIVE (Bitfield-Mask: 0x01)              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ERASE_ACTIVE_Pos (25UL)    /*!< ERASE_ACTIVE (Bit 25)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_ERASE_ACTIVE_Msk (0x2000000UL) /*!< ERASE_ACTIVE (Bitfield-Mask: 0x01)                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_ACTIVE_Pos (24UL)       /*!< WR_ACTIVE (Bit 24)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_ACTIVE_Msk (0x1000000UL) /*!< WR_ACTIVE (Bitfield-Mask: 0x01)                      */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_RD_ACTIVE_Pos (23UL)       /*!< RD_ACTIVE (Bit 23)                                    */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_RD_ACTIVE_Msk (0x800000UL) /*!< RD_ACTIVE (Bitfield-Mask: 0x01)                       */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_FIFO_EMPTY_Pos (18UL)   /*!< WR_FIFO_EMPTY (Bit 18)                                */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_FIFO_EMPTY_Msk (0x7c0000UL) /*!< WR_FIFO_EMPTY (Bitfield-Mask: 0x1f)               */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_FIFO_FULL_Pos (13UL)    /*!< WR_FIFO_FULL (Bit 13)                                 */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_WR_FIFO_FULL_Msk (0x3e000UL) /*!< WR_FIFO_FULL (Bitfield-Mask: 0x1f)                  */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_MAIN_SM_Pos (8UL)          /*!< MAIN_SM (Bit 8)                                       */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_MAIN_SM_Msk (0x1f00UL)     /*!< MAIN_SM (Bitfield-Mask: 0x1f)                         */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_SM_Pos (4UL)               /*!< SM (Bit 4)                                            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_SM_Msk (0xf0UL)            /*!< SM (Bitfield-Mask: 0x0f)                              */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_HALT_ACTIVE_Pos (3UL)      /*!< HALT_ACTIVE (Bit 3)                                   */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_HALT_ACTIVE_Msk (0x8UL)    /*!< HALT_ACTIVE (Bitfield-Mask: 0x01)                     */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_CMD_RESULT0_VALID_Pos (2UL) /*!< CMD_RESULT0_VALID (Bit 2)                            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_CMD_RESULT0_VALID_Msk (0x4UL) /*!< CMD_RESULT0_VALID (Bitfield-Mask: 0x01)            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_CMD_RESULT1_VALID_Pos (1UL) /*!< CMD_RESULT1_VALID (Bit 1)                            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_CMD_RESULT1_VALID_Msk (0x2UL) /*!< CMD_RESULT1_VALID (Bitfield-Mask: 0x01)            */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_INT_STAT_Pos (0UL)         /*!< INT_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MANUAL_STATUS2_INT_STAT_Msk (0x1UL)       /*!< INT_STAT (Bitfield-Mask: 0x01)                        */


/* =========================================================================================================================== */
/* ================                               SERIAL_FLASH_CTRL_MCU_SUBSYS                                ================ */
/* =========================================================================================================================== */

/* ======================================================  CFG_SYSTEM  ======================================================= */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_CFG_SYSTEM_CLEAR_PREFETCH_MCU_OTHER_PULSE_Pos (1UL) /*!< CLEAR_PREFETCH_MCU_OTHER_PULSE (Bit 1) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_CFG_SYSTEM_CLEAR_PREFETCH_MCU_OTHER_PULSE_Msk (0x2UL) /*!< CLEAR_PREFETCH_MCU_OTHER_PULSE (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_CFG_SYSTEM_CLEAR_PREFETCH_MCU_PULSE_Pos (0UL) /*!< CLEAR_PREFETCH_MCU_PULSE (Bit 0)       */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_CFG_SYSTEM_CLEAR_PREFETCH_MCU_PULSE_Msk (0x1UL) /*!< CLEAR_PREFETCH_MCU_PULSE (Bitfield-Mask: 0x01) */
/* ======================================================  STATUS_MCU  ======================================================= */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_ERASE_EXECUTING_Pos (11UL) /*!< ERASE_EXECUTING (Bit 11)                       */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_ERASE_EXECUTING_Msk (0x800UL) /*!< ERASE_EXECUTING (Bitfield-Mask: 0x01)       */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_ERASE_PENDING_TO_ARB_Pos (10UL) /*!< ERASE_PENDING_TO_ARB (Bit 10)             */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_ERASE_PENDING_TO_ARB_Msk (0x400UL) /*!< ERASE_PENDING_TO_ARB (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WRITE_EXECUTING_Pos (9UL) /*!< WRITE_EXECUTING (Bit 9)                         */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WRITE_EXECUTING_Msk (0x200UL) /*!< WRITE_EXECUTING (Bitfield-Mask: 0x01)       */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WRITE_PENDING_TO_ARB_Pos (8UL) /*!< WRITE_PENDING_TO_ARB (Bit 8)               */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WRITE_PENDING_TO_ARB_Msk (0x100UL) /*!< WRITE_PENDING_TO_ARB (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_ALL_WRITE_IN_FIFO_Pos (6UL) /*!< WR_FIFO_ALL_WRITE_IN_FIFO (Bit 6)     */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_ALL_WRITE_IN_FIFO_Msk (0x40UL) /*!< WR_FIFO_ALL_WRITE_IN_FIFO (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_FULL_Pos (5UL) /*!< WR_FIFO_FULL (Bit 5)                               */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_FULL_Msk (0x20UL) /*!< WR_FIFO_FULL (Bitfield-Mask: 0x01)              */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_EMPTY_Pos (4UL) /*!< WR_FIFO_EMPTY (Bit 4)                             */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_WR_FIFO_EMPTY_Msk (0x10UL) /*!< WR_FIFO_EMPTY (Bitfield-Mask: 0x01)            */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_INT_STAT_Pos (0UL)  /*!< INT_STAT (Bit 0)                                      */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_INT_STAT_Msk (0x1UL) /*!< INT_STAT (Bitfield-Mask: 0x01)                       */
/* =====================================================  STATUS_MCU_RC  ===================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_ERASE_EXECUTING_Pos (11UL) /*!< ERASE_EXECUTING (Bit 11)                    */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_ERASE_EXECUTING_Msk (0x800UL) /*!< ERASE_EXECUTING (Bitfield-Mask: 0x01)    */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_ERASE_PENDING_TO_ARB_Pos (10UL) /*!< ERASE_PENDING_TO_ARB (Bit 10)          */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_ERASE_PENDING_TO_ARB_Msk (0x400UL) /*!< ERASE_PENDING_TO_ARB (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WRITE_EXECUTING_Pos (9UL) /*!< WRITE_EXECUTING (Bit 9)                      */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WRITE_EXECUTING_Msk (0x200UL) /*!< WRITE_EXECUTING (Bitfield-Mask: 0x01)    */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WRITE_PENDING_TO_ARB_Pos (8UL) /*!< WRITE_PENDING_TO_ARB (Bit 8)            */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WRITE_PENDING_TO_ARB_Msk (0x100UL) /*!< WRITE_PENDING_TO_ARB (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_ALL_WRITE_IN_FIFO_Pos (6UL) /*!< WR_FIFO_ALL_WRITE_IN_FIFO (Bit 6)  */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_ALL_WRITE_IN_FIFO_Msk (0x40UL) /*!< WR_FIFO_ALL_WRITE_IN_FIFO (Bitfield-Mask: 0x01) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_FULL_Pos (5UL) /*!< WR_FIFO_FULL (Bit 5)                            */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_FULL_Msk (0x20UL) /*!< WR_FIFO_FULL (Bitfield-Mask: 0x01)           */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_EMPTY_Pos (4UL) /*!< WR_FIFO_EMPTY (Bit 4)                          */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_WR_FIFO_EMPTY_Msk (0x10UL) /*!< WR_FIFO_EMPTY (Bitfield-Mask: 0x01)         */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_INT_STAT_Pos (0UL) /*!< INT_STAT (Bit 0)                                    */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_STATUS_MCU_RC_INT_STAT_Msk (0x1UL) /*!< INT_STAT (Bitfield-Mask: 0x01)                    */
/* ======================================================  WRITE_COUNT  ====================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_COUNT_CLR_Pos (31UL) /*!< COUNT_CLR (Bit 31)                                  */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_COUNT_CLR_Msk (0x80000000UL) /*!< COUNT_CLR (Bitfield-Mask: 0x01)             */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_IN_COUNTER_Pos (24UL) /*!< IN_COUNTER (Bit 24)                                */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_IN_COUNTER_Msk (0x7f000000UL) /*!< IN_COUNTER (Bitfield-Mask: 0x7f)           */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_OUT_COUNTER_Pos (16UL) /*!< OUT_COUNTER (Bit 16)                              */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_OUT_COUNTER_Msk (0x7f0000UL) /*!< OUT_COUNTER (Bitfield-Mask: 0x7f)           */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_VAL_Pos (2UL)      /*!< VAL (Bit 2)                                           */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_COUNT_VAL_Msk (0x1fcUL)  /*!< VAL (Bitfield-Mask: 0x7f)                             */
/* =====================================================  SFC_ERASE_CFG  ===================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_ADDR_Pos (8UL)   /*!< ADDR (Bit 8)                                          */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_ADDR_Msk (0xffffff00UL) /*!< ADDR (Bitfield-Mask: 0xffffff)                 */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_OPCODE_SEL_Pos (4UL) /*!< OPCODE_SEL (Bit 4)                                */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_OPCODE_SEL_Msk (0x10UL) /*!< OPCODE_SEL (Bitfield-Mask: 0x01)               */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_REQUEST_ERASE_Pos (0UL) /*!< REQUEST_ERASE (Bit 0)                          */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_SFC_ERASE_CFG_REQUEST_ERASE_Msk (0x1UL) /*!< REQUEST_ERASE (Bitfield-Mask: 0x01)          */
/* =====================================================  ERROR_STATUS  ====================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_WR_ERROR_FIRST_ADDR_Pos (3UL) /*!< WR_ERROR_FIRST_ADDR (Bit 3)               */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_WR_ERROR_FIRST_ADDR_Msk (0x7fffff8UL) /*!< WR_ERROR_FIRST_ADDR (Bitfield-Mask: 0xffffff) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_PP_ERROR_Pos (2UL) /*!< PP_ERROR (Bit 2)                                     */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_PP_ERROR_Msk (0x4UL) /*!< PP_ERROR (Bitfield-Mask: 0x01)                     */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_WR_ERR_STAT_Pos (0UL) /*!< WR_ERR_STAT (Bit 0)                               */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_WR_ERR_STAT_Msk (0x1UL) /*!< WR_ERR_STAT (Bitfield-Mask: 0x01)               */
/* ====================================================  ERROR_STATUS_RC  ==================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_WR_ERROR_FIRST_ADDR_Pos (3UL) /*!< WR_ERROR_FIRST_ADDR (Bit 3)            */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_WR_ERROR_FIRST_ADDR_Msk (0x7fffff8UL) /*!< WR_ERROR_FIRST_ADDR (Bitfield-Mask: 0xffffff) */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_PP_ERROR_Pos (2UL) /*!< PP_ERROR (Bit 2)                                  */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_PP_ERROR_Msk (0x4UL) /*!< PP_ERROR (Bitfield-Mask: 0x01)                  */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_WR_ERR_STAT_Pos (0UL) /*!< WR_ERR_STAT (Bit 0)                            */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_ERROR_STATUS_RC_WR_ERR_STAT_Msk (0x1UL) /*!< WR_ERR_STAT (Bitfield-Mask: 0x01)            */
/* =====================================================  WRITE_PROTECT  ===================================================== */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_PROTECT_WRITE_PROTECT_Pos (0UL) /*!< WRITE_PROTECT (Bit 0)                          */
#define SERIAL_FLASH_CTRL_MCU_SUBSYS_WRITE_PROTECT_WRITE_PROTECT_Msk (0x1UL) /*!< WRITE_PROTECT (Bitfield-Mask: 0x01)          */


/* =========================================================================================================================== */
/* ================                                SERIAL_FLASH_CTRL_SECURITY                                 ================ */
/* =========================================================================================================================== */

/* ================================================  SECURED_CONID0_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID0_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID1_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID1_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID2_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID2_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID3_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID3_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID4_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID4_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID5_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID5_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID6_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID6_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID7_WINDOW0  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* ================================================  SECURED_CONID7_WINDOW1  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                               */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)           */
/* =================================================  SECURED_FREE_WINDOW0  ================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_START_Pos (0UL) /*!< START (Bit 0)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_END_Pos (12UL) /*!< END (Bit 12)                                       */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)             */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_CONID_Pos (27UL) /*!< CONID (Bit 27)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW0_CONID_Msk (0x38000000UL) /*!< CONID (Bitfield-Mask: 0x07)              */
/* =================================================  SECURED_FREE_WINDOW1  ================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_START_Pos (0UL) /*!< START (Bit 0)                                     */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_START_Msk (0xfffUL) /*!< START (Bitfield-Mask: 0xfff)                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_END_Pos (12UL) /*!< END (Bit 12)                                       */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_END_Msk (0xfff000UL) /*!< END (Bitfield-Mask: 0xfff)                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_CMD_EN_Pos (24UL) /*!< CMD_EN (Bit 24)                                 */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_CMD_EN_Msk (0x7000000UL) /*!< CMD_EN (Bitfield-Mask: 0x07)             */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_CONID_Pos (27UL) /*!< CONID (Bit 27)                                   */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_FREE_WINDOW1_CONID_Msk (0x38000000UL) /*!< CONID (Bitfield-Mask: 0x07)              */
/* =================================================  SECURED_WR_JUNK_ADDR  ================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_WR_JUNK_ADDR_WR_JUNK_ADDR_Pos (0UL) /*!< WR_JUNK_ADDR (Bit 0)                       */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_WR_JUNK_ADDR_WR_JUNK_ADDR_Msk (0x3ffffffUL) /*!< WR_JUNK_ADDR (Bitfield-Mask: 0x3ffffff) */
/* =================================================  SECURED_RD_JUNK_ADDR  ================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_RD_JUNK_ADDR_RD_JUNK_ADDR_Pos (0UL) /*!< RD_JUNK_ADDR (Bit 0)                       */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_RD_JUNK_ADDR_RD_JUNK_ADDR_Msk (0x3ffffffUL) /*!< RD_JUNK_ADDR (Bitfield-Mask: 0x3ffffff) */
/* =================================================  SECURED_CONID0_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID0_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID1_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID1_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID2_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID2_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID3_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID3_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID4_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID4_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID5_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID5_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID6_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID6_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURED_CONID7_OFFSET  ================================================= */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_OFFSET_OFFSET_Pos (0UL) /*!< OFFSET (Bit 0)                                  */
#define SERIAL_FLASH_CTRL_SECURITY_SECURED_CONID7_OFFSET_OFFSET_Msk (0xfffUL) /*!< OFFSET (Bitfield-Mask: 0xfff)               */
/* =================================================  SECURITY_RD_WR_DEBUG  ================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_ADDR_Pos (0UL) /*!< SFC_VIOLATION_ADDR (Bit 0)           */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_ADDR_Msk (0x3ffffffUL) /*!< SFC_VIOLATION_ADDR (Bitfield-Mask: 0x3ffffff) */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_CONID_Pos (26UL) /*!< SFC_VIOLATION_CONID (Bit 26)       */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_CONID_Msk (0x1c000000UL) /*!< SFC_VIOLATION_CONID (Bitfield-Mask: 0x07) */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_FLAG_Pos (29UL) /*!< SFC_VIOLATION_FLAG (Bit 29)         */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_RD_WR_DEBUG_SFC_VIOLATION_FLAG_Msk (0x20000000UL) /*!< SFC_VIOLATION_FLAG (Bitfield-Mask: 0x01) */
/* ===================================================  SECURITY_ER_DEBUG  =================================================== */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_ADDR_Pos (0UL) /*!< SFC_VIOLATION_ADDR (Bit 0)              */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_ADDR_Msk (0x3ffffffUL) /*!< SFC_VIOLATION_ADDR (Bitfield-Mask: 0x3ffffff) */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_CONID_Pos (26UL) /*!< SFC_VIOLATION_CONID (Bit 26)          */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_CONID_Msk (0x1c000000UL) /*!< SFC_VIOLATION_CONID (Bitfield-Mask: 0x07) */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_FLAG_Pos (29UL) /*!< SFC_VIOLATION_FLAG (Bit 29)            */
#define SERIAL_FLASH_CTRL_SECURITY_SECURITY_ER_DEBUG_SFC_VIOLATION_FLAG_Msk (0x20000000UL) /*!< SFC_VIOLATION_FLAG (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                        GSP_REGFILE                                        ================ */
/* =========================================================================================================================== */

/* ===================================================  MCU_ROM_ADDR_0X0  ==================================================== */
#define GSP_REGFILE_MCU_ROM_ADDR_0X0_MCU_ROM_ADDR_0X0_Pos (0UL)     /*!< MCU_ROM_ADDR_0X0 (Bit 0)                              */
#define GSP_REGFILE_MCU_ROM_ADDR_0X0_MCU_ROM_ADDR_0X0_Msk (0xffffffffUL) /*!< MCU_ROM_ADDR_0X0 (Bitfield-Mask: 0xffffffff)     */
/* ===================================================  MCU_ROM_ADDR_0X4  ==================================================== */
#define GSP_REGFILE_MCU_ROM_ADDR_0X4_MCU_ROM_ADDR_0X4_Pos (0UL)     /*!< MCU_ROM_ADDR_0X4 (Bit 0)                              */
#define GSP_REGFILE_MCU_ROM_ADDR_0X4_MCU_ROM_ADDR_0X4_Msk (0xffffffffUL) /*!< MCU_ROM_ADDR_0X4 (Bitfield-Mask: 0xffffffff)     */
/* ===================================================  MCU_ROM_ADDR_0X8  ==================================================== */
#define GSP_REGFILE_MCU_ROM_ADDR_0X8_MCU_ROM_ADDR_0X8_Pos (0UL)     /*!< MCU_ROM_ADDR_0X8 (Bit 0)                              */
#define GSP_REGFILE_MCU_ROM_ADDR_0X8_MCU_ROM_ADDR_0X8_Msk (0xffffffffUL) /*!< MCU_ROM_ADDR_0X8 (Bitfield-Mask: 0xffffffff)     */
/* ===================================================  MCU_ROM_ADDR_0XC  ==================================================== */
#define GSP_REGFILE_MCU_ROM_ADDR_0XC_MCU_ROM_ADDR_0XC_Pos (0UL)     /*!< MCU_ROM_ADDR_0XC (Bit 0)                              */
#define GSP_REGFILE_MCU_ROM_ADDR_0XC_MCU_ROM_ADDR_0XC_Msk (0xffffffffUL) /*!< MCU_ROM_ADDR_0XC (Bitfield-Mask: 0xffffffff)     */
/* ===================================================  M4_RST_REQ_TARGET  =================================================== */
#define GSP_REGFILE_M4_RST_REQ_TARGET_M4_RST_REQ_TARGET_Pos (0UL)   /*!< M4_RST_REQ_TARGET (Bit 0)                             */
#define GSP_REGFILE_M4_RST_REQ_TARGET_M4_RST_REQ_TARGET_Msk (0x3UL) /*!< M4_RST_REQ_TARGET (Bitfield-Mask: 0x03)               */
/* ======================================================  MCU_CLK_EN  ======================================================= */
#define GSP_REGFILE_MCU_CLK_EN_MCU_CLK_EN_Pos (0UL)                 /*!< MCU_CLK_EN (Bit 0)                                    */
#define GSP_REGFILE_MCU_CLK_EN_MCU_CLK_EN_Msk (0x1UL)               /*!< MCU_CLK_EN (Bitfield-Mask: 0x01)                      */
/* ================================================  MCU_STATUS_MASKED_RCLR  ================================================= */
#define GSP_REGFILE_MCU_STATUS_MASKED_RCLR_MCU_STATUS_MASKED_RCLR_Pos (0UL) /*!< MCU_STATUS_MASKED_RCLR (Bit 0)                */
#define GSP_REGFILE_MCU_STATUS_MASKED_RCLR_MCU_STATUS_MASKED_RCLR_Msk (0xffffUL) /*!< MCU_STATUS_MASKED_RCLR (Bitfield-Mask: 0xffff) */
/* ===================================================  MCU_STATUS_MASKED  =================================================== */
#define GSP_REGFILE_MCU_STATUS_MASKED_MCU_STATUS_MASKED_Pos (0UL)   /*!< MCU_STATUS_MASKED (Bit 0)                             */
#define GSP_REGFILE_MCU_STATUS_MASKED_MCU_STATUS_MASKED_Msk (0xffffUL) /*!< MCU_STATUS_MASKED (Bitfield-Mask: 0xffff)          */
/* ======================================================  GPM_RST_REQ  ====================================================== */
#define GSP_REGFILE_GPM_RST_REQ_GPM_RST_REQ_Pos (0UL)               /*!< GPM_RST_REQ (Bit 0)                                   */
#define GSP_REGFILE_GPM_RST_REQ_GPM_RST_REQ_Msk (0x1UL)             /*!< GPM_RST_REQ (Bitfield-Mask: 0x01)                     */
/* =======================================================  SEG0_SEL  ======================================================== */
#define GSP_REGFILE_SEG0_SEL_SEG0_SEL_Pos (0UL)                     /*!< SEG0_SEL (Bit 0)                                      */
#define GSP_REGFILE_SEG0_SEL_SEG0_SEL_Msk (0x1UL)                   /*!< SEG0_SEL (Bitfield-Mask: 0x01)                        */
/* ========================================================  RC_CFG  ========================================================= */
#define GSP_REGFILE_RC_CFG_EN_Pos         (16UL)                    /*!< EN (Bit 16)                                           */
#define GSP_REGFILE_RC_CFG_EN_Msk         (0x10000UL)               /*!< EN (Bitfield-Mask: 0x01)                              */
#define GSP_REGFILE_RC_CFG_FREQ_SEL_Pos   (11UL)                    /*!< FREQ_SEL (Bit 11)                                     */
#define GSP_REGFILE_RC_CFG_FREQ_SEL_Msk   (0x7800UL)                /*!< FREQ_SEL (Bitfield-Mask: 0x0f)                        */
#define GSP_REGFILE_RC_CFG_TRIM_Pos       (0UL)                     /*!< TRIM (Bit 0)                                          */
#define GSP_REGFILE_RC_CFG_TRIM_Msk       (0x7ffUL)                 /*!< TRIM (Bitfield-Mask: 0x7ff)                           */
/* ========================================================  RC_STT  ========================================================= */
#define GSP_REGFILE_RC_STT_LOCK_Pos       (1UL)                     /*!< LOCK (Bit 1)                                          */
#define GSP_REGFILE_RC_STT_LOCK_Msk       (0x2UL)                   /*!< LOCK (Bitfield-Mask: 0x01)                            */
/* =======================================================  RC_RST_N  ======================================================== */
#define GSP_REGFILE_RC_RST_N_RST_N_Pos    (0UL)                     /*!< RST_N (Bit 0)                                         */
#define GSP_REGFILE_RC_RST_N_RST_N_Msk    (0x1UL)                   /*!< RST_N (Bitfield-Mask: 0x01)                           */
/* ========================================================  M4_CFG  ========================================================= */
#define GSP_REGFILE_M4_CFG_M4_MPU_DISABLE_Pos (0UL)                 /*!< M4_MPU_DISABLE (Bit 0)                                */
#define GSP_REGFILE_M4_CFG_M4_MPU_DISABLE_Msk (0x1UL)               /*!< M4_MPU_DISABLE (Bitfield-Mask: 0x01)                  */
/* ========================================================  M4_INFO  ======================================================== */
#define GSP_REGFILE_M4_INFO_M4_JTAGNSW_Pos (0UL)                    /*!< M4_JTAGNSW (Bit 0)                                    */
#define GSP_REGFILE_M4_INFO_M4_JTAGNSW_Msk (0x1UL)                  /*!< M4_JTAGNSW (Bitfield-Mask: 0x01)                      */
/* ====================================================  PMG_SSX_GSP_CFG  ==================================================== */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_SLEEP_OK_MASK_Pos (12UL)        /*!< SLEEP_OK_MASK (Bit 12)                                */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_SLEEP_OK_MASK_Msk (0x7000UL)    /*!< SLEEP_OK_MASK (Bitfield-Mask: 0x07)                   */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SSX_PMP_IN_POWER_DOWN_Pos (11UL) /*!< REGGSP_SSX_PMP_IN_POWER_DOWN (Bit 11)         */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SSX_PMP_IN_POWER_DOWN_Msk (0x800UL) /*!< REGGSP_SSX_PMP_IN_POWER_DOWN (Bitfield-Mask: 0x01) */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SSX_MCU_IN_POWER_DOWN_Pos (10UL) /*!< REGGSP_SSX_MCU_IN_POWER_DOWN (Bit 10)         */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SSX_MCU_IN_POWER_DOWN_Msk (0x400UL) /*!< REGGSP_SSX_MCU_IN_POWER_DOWN (Bitfield-Mask: 0x01) */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SONICS_CLK_GSP_CNT_TARGET_Pos (0UL) /*!< REGGSP_SONICS_CLK_GSP_CNT_TARGET (Bit 0)   */
#define GSP_REGFILE_PMG_SSX_GSP_CFG_REGGSP_SONICS_CLK_GSP_CNT_TARGET_Msk (0x3ffUL) /*!< REGGSP_SONICS_CLK_GSP_CNT_TARGET (Bitfield-Mask: 0x3ff) */
/* ===================================================  RESET_GSP_SSX_REG  =================================================== */
#define GSP_REGFILE_RESET_GSP_SSX_REG_RESET_GSP_SSX_REG_Pos (0UL)   /*!< RESET_GSP_SSX_REG (Bit 0)                             */
#define GSP_REGFILE_RESET_GSP_SSX_REG_RESET_GSP_SSX_REG_Msk (0x1UL) /*!< RESET_GSP_SSX_REG (Bitfield-Mask: 0x01)               */
/* =====================================================  RESET_MCU_REG  ===================================================== */
#define GSP_REGFILE_RESET_MCU_REG_RESET_MCU_REG_Pos (0UL)           /*!< RESET_MCU_REG (Bit 0)                                 */
#define GSP_REGFILE_RESET_MCU_REG_RESET_MCU_REG_Msk (0x1UL)         /*!< RESET_MCU_REG (Bitfield-Mask: 0x01)                   */
/* =====================================================  RESET_M4_REG  ====================================================== */
#define GSP_REGFILE_RESET_M4_REG_RESET_M4_REG_Pos (0UL)             /*!< RESET_M4_REG (Bit 0)                                  */
#define GSP_REGFILE_RESET_M4_REG_RESET_M4_REG_Msk (0x1UL)           /*!< RESET_M4_REG (Bitfield-Mask: 0x01)                    */
/* ======================================================  POLICY_CFG  ======================================================= */
#define GSP_REGFILE_POLICY_CFG_DIS_ENLOWPOWER_Pos (0UL)             /*!< DIS_ENLOWPOWER (Bit 0)                                */
#define GSP_REGFILE_POLICY_CFG_DIS_ENLOWPOWER_Msk (0x1UL)           /*!< DIS_ENLOWPOWER (Bitfield-Mask: 0x01)                  */
#define GSP_REGFILE_POLICY_CFG_DIS_XO_ISO_EN_Pos (1UL)              /*!< DIS_XO_ISO_EN (Bit 1)                                 */
#define GSP_REGFILE_POLICY_CFG_DIS_XO_ISO_EN_Msk (0x2UL)            /*!< DIS_XO_ISO_EN (Bitfield-Mask: 0x01)                   */
/* ======================================================  MCU_RC_CFG  ======================================================= */
#define GSP_REGFILE_MCU_RC_CFG_EN_Pos     (0UL)                     /*!< EN (Bit 0)                                            */
#define GSP_REGFILE_MCU_RC_CFG_EN_Msk     (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  MCU_URCLK_CFG  ===================================================== */
#define GSP_REGFILE_MCU_URCLK_CFG_EN_Pos  (0UL)                     /*!< EN (Bit 0)                                            */
#define GSP_REGFILE_MCU_URCLK_CFG_EN_Msk  (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ======================================================  MCU_XO_CFG  ======================================================= */
#define GSP_REGFILE_MCU_XO_CFG_XO_LDO_EN_Pos (0UL)                  /*!< XO_LDO_EN (Bit 0)                                     */
#define GSP_REGFILE_MCU_XO_CFG_XO_LDO_EN_Msk (0x1UL)                /*!< XO_LDO_EN (Bitfield-Mask: 0x01)                       */
#define GSP_REGFILE_MCU_XO_CFG_RFXO_LDO_EN_Pos (1UL)                /*!< RFXO_LDO_EN (Bit 1)                                   */
#define GSP_REGFILE_MCU_XO_CFG_RFXO_LDO_EN_Msk (0x2UL)              /*!< RFXO_LDO_EN (Bitfield-Mask: 0x01)                     */
#define GSP_REGFILE_MCU_XO_CFG_XO_ISO_EN_Pos (2UL)                  /*!< XO_ISO_EN (Bit 2)                                     */
#define GSP_REGFILE_MCU_XO_CFG_XO_ISO_EN_Msk (0x4UL)                /*!< XO_ISO_EN (Bitfield-Mask: 0x01)                       */
/* ======================================================  MCU_APC_CFG  ====================================================== */
#define GSP_REGFILE_MCU_APC_CFG_EN_LOW_PWR_Pos (0UL)                /*!< EN_LOW_PWR (Bit 0)                                    */
#define GSP_REGFILE_MCU_APC_CFG_EN_LOW_PWR_Msk (0x1UL)              /*!< EN_LOW_PWR (Bitfield-Mask: 0x01)                      */
/* ======================================================  MCU_SIM_CFG  ====================================================== */
#define GSP_REGFILE_MCU_SIM_CFG_SIM_LDO_EN_Pos (0UL)                /*!< SIM_LDO_EN (Bit 0)                                    */
#define GSP_REGFILE_MCU_SIM_CFG_SIM_LDO_EN_Msk (0x1UL)              /*!< SIM_LDO_EN (Bitfield-Mask: 0x01)                      */
/* =====================================================  MCU_EXTRA_CFG  ===================================================== */
#define GSP_REGFILE_MCU_EXTRA_CFG_EXTRA_LDO_EN_Pos (0UL)            /*!< EXTRA_LDO_EN (Bit 0)                                  */
#define GSP_REGFILE_MCU_EXTRA_CFG_EXTRA_LDO_EN_Msk (0x1UL)          /*!< EXTRA_LDO_EN (Bitfield-Mask: 0x01)                    */
/* ======================================================  PMP_RC_CFG  ======================================================= */
#define GSP_REGFILE_PMP_RC_CFG_EN_Pos     (0UL)                     /*!< EN (Bit 0)                                            */
#define GSP_REGFILE_PMP_RC_CFG_EN_Msk     (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  PMP_URCLK_CFG  ===================================================== */
#define GSP_REGFILE_PMP_URCLK_CFG_EN_Pos  (0UL)                     /*!< EN (Bit 0)                                            */
#define GSP_REGFILE_PMP_URCLK_CFG_EN_Msk  (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ======================================================  PMP_XO_CFG  ======================================================= */
#define GSP_REGFILE_PMP_XO_CFG_XO_LDO_EN_Pos (0UL)                  /*!< XO_LDO_EN (Bit 0)                                     */
#define GSP_REGFILE_PMP_XO_CFG_XO_LDO_EN_Msk (0x1UL)                /*!< XO_LDO_EN (Bitfield-Mask: 0x01)                       */
#define GSP_REGFILE_PMP_XO_CFG_RFXO_LDO_EN_Pos (1UL)                /*!< RFXO_LDO_EN (Bit 1)                                   */
#define GSP_REGFILE_PMP_XO_CFG_RFXO_LDO_EN_Msk (0x2UL)              /*!< RFXO_LDO_EN (Bitfield-Mask: 0x01)                     */
#define GSP_REGFILE_PMP_XO_CFG_XO_ISO_EN_Pos (2UL)                  /*!< XO_ISO_EN (Bit 2)                                     */
#define GSP_REGFILE_PMP_XO_CFG_XO_ISO_EN_Msk (0x4UL)                /*!< XO_ISO_EN (Bitfield-Mask: 0x01)                       */
/* ======================================================  PMP_APC_CFG  ====================================================== */
#define GSP_REGFILE_PMP_APC_CFG_EN_LOW_PWR_Pos (0UL)                /*!< EN_LOW_PWR (Bit 0)                                    */
#define GSP_REGFILE_PMP_APC_CFG_EN_LOW_PWR_Msk (0x1UL)              /*!< EN_LOW_PWR (Bitfield-Mask: 0x01)                      */
/* ======================================================  PMP_SIM_CFG  ====================================================== */
#define GSP_REGFILE_PMP_SIM_CFG_SIM_LDO_EN_Pos (0UL)                /*!< SIM_LDO_EN (Bit 0)                                    */
#define GSP_REGFILE_PMP_SIM_CFG_SIM_LDO_EN_Msk (0x1UL)              /*!< SIM_LDO_EN (Bitfield-Mask: 0x01)                      */
/* =====================================================  PMP_EXTRA_CFG  ===================================================== */
#define GSP_REGFILE_PMP_EXTRA_CFG_EXTRA_LDO_EN_Pos (0UL)            /*!< EXTRA_LDO_EN (Bit 0)                                  */
#define GSP_REGFILE_PMP_EXTRA_CFG_EXTRA_LDO_EN_Msk (0x1UL)          /*!< EXTRA_LDO_EN (Bitfield-Mask: 0x01)                    */
/* ======================================================  M4_STCALIB  ======================================================= */
#define GSP_REGFILE_M4_STCALIB_M4_ST_NOREF_Pos (25UL)               /*!< M4_ST_NOREF (Bit 25)                                  */
#define GSP_REGFILE_M4_STCALIB_M4_ST_NOREF_Msk (0x2000000UL)        /*!< M4_ST_NOREF (Bitfield-Mask: 0x01)                     */
#define GSP_REGFILE_M4_STCALIB_M4_ST_SKEW_Pos (24UL)                /*!< M4_ST_SKEW (Bit 24)                                   */
#define GSP_REGFILE_M4_STCALIB_M4_ST_SKEW_Msk (0x1000000UL)         /*!< M4_ST_SKEW (Bitfield-Mask: 0x01)                      */
#define GSP_REGFILE_M4_STCALIB_M4_ST_TENMS_Pos (0UL)                /*!< M4_ST_TENMS (Bit 0)                                   */
#define GSP_REGFILE_M4_STCALIB_M4_ST_TENMS_Msk (0xffffffUL)         /*!< M4_ST_TENMS (Bitfield-Mask: 0xffffff)                 */
/* ======================================================  MCU_RC_GATE  ====================================================== */
#define GSP_REGFILE_MCU_RC_GATE_RCCLK_MCU_GALTE_Pos (0UL)           /*!< RCCLK_MCU_GALTE (Bit 0)                               */
#define GSP_REGFILE_MCU_RC_GATE_RCCLK_MCU_GALTE_Msk (0x1UL)         /*!< RCCLK_MCU_GALTE (Bitfield-Mask: 0x01)                 */
/* ======================================================  PMP_RC_GATE  ====================================================== */
#define GSP_REGFILE_PMP_RC_GATE_RCCLK_PMP_GATE_Pos (0UL)            /*!< RCCLK_PMP_GATE (Bit 0)                                */
#define GSP_REGFILE_PMP_RC_GATE_RCCLK_PMP_GATE_Msk (0x1UL)          /*!< RCCLK_PMP_GATE (Bitfield-Mask: 0x01)                  */
/* ====================================================  MCU_DEBUG_MODE  ===================================================== */
#define GSP_REGFILE_MCU_DEBUG_MODE_MCU_DEBUG_MODE_Pos (0UL)         /*!< MCU_DEBUG_MODE (Bit 0)                                */
#define GSP_REGFILE_MCU_DEBUG_MODE_MCU_DEBUG_MODE_Msk (0x1UL)       /*!< MCU_DEBUG_MODE (Bitfield-Mask: 0x01)                  */
/* =====================================================  CHIP_RST_STAT  ===================================================== */
#define GSP_REGFILE_CHIP_RST_STAT_MODEM_RST_Pos (0UL)               /*!< MODEM_RST (Bit 0)                                     */
#define GSP_REGFILE_CHIP_RST_STAT_MODEM_RST_Msk (0x1UL)             /*!< MODEM_RST (Bitfield-Mask: 0x01)                       */
#define GSP_REGFILE_CHIP_RST_STAT_PMP_RST_Pos (1UL)                 /*!< PMP_RST (Bit 1)                                       */
#define GSP_REGFILE_CHIP_RST_STAT_PMP_RST_Msk (0x2UL)               /*!< PMP_RST (Bitfield-Mask: 0x01)                         */
#define GSP_REGFILE_CHIP_RST_STAT_GSP_RST_Pos (2UL)                 /*!< GSP_RST (Bit 2)                                       */
#define GSP_REGFILE_CHIP_RST_STAT_GSP_RST_Msk (0x4UL)               /*!< GSP_RST (Bitfield-Mask: 0x01)                         */
/* ================================================  REDUCE_MCU_INTERNAL_MEM  ================================================ */
#define GSP_REGFILE_REDUCE_MCU_INTERNAL_MEM_REDUCE_MCU_INTERNAL_MEM_Pos (0UL) /*!< REDUCE_MCU_INTERNAL_MEM (Bit 0)             */
#define GSP_REGFILE_REDUCE_MCU_INTERNAL_MEM_REDUCE_MCU_INTERNAL_MEM_Msk (0x1UL) /*!< REDUCE_MCU_INTERNAL_MEM (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                        GPM_IO_CFG                                         ================ */
/* =========================================================================================================================== */

/* =========================================================  GPIO0  ========================================================= */
#define GPM_IO_CFG_GPIO0_IO_CFG_IE_GPIO0_Pos (6UL)                  /*!< IO_CFG_IE_GPIO0 (Bit 6)                               */
#define GPM_IO_CFG_GPIO0_IO_CFG_IE_GPIO0_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO0_IO_CFG_IS_GPIO0_Pos (5UL)                  /*!< IO_CFG_IS_GPIO0 (Bit 5)                               */
#define GPM_IO_CFG_GPIO0_IO_CFG_IS_GPIO0_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO0_IO_CFG_SR_GPIO0_Pos (4UL)                  /*!< IO_CFG_SR_GPIO0 (Bit 4)                               */
#define GPM_IO_CFG_GPIO0_IO_CFG_SR_GPIO0_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO0_IO_CFG_PE_GPIO0_Pos (3UL)                  /*!< IO_CFG_PE_GPIO0 (Bit 3)                               */
#define GPM_IO_CFG_GPIO0_IO_CFG_PE_GPIO0_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO0_IO_CFG_PS_GPIO0_Pos (2UL)                  /*!< IO_CFG_PS_GPIO0 (Bit 2)                               */
#define GPM_IO_CFG_GPIO0_IO_CFG_PS_GPIO0_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO0_IO_CFG_DS0_GPIO0_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO0 (Bit 1)                              */
#define GPM_IO_CFG_GPIO0_IO_CFG_DS0_GPIO0_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO0 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO0_IO_CFG_DS1_GPIO0_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO0 (Bit 0)                              */
#define GPM_IO_CFG_GPIO0_IO_CFG_DS1_GPIO0_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO0 (Bitfield-Mask: 0x01)                */
/* =========================================================  GPIO1  ========================================================= */
#define GPM_IO_CFG_GPIO1_IO_CFG_IE_GPIO1_Pos (6UL)                  /*!< IO_CFG_IE_GPIO1 (Bit 6)                               */
#define GPM_IO_CFG_GPIO1_IO_CFG_IE_GPIO1_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO1_IO_CFG_IS_GPIO1_Pos (5UL)                  /*!< IO_CFG_IS_GPIO1 (Bit 5)                               */
#define GPM_IO_CFG_GPIO1_IO_CFG_IS_GPIO1_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO1_IO_CFG_SR_GPIO1_Pos (4UL)                  /*!< IO_CFG_SR_GPIO1 (Bit 4)                               */
#define GPM_IO_CFG_GPIO1_IO_CFG_SR_GPIO1_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO1_IO_CFG_PE_GPIO1_Pos (3UL)                  /*!< IO_CFG_PE_GPIO1 (Bit 3)                               */
#define GPM_IO_CFG_GPIO1_IO_CFG_PE_GPIO1_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO1_IO_CFG_PS_GPIO1_Pos (2UL)                  /*!< IO_CFG_PS_GPIO1 (Bit 2)                               */
#define GPM_IO_CFG_GPIO1_IO_CFG_PS_GPIO1_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO1_IO_CFG_DS0_GPIO1_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO1 (Bit 1)                              */
#define GPM_IO_CFG_GPIO1_IO_CFG_DS0_GPIO1_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO1 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO1_IO_CFG_DS1_GPIO1_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO1 (Bit 0)                              */
#define GPM_IO_CFG_GPIO1_IO_CFG_DS1_GPIO1_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO1 (Bitfield-Mask: 0x01)                */
/* =========================================================  GPIO2  ========================================================= */
#define GPM_IO_CFG_GPIO2_IO_CFG_IE_GPIO2_Pos (6UL)                  /*!< IO_CFG_IE_GPIO2 (Bit 6)                               */
#define GPM_IO_CFG_GPIO2_IO_CFG_IE_GPIO2_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO2_IO_CFG_IS_GPIO2_Pos (5UL)                  /*!< IO_CFG_IS_GPIO2 (Bit 5)                               */
#define GPM_IO_CFG_GPIO2_IO_CFG_IS_GPIO2_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO2_IO_CFG_SR_GPIO2_Pos (4UL)                  /*!< IO_CFG_SR_GPIO2 (Bit 4)                               */
#define GPM_IO_CFG_GPIO2_IO_CFG_SR_GPIO2_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO2_IO_CFG_PE_GPIO2_Pos (3UL)                  /*!< IO_CFG_PE_GPIO2 (Bit 3)                               */
#define GPM_IO_CFG_GPIO2_IO_CFG_PE_GPIO2_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO2_IO_CFG_PS_GPIO2_Pos (2UL)                  /*!< IO_CFG_PS_GPIO2 (Bit 2)                               */
#define GPM_IO_CFG_GPIO2_IO_CFG_PS_GPIO2_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO2_IO_CFG_DS0_GPIO2_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO2 (Bit 1)                              */
#define GPM_IO_CFG_GPIO2_IO_CFG_DS0_GPIO2_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO2 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO2_IO_CFG_DS1_GPIO2_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO2 (Bit 0)                              */
#define GPM_IO_CFG_GPIO2_IO_CFG_DS1_GPIO2_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO2 (Bitfield-Mask: 0x01)                */
/* =========================================================  GPIO3  ========================================================= */
#define GPM_IO_CFG_GPIO3_IO_CFG_IE_GPIO3_Pos (6UL)                  /*!< IO_CFG_IE_GPIO3 (Bit 6)                               */
#define GPM_IO_CFG_GPIO3_IO_CFG_IE_GPIO3_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO3_IO_CFG_IS_GPIO3_Pos (5UL)                  /*!< IO_CFG_IS_GPIO3 (Bit 5)                               */
#define GPM_IO_CFG_GPIO3_IO_CFG_IS_GPIO3_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO3_IO_CFG_SR_GPIO3_Pos (4UL)                  /*!< IO_CFG_SR_GPIO3 (Bit 4)                               */
#define GPM_IO_CFG_GPIO3_IO_CFG_SR_GPIO3_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO3_IO_CFG_PE_GPIO3_Pos (3UL)                  /*!< IO_CFG_PE_GPIO3 (Bit 3)                               */
#define GPM_IO_CFG_GPIO3_IO_CFG_PE_GPIO3_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO3_IO_CFG_PS_GPIO3_Pos (2UL)                  /*!< IO_CFG_PS_GPIO3 (Bit 2)                               */
#define GPM_IO_CFG_GPIO3_IO_CFG_PS_GPIO3_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO3_IO_CFG_DS0_GPIO3_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO3 (Bit 1)                              */
#define GPM_IO_CFG_GPIO3_IO_CFG_DS0_GPIO3_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO3 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO3_IO_CFG_DS1_GPIO3_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO3 (Bit 0)                              */
#define GPM_IO_CFG_GPIO3_IO_CFG_DS1_GPIO3_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO3 (Bitfield-Mask: 0x01)                */
/* =========================================================  GPIO4  ========================================================= */
#define GPM_IO_CFG_GPIO4_IO_CFG_IE_GPIO4_Pos (6UL)                  /*!< IO_CFG_IE_GPIO4 (Bit 6)                               */
#define GPM_IO_CFG_GPIO4_IO_CFG_IE_GPIO4_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO4 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO4_IO_CFG_IS_GPIO4_Pos (5UL)                  /*!< IO_CFG_IS_GPIO4 (Bit 5)                               */
#define GPM_IO_CFG_GPIO4_IO_CFG_IS_GPIO4_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO4 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO4_IO_CFG_SR_GPIO4_Pos (4UL)                  /*!< IO_CFG_SR_GPIO4 (Bit 4)                               */
#define GPM_IO_CFG_GPIO4_IO_CFG_SR_GPIO4_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO4 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO4_IO_CFG_PE_GPIO4_Pos (3UL)                  /*!< IO_CFG_PE_GPIO4 (Bit 3)                               */
#define GPM_IO_CFG_GPIO4_IO_CFG_PE_GPIO4_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO4 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO4_IO_CFG_PS_GPIO4_Pos (2UL)                  /*!< IO_CFG_PS_GPIO4 (Bit 2)                               */
#define GPM_IO_CFG_GPIO4_IO_CFG_PS_GPIO4_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO4 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO4_IO_CFG_DS0_GPIO4_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO4 (Bit 1)                              */
#define GPM_IO_CFG_GPIO4_IO_CFG_DS0_GPIO4_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO4 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO4_IO_CFG_DS1_GPIO4_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO4 (Bit 0)                              */
#define GPM_IO_CFG_GPIO4_IO_CFG_DS1_GPIO4_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO4 (Bitfield-Mask: 0x01)                */
/* =========================================================  GPIO5  ========================================================= */
#define GPM_IO_CFG_GPIO5_IO_CFG_IE_GPIO5_Pos (6UL)                  /*!< IO_CFG_IE_GPIO5 (Bit 6)                               */
#define GPM_IO_CFG_GPIO5_IO_CFG_IE_GPIO5_Msk (0x40UL)               /*!< IO_CFG_IE_GPIO5 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO5_IO_CFG_IS_GPIO5_Pos (5UL)                  /*!< IO_CFG_IS_GPIO5 (Bit 5)                               */
#define GPM_IO_CFG_GPIO5_IO_CFG_IS_GPIO5_Msk (0x20UL)               /*!< IO_CFG_IS_GPIO5 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO5_IO_CFG_SR_GPIO5_Pos (4UL)                  /*!< IO_CFG_SR_GPIO5 (Bit 4)                               */
#define GPM_IO_CFG_GPIO5_IO_CFG_SR_GPIO5_Msk (0x10UL)               /*!< IO_CFG_SR_GPIO5 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO5_IO_CFG_PE_GPIO5_Pos (3UL)                  /*!< IO_CFG_PE_GPIO5 (Bit 3)                               */
#define GPM_IO_CFG_GPIO5_IO_CFG_PE_GPIO5_Msk (0x8UL)                /*!< IO_CFG_PE_GPIO5 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO5_IO_CFG_PS_GPIO5_Pos (2UL)                  /*!< IO_CFG_PS_GPIO5 (Bit 2)                               */
#define GPM_IO_CFG_GPIO5_IO_CFG_PS_GPIO5_Msk (0x4UL)                /*!< IO_CFG_PS_GPIO5 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_GPIO5_IO_CFG_DS0_GPIO5_Pos (1UL)                 /*!< IO_CFG_DS0_GPIO5 (Bit 1)                              */
#define GPM_IO_CFG_GPIO5_IO_CFG_DS0_GPIO5_Msk (0x2UL)               /*!< IO_CFG_DS0_GPIO5 (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_GPIO5_IO_CFG_DS1_GPIO5_Pos (0UL)                 /*!< IO_CFG_DS1_GPIO5 (Bit 0)                              */
#define GPM_IO_CFG_GPIO5_IO_CFG_DS1_GPIO5_Msk (0x1UL)               /*!< IO_CFG_DS1_GPIO5 (Bitfield-Mask: 0x01)                */
/* ====================================================  RFFE_VDDIO_OUT  ===================================================== */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_IE_RFFE_VDDIO_OUT_Pos (6UL) /*!< IO_CFG_IE_RFFE_VDDIO_OUT (Bit 6)                     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_IE_RFFE_VDDIO_OUT_Msk (0x40UL) /*!< IO_CFG_IE_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)    */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_IS_RFFE_VDDIO_OUT_Pos (5UL) /*!< IO_CFG_IS_RFFE_VDDIO_OUT (Bit 5)                     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_IS_RFFE_VDDIO_OUT_Msk (0x20UL) /*!< IO_CFG_IS_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)    */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_SR_RFFE_VDDIO_OUT_Pos (4UL) /*!< IO_CFG_SR_RFFE_VDDIO_OUT (Bit 4)                     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_SR_RFFE_VDDIO_OUT_Msk (0x10UL) /*!< IO_CFG_SR_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)    */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_PE_RFFE_VDDIO_OUT_Pos (3UL) /*!< IO_CFG_PE_RFFE_VDDIO_OUT (Bit 3)                     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_PE_RFFE_VDDIO_OUT_Msk (0x8UL) /*!< IO_CFG_PE_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_PS_RFFE_VDDIO_OUT_Pos (2UL) /*!< IO_CFG_PS_RFFE_VDDIO_OUT (Bit 2)                     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_PS_RFFE_VDDIO_OUT_Msk (0x4UL) /*!< IO_CFG_PS_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)     */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_DS0_RFFE_VDDIO_OUT_Pos (1UL) /*!< IO_CFG_DS0_RFFE_VDDIO_OUT (Bit 1)                   */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_DS0_RFFE_VDDIO_OUT_Msk (0x2UL) /*!< IO_CFG_DS0_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)   */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_DS1_RFFE_VDDIO_OUT_Pos (0UL) /*!< IO_CFG_DS1_RFFE_VDDIO_OUT (Bit 0)                   */
#define GPM_IO_CFG_RFFE_VDDIO_OUT_IO_CFG_DS1_RFFE_VDDIO_OUT_Msk (0x1UL) /*!< IO_CFG_DS1_RFFE_VDDIO_OUT (Bitfield-Mask: 0x01)   */
/* =======================================================  RFFE_SCLK  ======================================================= */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_IE_RFFE_SCLK_Pos (6UL)          /*!< IO_CFG_IE_RFFE_SCLK (Bit 6)                           */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_IE_RFFE_SCLK_Msk (0x40UL)       /*!< IO_CFG_IE_RFFE_SCLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_IS_RFFE_SCLK_Pos (5UL)          /*!< IO_CFG_IS_RFFE_SCLK (Bit 5)                           */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_IS_RFFE_SCLK_Msk (0x20UL)       /*!< IO_CFG_IS_RFFE_SCLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_SR_RFFE_SCLK_Pos (4UL)          /*!< IO_CFG_SR_RFFE_SCLK (Bit 4)                           */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_SR_RFFE_SCLK_Msk (0x10UL)       /*!< IO_CFG_SR_RFFE_SCLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_PE_RFFE_SCLK_Pos (3UL)          /*!< IO_CFG_PE_RFFE_SCLK (Bit 3)                           */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_PE_RFFE_SCLK_Msk (0x8UL)        /*!< IO_CFG_PE_RFFE_SCLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_PS_RFFE_SCLK_Pos (2UL)          /*!< IO_CFG_PS_RFFE_SCLK (Bit 2)                           */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_PS_RFFE_SCLK_Msk (0x4UL)        /*!< IO_CFG_PS_RFFE_SCLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_DS0_RFFE_SCLK_Pos (1UL)         /*!< IO_CFG_DS0_RFFE_SCLK (Bit 1)                          */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_DS0_RFFE_SCLK_Msk (0x2UL)       /*!< IO_CFG_DS0_RFFE_SCLK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_DS1_RFFE_SCLK_Pos (0UL)         /*!< IO_CFG_DS1_RFFE_SCLK (Bit 0)                          */
#define GPM_IO_CFG_RFFE_SCLK_IO_CFG_DS1_RFFE_SCLK_Msk (0x1UL)       /*!< IO_CFG_DS1_RFFE_SCLK (Bitfield-Mask: 0x01)            */
/* ======================================================  RFFE_SDATA  ======================================================= */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_IE_RFFE_SDATA_Pos (6UL)        /*!< IO_CFG_IE_RFFE_SDATA (Bit 6)                          */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_IE_RFFE_SDATA_Msk (0x40UL)     /*!< IO_CFG_IE_RFFE_SDATA (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_IS_RFFE_SDATA_Pos (5UL)        /*!< IO_CFG_IS_RFFE_SDATA (Bit 5)                          */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_IS_RFFE_SDATA_Msk (0x20UL)     /*!< IO_CFG_IS_RFFE_SDATA (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_SR_RFFE_SDATA_Pos (4UL)        /*!< IO_CFG_SR_RFFE_SDATA (Bit 4)                          */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_SR_RFFE_SDATA_Msk (0x10UL)     /*!< IO_CFG_SR_RFFE_SDATA (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_PE_RFFE_SDATA_Pos (3UL)        /*!< IO_CFG_PE_RFFE_SDATA (Bit 3)                          */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_PE_RFFE_SDATA_Msk (0x8UL)      /*!< IO_CFG_PE_RFFE_SDATA (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_PS_RFFE_SDATA_Pos (2UL)        /*!< IO_CFG_PS_RFFE_SDATA (Bit 2)                          */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_PS_RFFE_SDATA_Msk (0x4UL)      /*!< IO_CFG_PS_RFFE_SDATA (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_DS0_RFFE_SDATA_Pos (1UL)       /*!< IO_CFG_DS0_RFFE_SDATA (Bit 1)                         */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_DS0_RFFE_SDATA_Msk (0x2UL)     /*!< IO_CFG_DS0_RFFE_SDATA (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_DS1_RFFE_SDATA_Pos (0UL)       /*!< IO_CFG_DS1_RFFE_SDATA (Bit 0)                         */
#define GPM_IO_CFG_RFFE_SDATA_IO_CFG_DS1_RFFE_SDATA_Msk (0x1UL)     /*!< IO_CFG_DS1_RFFE_SDATA (Bitfield-Mask: 0x01)           */
/* ========================================================  SC_RST  ========================================================= */
#define GPM_IO_CFG_SC_RST_IO_CFG_IE_SC_RST_Pos (6UL)                /*!< IO_CFG_IE_SC_RST (Bit 6)                              */
#define GPM_IO_CFG_SC_RST_IO_CFG_IE_SC_RST_Msk (0x40UL)             /*!< IO_CFG_IE_SC_RST (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_RST_IO_CFG_IS_SC_RST_Pos (5UL)                /*!< IO_CFG_IS_SC_RST (Bit 5)                              */
#define GPM_IO_CFG_SC_RST_IO_CFG_IS_SC_RST_Msk (0x20UL)             /*!< IO_CFG_IS_SC_RST (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_RST_IO_CFG_SR_SC_RST_Pos (4UL)                /*!< IO_CFG_SR_SC_RST (Bit 4)                              */
#define GPM_IO_CFG_SC_RST_IO_CFG_SR_SC_RST_Msk (0x10UL)             /*!< IO_CFG_SR_SC_RST (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_RST_IO_CFG_PE_SC_RST_Pos (3UL)                /*!< IO_CFG_PE_SC_RST (Bit 3)                              */
#define GPM_IO_CFG_SC_RST_IO_CFG_PE_SC_RST_Msk (0x8UL)              /*!< IO_CFG_PE_SC_RST (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_RST_IO_CFG_PS_SC_RST_Pos (2UL)                /*!< IO_CFG_PS_SC_RST (Bit 2)                              */
#define GPM_IO_CFG_SC_RST_IO_CFG_PS_SC_RST_Msk (0x4UL)              /*!< IO_CFG_PS_SC_RST (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_RST_IO_CFG_DS0_SC_RST_Pos (1UL)               /*!< IO_CFG_DS0_SC_RST (Bit 1)                             */
#define GPM_IO_CFG_SC_RST_IO_CFG_DS0_SC_RST_Msk (0x2UL)             /*!< IO_CFG_DS0_SC_RST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_SC_RST_IO_CFG_DS1_SC_RST_Pos (0UL)               /*!< IO_CFG_DS1_SC_RST (Bit 0)                             */
#define GPM_IO_CFG_SC_RST_IO_CFG_DS1_SC_RST_Msk (0x1UL)             /*!< IO_CFG_DS1_SC_RST (Bitfield-Mask: 0x01)               */
/* =========================================================  SC_IO  ========================================================= */
#define GPM_IO_CFG_SC_IO_IO_CFG_IE_SC_IO_Pos (6UL)                  /*!< IO_CFG_IE_SC_IO (Bit 6)                               */
#define GPM_IO_CFG_SC_IO_IO_CFG_IE_SC_IO_Msk (0x40UL)               /*!< IO_CFG_IE_SC_IO (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_SC_IO_IO_CFG_IS_SC_IO_Pos (5UL)                  /*!< IO_CFG_IS_SC_IO (Bit 5)                               */
#define GPM_IO_CFG_SC_IO_IO_CFG_IS_SC_IO_Msk (0x20UL)               /*!< IO_CFG_IS_SC_IO (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_SC_IO_IO_CFG_SR_SC_IO_Pos (4UL)                  /*!< IO_CFG_SR_SC_IO (Bit 4)                               */
#define GPM_IO_CFG_SC_IO_IO_CFG_SR_SC_IO_Msk (0x10UL)               /*!< IO_CFG_SR_SC_IO (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_SC_IO_IO_CFG_PE_SC_IO_Pos (3UL)                  /*!< IO_CFG_PE_SC_IO (Bit 3)                               */
#define GPM_IO_CFG_SC_IO_IO_CFG_PE_SC_IO_Msk (0x8UL)                /*!< IO_CFG_PE_SC_IO (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_SC_IO_IO_CFG_PS_SC_IO_Pos (2UL)                  /*!< IO_CFG_PS_SC_IO (Bit 2)                               */
#define GPM_IO_CFG_SC_IO_IO_CFG_PS_SC_IO_Msk (0x4UL)                /*!< IO_CFG_PS_SC_IO (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_SC_IO_IO_CFG_DS0_SC_IO_Pos (1UL)                 /*!< IO_CFG_DS0_SC_IO (Bit 1)                              */
#define GPM_IO_CFG_SC_IO_IO_CFG_DS0_SC_IO_Msk (0x2UL)               /*!< IO_CFG_DS0_SC_IO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_IO_IO_CFG_DS1_SC_IO_Pos (0UL)                 /*!< IO_CFG_DS1_SC_IO (Bit 0)                              */
#define GPM_IO_CFG_SC_IO_IO_CFG_DS1_SC_IO_Msk (0x1UL)               /*!< IO_CFG_DS1_SC_IO (Bitfield-Mask: 0x01)                */
/* ========================================================  SC_CLK  ========================================================= */
#define GPM_IO_CFG_SC_CLK_IO_CFG_IE_SC_CLK_Pos (6UL)                /*!< IO_CFG_IE_SC_CLK (Bit 6)                              */
#define GPM_IO_CFG_SC_CLK_IO_CFG_IE_SC_CLK_Msk (0x40UL)             /*!< IO_CFG_IE_SC_CLK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_CLK_IO_CFG_IS_SC_CLK_Pos (5UL)                /*!< IO_CFG_IS_SC_CLK (Bit 5)                              */
#define GPM_IO_CFG_SC_CLK_IO_CFG_IS_SC_CLK_Msk (0x20UL)             /*!< IO_CFG_IS_SC_CLK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_CLK_IO_CFG_SR_SC_CLK_Pos (4UL)                /*!< IO_CFG_SR_SC_CLK (Bit 4)                              */
#define GPM_IO_CFG_SC_CLK_IO_CFG_SR_SC_CLK_Msk (0x10UL)             /*!< IO_CFG_SR_SC_CLK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_CLK_IO_CFG_PE_SC_CLK_Pos (3UL)                /*!< IO_CFG_PE_SC_CLK (Bit 3)                              */
#define GPM_IO_CFG_SC_CLK_IO_CFG_PE_SC_CLK_Msk (0x8UL)              /*!< IO_CFG_PE_SC_CLK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_CLK_IO_CFG_PS_SC_CLK_Pos (2UL)                /*!< IO_CFG_PS_SC_CLK (Bit 2)                              */
#define GPM_IO_CFG_SC_CLK_IO_CFG_PS_SC_CLK_Msk (0x4UL)              /*!< IO_CFG_PS_SC_CLK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_CLK_IO_CFG_DS0_SC_CLK_Pos (1UL)               /*!< IO_CFG_DS0_SC_CLK (Bit 1)                             */
#define GPM_IO_CFG_SC_CLK_IO_CFG_DS0_SC_CLK_Msk (0x2UL)             /*!< IO_CFG_DS0_SC_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_SC_CLK_IO_CFG_DS1_SC_CLK_Pos (0UL)               /*!< IO_CFG_DS1_SC_CLK (Bit 0)                             */
#define GPM_IO_CFG_SC_CLK_IO_CFG_DS1_SC_CLK_Msk (0x1UL)             /*!< IO_CFG_DS1_SC_CLK (Bitfield-Mask: 0x01)               */
/* ========================================================  SC_DET  ========================================================= */
#define GPM_IO_CFG_SC_DET_IO_CFG_IE_SC_DET_Pos (6UL)                /*!< IO_CFG_IE_SC_DET (Bit 6)                              */
#define GPM_IO_CFG_SC_DET_IO_CFG_IE_SC_DET_Msk (0x40UL)             /*!< IO_CFG_IE_SC_DET (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_DET_IO_CFG_IS_SC_DET_Pos (5UL)                /*!< IO_CFG_IS_SC_DET (Bit 5)                              */
#define GPM_IO_CFG_SC_DET_IO_CFG_IS_SC_DET_Msk (0x20UL)             /*!< IO_CFG_IS_SC_DET (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_DET_IO_CFG_SR_SC_DET_Pos (4UL)                /*!< IO_CFG_SR_SC_DET (Bit 4)                              */
#define GPM_IO_CFG_SC_DET_IO_CFG_SR_SC_DET_Msk (0x10UL)             /*!< IO_CFG_SR_SC_DET (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_DET_IO_CFG_PE_SC_DET_Pos (3UL)                /*!< IO_CFG_PE_SC_DET (Bit 3)                              */
#define GPM_IO_CFG_SC_DET_IO_CFG_PE_SC_DET_Msk (0x8UL)              /*!< IO_CFG_PE_SC_DET (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_DET_IO_CFG_PS_SC_DET_Pos (2UL)                /*!< IO_CFG_PS_SC_DET (Bit 2)                              */
#define GPM_IO_CFG_SC_DET_IO_CFG_PS_SC_DET_Msk (0x4UL)              /*!< IO_CFG_PS_SC_DET (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_DET_IO_CFG_DS0_SC_DET_Pos (1UL)               /*!< IO_CFG_DS0_SC_DET (Bit 1)                             */
#define GPM_IO_CFG_SC_DET_IO_CFG_DS0_SC_DET_Msk (0x2UL)             /*!< IO_CFG_DS0_SC_DET (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_SC_DET_IO_CFG_DS1_SC_DET_Pos (0UL)               /*!< IO_CFG_DS1_SC_DET (Bit 0)                             */
#define GPM_IO_CFG_SC_DET_IO_CFG_DS1_SC_DET_Msk (0x1UL)             /*!< IO_CFG_DS1_SC_DET (Bitfield-Mask: 0x01)               */
/* ========================================================  SC_SWP  ========================================================= */
#define GPM_IO_CFG_SC_SWP_IO_CFG_IE_SC_SWP_Pos (6UL)                /*!< IO_CFG_IE_SC_SWP (Bit 6)                              */
#define GPM_IO_CFG_SC_SWP_IO_CFG_IE_SC_SWP_Msk (0x40UL)             /*!< IO_CFG_IE_SC_SWP (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_SWP_IO_CFG_IS_SC_SWP_Pos (5UL)                /*!< IO_CFG_IS_SC_SWP (Bit 5)                              */
#define GPM_IO_CFG_SC_SWP_IO_CFG_IS_SC_SWP_Msk (0x20UL)             /*!< IO_CFG_IS_SC_SWP (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_SWP_IO_CFG_SR_SC_SWP_Pos (4UL)                /*!< IO_CFG_SR_SC_SWP (Bit 4)                              */
#define GPM_IO_CFG_SC_SWP_IO_CFG_SR_SC_SWP_Msk (0x10UL)             /*!< IO_CFG_SR_SC_SWP (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_SWP_IO_CFG_PE_SC_SWP_Pos (3UL)                /*!< IO_CFG_PE_SC_SWP (Bit 3)                              */
#define GPM_IO_CFG_SC_SWP_IO_CFG_PE_SC_SWP_Msk (0x8UL)              /*!< IO_CFG_PE_SC_SWP (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_SWP_IO_CFG_PS_SC_SWP_Pos (2UL)                /*!< IO_CFG_PS_SC_SWP (Bit 2)                              */
#define GPM_IO_CFG_SC_SWP_IO_CFG_PS_SC_SWP_Msk (0x4UL)              /*!< IO_CFG_PS_SC_SWP (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_SC_SWP_IO_CFG_DS0_SC_SWP_Pos (1UL)               /*!< IO_CFG_DS0_SC_SWP (Bit 1)                             */
#define GPM_IO_CFG_SC_SWP_IO_CFG_DS0_SC_SWP_Msk (0x2UL)             /*!< IO_CFG_DS0_SC_SWP (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_SC_SWP_IO_CFG_DS1_SC_SWP_Pos (0UL)               /*!< IO_CFG_DS1_SC_SWP (Bit 0)                             */
#define GPM_IO_CFG_SC_SWP_IO_CFG_DS1_SC_SWP_Msk (0x1UL)             /*!< IO_CFG_DS1_SC_SWP (Bitfield-Mask: 0x01)               */
/* ========================================================  EJ_TCK  ========================================================= */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_IE_EJ_TCK_Pos (6UL)                /*!< IO_CFG_IE_EJ_TCK (Bit 6)                              */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_IE_EJ_TCK_Msk (0x40UL)             /*!< IO_CFG_IE_EJ_TCK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_IS_EJ_TCK_Pos (5UL)                /*!< IO_CFG_IS_EJ_TCK (Bit 5)                              */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_IS_EJ_TCK_Msk (0x20UL)             /*!< IO_CFG_IS_EJ_TCK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_SR_EJ_TCK_Pos (4UL)                /*!< IO_CFG_SR_EJ_TCK (Bit 4)                              */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_SR_EJ_TCK_Msk (0x10UL)             /*!< IO_CFG_SR_EJ_TCK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_PE_EJ_TCK_Pos (3UL)                /*!< IO_CFG_PE_EJ_TCK (Bit 3)                              */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_PE_EJ_TCK_Msk (0x8UL)              /*!< IO_CFG_PE_EJ_TCK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_PS_EJ_TCK_Pos (2UL)                /*!< IO_CFG_PS_EJ_TCK (Bit 2)                              */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_PS_EJ_TCK_Msk (0x4UL)              /*!< IO_CFG_PS_EJ_TCK (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_DS0_EJ_TCK_Pos (1UL)               /*!< IO_CFG_DS0_EJ_TCK (Bit 1)                             */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_DS0_EJ_TCK_Msk (0x2UL)             /*!< IO_CFG_DS0_EJ_TCK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_DS1_EJ_TCK_Pos (0UL)               /*!< IO_CFG_DS1_EJ_TCK (Bit 0)                             */
#define GPM_IO_CFG_EJ_TCK_IO_CFG_DS1_EJ_TCK_Msk (0x1UL)             /*!< IO_CFG_DS1_EJ_TCK (Bitfield-Mask: 0x01)               */
/* ========================================================  EJ_TMS  ========================================================= */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_IE_EJ_TMS_Pos (6UL)                /*!< IO_CFG_IE_EJ_TMS (Bit 6)                              */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_IE_EJ_TMS_Msk (0x40UL)             /*!< IO_CFG_IE_EJ_TMS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_IS_EJ_TMS_Pos (5UL)                /*!< IO_CFG_IS_EJ_TMS (Bit 5)                              */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_IS_EJ_TMS_Msk (0x20UL)             /*!< IO_CFG_IS_EJ_TMS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_SR_EJ_TMS_Pos (4UL)                /*!< IO_CFG_SR_EJ_TMS (Bit 4)                              */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_SR_EJ_TMS_Msk (0x10UL)             /*!< IO_CFG_SR_EJ_TMS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_PE_EJ_TMS_Pos (3UL)                /*!< IO_CFG_PE_EJ_TMS (Bit 3)                              */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_PE_EJ_TMS_Msk (0x8UL)              /*!< IO_CFG_PE_EJ_TMS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_PS_EJ_TMS_Pos (2UL)                /*!< IO_CFG_PS_EJ_TMS (Bit 2)                              */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_PS_EJ_TMS_Msk (0x4UL)              /*!< IO_CFG_PS_EJ_TMS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_DS0_EJ_TMS_Pos (1UL)               /*!< IO_CFG_DS0_EJ_TMS (Bit 1)                             */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_DS0_EJ_TMS_Msk (0x2UL)             /*!< IO_CFG_DS0_EJ_TMS (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_DS1_EJ_TMS_Pos (0UL)               /*!< IO_CFG_DS1_EJ_TMS (Bit 0)                             */
#define GPM_IO_CFG_EJ_TMS_IO_CFG_DS1_EJ_TMS_Msk (0x1UL)             /*!< IO_CFG_DS1_EJ_TMS (Bitfield-Mask: 0x01)               */
/* ========================================================  EJ_TRST  ======================================================== */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_IE_EJ_TRST_Pos (6UL)              /*!< IO_CFG_IE_EJ_TRST (Bit 6)                             */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_IE_EJ_TRST_Msk (0x40UL)           /*!< IO_CFG_IE_EJ_TRST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_IS_EJ_TRST_Pos (5UL)              /*!< IO_CFG_IS_EJ_TRST (Bit 5)                             */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_IS_EJ_TRST_Msk (0x20UL)           /*!< IO_CFG_IS_EJ_TRST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_SR_EJ_TRST_Pos (4UL)              /*!< IO_CFG_SR_EJ_TRST (Bit 4)                             */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_SR_EJ_TRST_Msk (0x10UL)           /*!< IO_CFG_SR_EJ_TRST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_PE_EJ_TRST_Pos (3UL)              /*!< IO_CFG_PE_EJ_TRST (Bit 3)                             */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_PE_EJ_TRST_Msk (0x8UL)            /*!< IO_CFG_PE_EJ_TRST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_PS_EJ_TRST_Pos (2UL)              /*!< IO_CFG_PS_EJ_TRST (Bit 2)                             */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_PS_EJ_TRST_Msk (0x4UL)            /*!< IO_CFG_PS_EJ_TRST (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_DS0_EJ_TRST_Pos (1UL)             /*!< IO_CFG_DS0_EJ_TRST (Bit 1)                            */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_DS0_EJ_TRST_Msk (0x2UL)           /*!< IO_CFG_DS0_EJ_TRST (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_DS1_EJ_TRST_Pos (0UL)             /*!< IO_CFG_DS1_EJ_TRST (Bit 0)                            */
#define GPM_IO_CFG_EJ_TRST_IO_CFG_DS1_EJ_TRST_Msk (0x1UL)           /*!< IO_CFG_DS1_EJ_TRST (Bitfield-Mask: 0x01)              */
/* ========================================================  EJ_TDI  ========================================================= */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_IE_EJ_TDI_Pos (6UL)                /*!< IO_CFG_IE_EJ_TDI (Bit 6)                              */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_IE_EJ_TDI_Msk (0x40UL)             /*!< IO_CFG_IE_EJ_TDI (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_IS_EJ_TDI_Pos (5UL)                /*!< IO_CFG_IS_EJ_TDI (Bit 5)                              */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_IS_EJ_TDI_Msk (0x20UL)             /*!< IO_CFG_IS_EJ_TDI (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_SR_EJ_TDI_Pos (4UL)                /*!< IO_CFG_SR_EJ_TDI (Bit 4)                              */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_SR_EJ_TDI_Msk (0x10UL)             /*!< IO_CFG_SR_EJ_TDI (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_PE_EJ_TDI_Pos (3UL)                /*!< IO_CFG_PE_EJ_TDI (Bit 3)                              */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_PE_EJ_TDI_Msk (0x8UL)              /*!< IO_CFG_PE_EJ_TDI (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_PS_EJ_TDI_Pos (2UL)                /*!< IO_CFG_PS_EJ_TDI (Bit 2)                              */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_PS_EJ_TDI_Msk (0x4UL)              /*!< IO_CFG_PS_EJ_TDI (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_DS0_EJ_TDI_Pos (1UL)               /*!< IO_CFG_DS0_EJ_TDI (Bit 1)                             */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_DS0_EJ_TDI_Msk (0x2UL)             /*!< IO_CFG_DS0_EJ_TDI (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_DS1_EJ_TDI_Pos (0UL)               /*!< IO_CFG_DS1_EJ_TDI (Bit 0)                             */
#define GPM_IO_CFG_EJ_TDI_IO_CFG_DS1_EJ_TDI_Msk (0x1UL)             /*!< IO_CFG_DS1_EJ_TDI (Bitfield-Mask: 0x01)               */
/* ========================================================  EJ_TDO  ========================================================= */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_IE_EJ_TDO_Pos (6UL)                /*!< IO_CFG_IE_EJ_TDO (Bit 6)                              */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_IE_EJ_TDO_Msk (0x40UL)             /*!< IO_CFG_IE_EJ_TDO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_IS_EJ_TDO_Pos (5UL)                /*!< IO_CFG_IS_EJ_TDO (Bit 5)                              */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_IS_EJ_TDO_Msk (0x20UL)             /*!< IO_CFG_IS_EJ_TDO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_SR_EJ_TDO_Pos (4UL)                /*!< IO_CFG_SR_EJ_TDO (Bit 4)                              */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_SR_EJ_TDO_Msk (0x10UL)             /*!< IO_CFG_SR_EJ_TDO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_PE_EJ_TDO_Pos (3UL)                /*!< IO_CFG_PE_EJ_TDO (Bit 3)                              */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_PE_EJ_TDO_Msk (0x8UL)              /*!< IO_CFG_PE_EJ_TDO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_PS_EJ_TDO_Pos (2UL)                /*!< IO_CFG_PS_EJ_TDO (Bit 2)                              */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_PS_EJ_TDO_Msk (0x4UL)              /*!< IO_CFG_PS_EJ_TDO (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_DS0_EJ_TDO_Pos (1UL)               /*!< IO_CFG_DS0_EJ_TDO (Bit 1)                             */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_DS0_EJ_TDO_Msk (0x2UL)             /*!< IO_CFG_DS0_EJ_TDO (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_DS1_EJ_TDO_Pos (0UL)               /*!< IO_CFG_DS1_EJ_TDO (Bit 0)                             */
#define GPM_IO_CFG_EJ_TDO_IO_CFG_DS1_EJ_TDO_Msk (0x1UL)             /*!< IO_CFG_DS1_EJ_TDO (Bitfield-Mask: 0x01)               */
/* =======================================================  UART0_RX  ======================================================== */
#define GPM_IO_CFG_UART0_RX_IO_CFG_IE_UART0_RX_Pos (6UL)            /*!< IO_CFG_IE_UART0_RX (Bit 6)                            */
#define GPM_IO_CFG_UART0_RX_IO_CFG_IE_UART0_RX_Msk (0x40UL)         /*!< IO_CFG_IE_UART0_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_RX_IO_CFG_IS_UART0_RX_Pos (5UL)            /*!< IO_CFG_IS_UART0_RX (Bit 5)                            */
#define GPM_IO_CFG_UART0_RX_IO_CFG_IS_UART0_RX_Msk (0x20UL)         /*!< IO_CFG_IS_UART0_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_RX_IO_CFG_SR_UART0_RX_Pos (4UL)            /*!< IO_CFG_SR_UART0_RX (Bit 4)                            */
#define GPM_IO_CFG_UART0_RX_IO_CFG_SR_UART0_RX_Msk (0x10UL)         /*!< IO_CFG_SR_UART0_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_RX_IO_CFG_PE_UART0_RX_Pos (3UL)            /*!< IO_CFG_PE_UART0_RX (Bit 3)                            */
#define GPM_IO_CFG_UART0_RX_IO_CFG_PE_UART0_RX_Msk (0x8UL)          /*!< IO_CFG_PE_UART0_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_RX_IO_CFG_PS_UART0_RX_Pos (2UL)            /*!< IO_CFG_PS_UART0_RX (Bit 2)                            */
#define GPM_IO_CFG_UART0_RX_IO_CFG_PS_UART0_RX_Msk (0x4UL)          /*!< IO_CFG_PS_UART0_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_RX_IO_CFG_DS0_UART0_RX_Pos (1UL)           /*!< IO_CFG_DS0_UART0_RX (Bit 1)                           */
#define GPM_IO_CFG_UART0_RX_IO_CFG_DS0_UART0_RX_Msk (0x2UL)         /*!< IO_CFG_DS0_UART0_RX (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RX_IO_CFG_DS1_UART0_RX_Pos (0UL)           /*!< IO_CFG_DS1_UART0_RX (Bit 0)                           */
#define GPM_IO_CFG_UART0_RX_IO_CFG_DS1_UART0_RX_Msk (0x1UL)         /*!< IO_CFG_DS1_UART0_RX (Bitfield-Mask: 0x01)             */
/* =======================================================  UART0_TX  ======================================================== */
#define GPM_IO_CFG_UART0_TX_IO_CFG_IE_UART0_TX_Pos (6UL)            /*!< IO_CFG_IE_UART0_TX (Bit 6)                            */
#define GPM_IO_CFG_UART0_TX_IO_CFG_IE_UART0_TX_Msk (0x40UL)         /*!< IO_CFG_IE_UART0_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_TX_IO_CFG_IS_UART0_TX_Pos (5UL)            /*!< IO_CFG_IS_UART0_TX (Bit 5)                            */
#define GPM_IO_CFG_UART0_TX_IO_CFG_IS_UART0_TX_Msk (0x20UL)         /*!< IO_CFG_IS_UART0_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_TX_IO_CFG_SR_UART0_TX_Pos (4UL)            /*!< IO_CFG_SR_UART0_TX (Bit 4)                            */
#define GPM_IO_CFG_UART0_TX_IO_CFG_SR_UART0_TX_Msk (0x10UL)         /*!< IO_CFG_SR_UART0_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_TX_IO_CFG_PE_UART0_TX_Pos (3UL)            /*!< IO_CFG_PE_UART0_TX (Bit 3)                            */
#define GPM_IO_CFG_UART0_TX_IO_CFG_PE_UART0_TX_Msk (0x8UL)          /*!< IO_CFG_PE_UART0_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_TX_IO_CFG_PS_UART0_TX_Pos (2UL)            /*!< IO_CFG_PS_UART0_TX (Bit 2)                            */
#define GPM_IO_CFG_UART0_TX_IO_CFG_PS_UART0_TX_Msk (0x4UL)          /*!< IO_CFG_PS_UART0_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART0_TX_IO_CFG_DS0_UART0_TX_Pos (1UL)           /*!< IO_CFG_DS0_UART0_TX (Bit 1)                           */
#define GPM_IO_CFG_UART0_TX_IO_CFG_DS0_UART0_TX_Msk (0x2UL)         /*!< IO_CFG_DS0_UART0_TX (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_TX_IO_CFG_DS1_UART0_TX_Pos (0UL)           /*!< IO_CFG_DS1_UART0_TX (Bit 0)                           */
#define GPM_IO_CFG_UART0_TX_IO_CFG_DS1_UART0_TX_Msk (0x1UL)         /*!< IO_CFG_DS1_UART0_TX (Bitfield-Mask: 0x01)             */
/* =======================================================  UART0_CTS  ======================================================= */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_IE_UART0_CTS_Pos (6UL)          /*!< IO_CFG_IE_UART0_CTS (Bit 6)                           */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_IE_UART0_CTS_Msk (0x40UL)       /*!< IO_CFG_IE_UART0_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_IS_UART0_CTS_Pos (5UL)          /*!< IO_CFG_IS_UART0_CTS (Bit 5)                           */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_IS_UART0_CTS_Msk (0x20UL)       /*!< IO_CFG_IS_UART0_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_SR_UART0_CTS_Pos (4UL)          /*!< IO_CFG_SR_UART0_CTS (Bit 4)                           */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_SR_UART0_CTS_Msk (0x10UL)       /*!< IO_CFG_SR_UART0_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_PE_UART0_CTS_Pos (3UL)          /*!< IO_CFG_PE_UART0_CTS (Bit 3)                           */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_PE_UART0_CTS_Msk (0x8UL)        /*!< IO_CFG_PE_UART0_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_PS_UART0_CTS_Pos (2UL)          /*!< IO_CFG_PS_UART0_CTS (Bit 2)                           */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_PS_UART0_CTS_Msk (0x4UL)        /*!< IO_CFG_PS_UART0_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_DS0_UART0_CTS_Pos (1UL)         /*!< IO_CFG_DS0_UART0_CTS (Bit 1)                          */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_DS0_UART0_CTS_Msk (0x2UL)       /*!< IO_CFG_DS0_UART0_CTS (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_DS1_UART0_CTS_Pos (0UL)         /*!< IO_CFG_DS1_UART0_CTS (Bit 0)                          */
#define GPM_IO_CFG_UART0_CTS_IO_CFG_DS1_UART0_CTS_Msk (0x1UL)       /*!< IO_CFG_DS1_UART0_CTS (Bitfield-Mask: 0x01)            */
/* =======================================================  UART0_RTS  ======================================================= */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_IE_UART0_RTS_Pos (6UL)          /*!< IO_CFG_IE_UART0_RTS (Bit 6)                           */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_IE_UART0_RTS_Msk (0x40UL)       /*!< IO_CFG_IE_UART0_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_IS_UART0_RTS_Pos (5UL)          /*!< IO_CFG_IS_UART0_RTS (Bit 5)                           */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_IS_UART0_RTS_Msk (0x20UL)       /*!< IO_CFG_IS_UART0_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_SR_UART0_RTS_Pos (4UL)          /*!< IO_CFG_SR_UART0_RTS (Bit 4)                           */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_SR_UART0_RTS_Msk (0x10UL)       /*!< IO_CFG_SR_UART0_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_PE_UART0_RTS_Pos (3UL)          /*!< IO_CFG_PE_UART0_RTS (Bit 3)                           */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_PE_UART0_RTS_Msk (0x8UL)        /*!< IO_CFG_PE_UART0_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_PS_UART0_RTS_Pos (2UL)          /*!< IO_CFG_PS_UART0_RTS (Bit 2)                           */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_PS_UART0_RTS_Msk (0x4UL)        /*!< IO_CFG_PS_UART0_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_DS0_UART0_RTS_Pos (1UL)         /*!< IO_CFG_DS0_UART0_RTS (Bit 1)                          */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_DS0_UART0_RTS_Msk (0x2UL)       /*!< IO_CFG_DS0_UART0_RTS (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_DS1_UART0_RTS_Pos (0UL)         /*!< IO_CFG_DS1_UART0_RTS (Bit 0)                          */
#define GPM_IO_CFG_UART0_RTS_IO_CFG_DS1_UART0_RTS_Msk (0x1UL)       /*!< IO_CFG_DS1_UART0_RTS (Bitfield-Mask: 0x01)            */
/* =======================================================  UART2_RX  ======================================================== */
#define GPM_IO_CFG_UART2_RX_IO_CFG_IE_UART2_RX_Pos (6UL)            /*!< IO_CFG_IE_UART2_RX (Bit 6)                            */
#define GPM_IO_CFG_UART2_RX_IO_CFG_IE_UART2_RX_Msk (0x40UL)         /*!< IO_CFG_IE_UART2_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_RX_IO_CFG_IS_UART2_RX_Pos (5UL)            /*!< IO_CFG_IS_UART2_RX (Bit 5)                            */
#define GPM_IO_CFG_UART2_RX_IO_CFG_IS_UART2_RX_Msk (0x20UL)         /*!< IO_CFG_IS_UART2_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_RX_IO_CFG_SR_UART2_RX_Pos (4UL)            /*!< IO_CFG_SR_UART2_RX (Bit 4)                            */
#define GPM_IO_CFG_UART2_RX_IO_CFG_SR_UART2_RX_Msk (0x10UL)         /*!< IO_CFG_SR_UART2_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_RX_IO_CFG_PE_UART2_RX_Pos (3UL)            /*!< IO_CFG_PE_UART2_RX (Bit 3)                            */
#define GPM_IO_CFG_UART2_RX_IO_CFG_PE_UART2_RX_Msk (0x8UL)          /*!< IO_CFG_PE_UART2_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_RX_IO_CFG_PS_UART2_RX_Pos (2UL)            /*!< IO_CFG_PS_UART2_RX (Bit 2)                            */
#define GPM_IO_CFG_UART2_RX_IO_CFG_PS_UART2_RX_Msk (0x4UL)          /*!< IO_CFG_PS_UART2_RX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_RX_IO_CFG_DS0_UART2_RX_Pos (1UL)           /*!< IO_CFG_DS0_UART2_RX (Bit 1)                           */
#define GPM_IO_CFG_UART2_RX_IO_CFG_DS0_UART2_RX_Msk (0x2UL)         /*!< IO_CFG_DS0_UART2_RX (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RX_IO_CFG_DS1_UART2_RX_Pos (0UL)           /*!< IO_CFG_DS1_UART2_RX (Bit 0)                           */
#define GPM_IO_CFG_UART2_RX_IO_CFG_DS1_UART2_RX_Msk (0x1UL)         /*!< IO_CFG_DS1_UART2_RX (Bitfield-Mask: 0x01)             */
/* =======================================================  UART2_TX  ======================================================== */
#define GPM_IO_CFG_UART2_TX_IO_CFG_IE_UART2_TX_Pos (6UL)            /*!< IO_CFG_IE_UART2_TX (Bit 6)                            */
#define GPM_IO_CFG_UART2_TX_IO_CFG_IE_UART2_TX_Msk (0x40UL)         /*!< IO_CFG_IE_UART2_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_TX_IO_CFG_IS_UART2_TX_Pos (5UL)            /*!< IO_CFG_IS_UART2_TX (Bit 5)                            */
#define GPM_IO_CFG_UART2_TX_IO_CFG_IS_UART2_TX_Msk (0x20UL)         /*!< IO_CFG_IS_UART2_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_TX_IO_CFG_SR_UART2_TX_Pos (4UL)            /*!< IO_CFG_SR_UART2_TX (Bit 4)                            */
#define GPM_IO_CFG_UART2_TX_IO_CFG_SR_UART2_TX_Msk (0x10UL)         /*!< IO_CFG_SR_UART2_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_TX_IO_CFG_PE_UART2_TX_Pos (3UL)            /*!< IO_CFG_PE_UART2_TX (Bit 3)                            */
#define GPM_IO_CFG_UART2_TX_IO_CFG_PE_UART2_TX_Msk (0x8UL)          /*!< IO_CFG_PE_UART2_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_TX_IO_CFG_PS_UART2_TX_Pos (2UL)            /*!< IO_CFG_PS_UART2_TX (Bit 2)                            */
#define GPM_IO_CFG_UART2_TX_IO_CFG_PS_UART2_TX_Msk (0x4UL)          /*!< IO_CFG_PS_UART2_TX (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_UART2_TX_IO_CFG_DS0_UART2_TX_Pos (1UL)           /*!< IO_CFG_DS0_UART2_TX (Bit 1)                           */
#define GPM_IO_CFG_UART2_TX_IO_CFG_DS0_UART2_TX_Msk (0x2UL)         /*!< IO_CFG_DS0_UART2_TX (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_TX_IO_CFG_DS1_UART2_TX_Pos (0UL)           /*!< IO_CFG_DS1_UART2_TX (Bit 0)                           */
#define GPM_IO_CFG_UART2_TX_IO_CFG_DS1_UART2_TX_Msk (0x1UL)         /*!< IO_CFG_DS1_UART2_TX (Bitfield-Mask: 0x01)             */
/* =======================================================  UART2_CTS  ======================================================= */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_IE_UART2_CTS_Pos (6UL)          /*!< IO_CFG_IE_UART2_CTS (Bit 6)                           */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_IE_UART2_CTS_Msk (0x40UL)       /*!< IO_CFG_IE_UART2_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_IS_UART2_CTS_Pos (5UL)          /*!< IO_CFG_IS_UART2_CTS (Bit 5)                           */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_IS_UART2_CTS_Msk (0x20UL)       /*!< IO_CFG_IS_UART2_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_SR_UART2_CTS_Pos (4UL)          /*!< IO_CFG_SR_UART2_CTS (Bit 4)                           */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_SR_UART2_CTS_Msk (0x10UL)       /*!< IO_CFG_SR_UART2_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_PE_UART2_CTS_Pos (3UL)          /*!< IO_CFG_PE_UART2_CTS (Bit 3)                           */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_PE_UART2_CTS_Msk (0x8UL)        /*!< IO_CFG_PE_UART2_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_PS_UART2_CTS_Pos (2UL)          /*!< IO_CFG_PS_UART2_CTS (Bit 2)                           */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_PS_UART2_CTS_Msk (0x4UL)        /*!< IO_CFG_PS_UART2_CTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_DS0_UART2_CTS_Pos (1UL)         /*!< IO_CFG_DS0_UART2_CTS (Bit 1)                          */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_DS0_UART2_CTS_Msk (0x2UL)       /*!< IO_CFG_DS0_UART2_CTS (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_DS1_UART2_CTS_Pos (0UL)         /*!< IO_CFG_DS1_UART2_CTS (Bit 0)                          */
#define GPM_IO_CFG_UART2_CTS_IO_CFG_DS1_UART2_CTS_Msk (0x1UL)       /*!< IO_CFG_DS1_UART2_CTS (Bitfield-Mask: 0x01)            */
/* =======================================================  UART2_RTS  ======================================================= */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_IE_UART2_RTS_Pos (6UL)          /*!< IO_CFG_IE_UART2_RTS (Bit 6)                           */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_IE_UART2_RTS_Msk (0x40UL)       /*!< IO_CFG_IE_UART2_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_IS_UART2_RTS_Pos (5UL)          /*!< IO_CFG_IS_UART2_RTS (Bit 5)                           */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_IS_UART2_RTS_Msk (0x20UL)       /*!< IO_CFG_IS_UART2_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_SR_UART2_RTS_Pos (4UL)          /*!< IO_CFG_SR_UART2_RTS (Bit 4)                           */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_SR_UART2_RTS_Msk (0x10UL)       /*!< IO_CFG_SR_UART2_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_PE_UART2_RTS_Pos (3UL)          /*!< IO_CFG_PE_UART2_RTS (Bit 3)                           */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_PE_UART2_RTS_Msk (0x8UL)        /*!< IO_CFG_PE_UART2_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_PS_UART2_RTS_Pos (2UL)          /*!< IO_CFG_PS_UART2_RTS (Bit 2)                           */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_PS_UART2_RTS_Msk (0x4UL)        /*!< IO_CFG_PS_UART2_RTS (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_DS0_UART2_RTS_Pos (1UL)         /*!< IO_CFG_DS0_UART2_RTS (Bit 1)                          */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_DS0_UART2_RTS_Msk (0x2UL)       /*!< IO_CFG_DS0_UART2_RTS (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_DS1_UART2_RTS_Pos (0UL)         /*!< IO_CFG_DS1_UART2_RTS (Bit 0)                          */
#define GPM_IO_CFG_UART2_RTS_IO_CFG_DS1_UART2_RTS_Msk (0x1UL)       /*!< IO_CFG_DS1_UART2_RTS (Bitfield-Mask: 0x01)            */
/* =======================================================  DEBUG_SEL  ======================================================= */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_IE_DEBUG_SEL_Pos (6UL)          /*!< IO_CFG_IE_DEBUG_SEL (Bit 6)                           */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_IE_DEBUG_SEL_Msk (0x40UL)       /*!< IO_CFG_IE_DEBUG_SEL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_IS_DEBUG_SEL_Pos (5UL)          /*!< IO_CFG_IS_DEBUG_SEL (Bit 5)                           */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_IS_DEBUG_SEL_Msk (0x20UL)       /*!< IO_CFG_IS_DEBUG_SEL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_SR_DEBUG_SEL_Pos (4UL)          /*!< IO_CFG_SR_DEBUG_SEL (Bit 4)                           */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_SR_DEBUG_SEL_Msk (0x10UL)       /*!< IO_CFG_SR_DEBUG_SEL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_PE_DEBUG_SEL_Pos (3UL)          /*!< IO_CFG_PE_DEBUG_SEL (Bit 3)                           */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_PE_DEBUG_SEL_Msk (0x8UL)        /*!< IO_CFG_PE_DEBUG_SEL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_PS_DEBUG_SEL_Pos (2UL)          /*!< IO_CFG_PS_DEBUG_SEL (Bit 2)                           */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_PS_DEBUG_SEL_Msk (0x4UL)        /*!< IO_CFG_PS_DEBUG_SEL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_DS0_DEBUG_SEL_Pos (1UL)         /*!< IO_CFG_DS0_DEBUG_SEL (Bit 1)                          */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_DS0_DEBUG_SEL_Msk (0x2UL)       /*!< IO_CFG_DS0_DEBUG_SEL (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_DS1_DEBUG_SEL_Pos (0UL)         /*!< IO_CFG_DS1_DEBUG_SEL (Bit 0)                          */
#define GPM_IO_CFG_DEBUG_SEL_IO_CFG_DS1_DEBUG_SEL_Msk (0x1UL)       /*!< IO_CFG_DS1_DEBUG_SEL (Bitfield-Mask: 0x01)            */
/* ======================================================  DEBUG_RSTN  ======================================================= */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_IE_DEBUG_RSTN_Pos (6UL)        /*!< IO_CFG_IE_DEBUG_RSTN (Bit 6)                          */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_IE_DEBUG_RSTN_Msk (0x40UL)     /*!< IO_CFG_IE_DEBUG_RSTN (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_IS_DEBUG_RSTN_Pos (5UL)        /*!< IO_CFG_IS_DEBUG_RSTN (Bit 5)                          */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_IS_DEBUG_RSTN_Msk (0x20UL)     /*!< IO_CFG_IS_DEBUG_RSTN (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_SR_DEBUG_RSTN_Pos (4UL)        /*!< IO_CFG_SR_DEBUG_RSTN (Bit 4)                          */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_SR_DEBUG_RSTN_Msk (0x10UL)     /*!< IO_CFG_SR_DEBUG_RSTN (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_PE_DEBUG_RSTN_Pos (3UL)        /*!< IO_CFG_PE_DEBUG_RSTN (Bit 3)                          */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_PE_DEBUG_RSTN_Msk (0x8UL)      /*!< IO_CFG_PE_DEBUG_RSTN (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_PS_DEBUG_RSTN_Pos (2UL)        /*!< IO_CFG_PS_DEBUG_RSTN (Bit 2)                          */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_PS_DEBUG_RSTN_Msk (0x4UL)      /*!< IO_CFG_PS_DEBUG_RSTN (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_DS0_DEBUG_RSTN_Pos (1UL)       /*!< IO_CFG_DS0_DEBUG_RSTN (Bit 1)                         */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_DS0_DEBUG_RSTN_Msk (0x2UL)     /*!< IO_CFG_DS0_DEBUG_RSTN (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_DS1_DEBUG_RSTN_Pos (0UL)       /*!< IO_CFG_DS1_DEBUG_RSTN (Bit 0)                         */
#define GPM_IO_CFG_DEBUG_RSTN_IO_CFG_DS1_DEBUG_RSTN_Msk (0x1UL)     /*!< IO_CFG_DS1_DEBUG_RSTN (Bitfield-Mask: 0x01)           */
/* ======================================================  SPIM0_MOSI  ======================================================= */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_IE_SPIM0_MOSI_Pos (6UL)        /*!< IO_CFG_IE_SPIM0_MOSI (Bit 6)                          */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_IE_SPIM0_MOSI_Msk (0x40UL)     /*!< IO_CFG_IE_SPIM0_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_IS_SPIM0_MOSI_Pos (5UL)        /*!< IO_CFG_IS_SPIM0_MOSI (Bit 5)                          */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_IS_SPIM0_MOSI_Msk (0x20UL)     /*!< IO_CFG_IS_SPIM0_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_SR_SPIM0_MOSI_Pos (4UL)        /*!< IO_CFG_SR_SPIM0_MOSI (Bit 4)                          */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_SR_SPIM0_MOSI_Msk (0x10UL)     /*!< IO_CFG_SR_SPIM0_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_PE_SPIM0_MOSI_Pos (3UL)        /*!< IO_CFG_PE_SPIM0_MOSI (Bit 3)                          */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_PE_SPIM0_MOSI_Msk (0x8UL)      /*!< IO_CFG_PE_SPIM0_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_PS_SPIM0_MOSI_Pos (2UL)        /*!< IO_CFG_PS_SPIM0_MOSI (Bit 2)                          */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_PS_SPIM0_MOSI_Msk (0x4UL)      /*!< IO_CFG_PS_SPIM0_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_DS0_SPIM0_MOSI_Pos (1UL)       /*!< IO_CFG_DS0_SPIM0_MOSI (Bit 1)                         */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_DS0_SPIM0_MOSI_Msk (0x2UL)     /*!< IO_CFG_DS0_SPIM0_MOSI (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_DS1_SPIM0_MOSI_Pos (0UL)       /*!< IO_CFG_DS1_SPIM0_MOSI (Bit 0)                         */
#define GPM_IO_CFG_SPIM0_MOSI_IO_CFG_DS1_SPIM0_MOSI_Msk (0x1UL)     /*!< IO_CFG_DS1_SPIM0_MOSI (Bitfield-Mask: 0x01)           */
/* ======================================================  SPIM0_MISO  ======================================================= */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_IE_SPIM0_MISO_Pos (6UL)        /*!< IO_CFG_IE_SPIM0_MISO (Bit 6)                          */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_IE_SPIM0_MISO_Msk (0x40UL)     /*!< IO_CFG_IE_SPIM0_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_IS_SPIM0_MISO_Pos (5UL)        /*!< IO_CFG_IS_SPIM0_MISO (Bit 5)                          */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_IS_SPIM0_MISO_Msk (0x20UL)     /*!< IO_CFG_IS_SPIM0_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_SR_SPIM0_MISO_Pos (4UL)        /*!< IO_CFG_SR_SPIM0_MISO (Bit 4)                          */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_SR_SPIM0_MISO_Msk (0x10UL)     /*!< IO_CFG_SR_SPIM0_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_PE_SPIM0_MISO_Pos (3UL)        /*!< IO_CFG_PE_SPIM0_MISO (Bit 3)                          */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_PE_SPIM0_MISO_Msk (0x8UL)      /*!< IO_CFG_PE_SPIM0_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_PS_SPIM0_MISO_Pos (2UL)        /*!< IO_CFG_PS_SPIM0_MISO (Bit 2)                          */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_PS_SPIM0_MISO_Msk (0x4UL)      /*!< IO_CFG_PS_SPIM0_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_DS0_SPIM0_MISO_Pos (1UL)       /*!< IO_CFG_DS0_SPIM0_MISO (Bit 1)                         */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_DS0_SPIM0_MISO_Msk (0x2UL)     /*!< IO_CFG_DS0_SPIM0_MISO (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_DS1_SPIM0_MISO_Pos (0UL)       /*!< IO_CFG_DS1_SPIM0_MISO (Bit 0)                         */
#define GPM_IO_CFG_SPIM0_MISO_IO_CFG_DS1_SPIM0_MISO_Msk (0x1UL)     /*!< IO_CFG_DS1_SPIM0_MISO (Bitfield-Mask: 0x01)           */
/* =======================================================  SPIM0_EN0  ======================================================= */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_IE_SPIM0_EN0_Pos (6UL)          /*!< IO_CFG_IE_SPIM0_EN0 (Bit 6)                           */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_IE_SPIM0_EN0_Msk (0x40UL)       /*!< IO_CFG_IE_SPIM0_EN0 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_IS_SPIM0_EN0_Pos (5UL)          /*!< IO_CFG_IS_SPIM0_EN0 (Bit 5)                           */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_IS_SPIM0_EN0_Msk (0x20UL)       /*!< IO_CFG_IS_SPIM0_EN0 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_SR_SPIM0_EN0_Pos (4UL)          /*!< IO_CFG_SR_SPIM0_EN0 (Bit 4)                           */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_SR_SPIM0_EN0_Msk (0x10UL)       /*!< IO_CFG_SR_SPIM0_EN0 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_PE_SPIM0_EN0_Pos (3UL)          /*!< IO_CFG_PE_SPIM0_EN0 (Bit 3)                           */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_PE_SPIM0_EN0_Msk (0x8UL)        /*!< IO_CFG_PE_SPIM0_EN0 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_PS_SPIM0_EN0_Pos (2UL)          /*!< IO_CFG_PS_SPIM0_EN0 (Bit 2)                           */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_PS_SPIM0_EN0_Msk (0x4UL)        /*!< IO_CFG_PS_SPIM0_EN0 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_DS0_SPIM0_EN0_Pos (1UL)         /*!< IO_CFG_DS0_SPIM0_EN0 (Bit 1)                          */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_DS0_SPIM0_EN0_Msk (0x2UL)       /*!< IO_CFG_DS0_SPIM0_EN0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_DS1_SPIM0_EN0_Pos (0UL)         /*!< IO_CFG_DS1_SPIM0_EN0 (Bit 0)                          */
#define GPM_IO_CFG_SPIM0_EN0_IO_CFG_DS1_SPIM0_EN0_Msk (0x1UL)       /*!< IO_CFG_DS1_SPIM0_EN0 (Bitfield-Mask: 0x01)            */
/* =======================================================  SPIM0_EN1  ======================================================= */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_IE_SPIM0_EN1_Pos (6UL)          /*!< IO_CFG_IE_SPIM0_EN1 (Bit 6)                           */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_IE_SPIM0_EN1_Msk (0x40UL)       /*!< IO_CFG_IE_SPIM0_EN1 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_IS_SPIM0_EN1_Pos (5UL)          /*!< IO_CFG_IS_SPIM0_EN1 (Bit 5)                           */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_IS_SPIM0_EN1_Msk (0x20UL)       /*!< IO_CFG_IS_SPIM0_EN1 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_SR_SPIM0_EN1_Pos (4UL)          /*!< IO_CFG_SR_SPIM0_EN1 (Bit 4)                           */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_SR_SPIM0_EN1_Msk (0x10UL)       /*!< IO_CFG_SR_SPIM0_EN1 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_PE_SPIM0_EN1_Pos (3UL)          /*!< IO_CFG_PE_SPIM0_EN1 (Bit 3)                           */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_PE_SPIM0_EN1_Msk (0x8UL)        /*!< IO_CFG_PE_SPIM0_EN1 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_PS_SPIM0_EN1_Pos (2UL)          /*!< IO_CFG_PS_SPIM0_EN1 (Bit 2)                           */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_PS_SPIM0_EN1_Msk (0x4UL)        /*!< IO_CFG_PS_SPIM0_EN1 (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_DS0_SPIM0_EN1_Pos (1UL)         /*!< IO_CFG_DS0_SPIM0_EN1 (Bit 1)                          */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_DS0_SPIM0_EN1_Msk (0x2UL)       /*!< IO_CFG_DS0_SPIM0_EN1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_DS1_SPIM0_EN1_Pos (0UL)         /*!< IO_CFG_DS1_SPIM0_EN1 (Bit 0)                          */
#define GPM_IO_CFG_SPIM0_EN1_IO_CFG_DS1_SPIM0_EN1_Msk (0x1UL)       /*!< IO_CFG_DS1_SPIM0_EN1 (Bitfield-Mask: 0x01)            */
/* =======================================================  SPIM0_CLK  ======================================================= */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_IE_SPIM0_CLK_Pos (6UL)          /*!< IO_CFG_IE_SPIM0_CLK (Bit 6)                           */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_IE_SPIM0_CLK_Msk (0x40UL)       /*!< IO_CFG_IE_SPIM0_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_IS_SPIM0_CLK_Pos (5UL)          /*!< IO_CFG_IS_SPIM0_CLK (Bit 5)                           */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_IS_SPIM0_CLK_Msk (0x20UL)       /*!< IO_CFG_IS_SPIM0_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_SR_SPIM0_CLK_Pos (4UL)          /*!< IO_CFG_SR_SPIM0_CLK (Bit 4)                           */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_SR_SPIM0_CLK_Msk (0x10UL)       /*!< IO_CFG_SR_SPIM0_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_PE_SPIM0_CLK_Pos (3UL)          /*!< IO_CFG_PE_SPIM0_CLK (Bit 3)                           */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_PE_SPIM0_CLK_Msk (0x8UL)        /*!< IO_CFG_PE_SPIM0_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_PS_SPIM0_CLK_Pos (2UL)          /*!< IO_CFG_PS_SPIM0_CLK (Bit 2)                           */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_PS_SPIM0_CLK_Msk (0x4UL)        /*!< IO_CFG_PS_SPIM0_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_DS0_SPIM0_CLK_Pos (1UL)         /*!< IO_CFG_DS0_SPIM0_CLK (Bit 1)                          */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_DS0_SPIM0_CLK_Msk (0x2UL)       /*!< IO_CFG_DS0_SPIM0_CLK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_DS1_SPIM0_CLK_Pos (0UL)         /*!< IO_CFG_DS1_SPIM0_CLK (Bit 0)                          */
#define GPM_IO_CFG_SPIM0_CLK_IO_CFG_DS1_SPIM0_CLK_Msk (0x1UL)       /*!< IO_CFG_DS1_SPIM0_CLK (Bitfield-Mask: 0x01)            */
/* ======================================================  SPIM1_MOSI  ======================================================= */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_IE_SPIM1_MOSI_Pos (6UL)        /*!< IO_CFG_IE_SPIM1_MOSI (Bit 6)                          */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_IE_SPIM1_MOSI_Msk (0x40UL)     /*!< IO_CFG_IE_SPIM1_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_IS_SPIM1_MOSI_Pos (5UL)        /*!< IO_CFG_IS_SPIM1_MOSI (Bit 5)                          */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_IS_SPIM1_MOSI_Msk (0x20UL)     /*!< IO_CFG_IS_SPIM1_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_SR_SPIM1_MOSI_Pos (4UL)        /*!< IO_CFG_SR_SPIM1_MOSI (Bit 4)                          */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_SR_SPIM1_MOSI_Msk (0x10UL)     /*!< IO_CFG_SR_SPIM1_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_PE_SPIM1_MOSI_Pos (3UL)        /*!< IO_CFG_PE_SPIM1_MOSI (Bit 3)                          */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_PE_SPIM1_MOSI_Msk (0x8UL)      /*!< IO_CFG_PE_SPIM1_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_PS_SPIM1_MOSI_Pos (2UL)        /*!< IO_CFG_PS_SPIM1_MOSI (Bit 2)                          */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_PS_SPIM1_MOSI_Msk (0x4UL)      /*!< IO_CFG_PS_SPIM1_MOSI (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_DS0_SPIM1_MOSI_Pos (1UL)       /*!< IO_CFG_DS0_SPIM1_MOSI (Bit 1)                         */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_DS0_SPIM1_MOSI_Msk (0x2UL)     /*!< IO_CFG_DS0_SPIM1_MOSI (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_DS1_SPIM1_MOSI_Pos (0UL)       /*!< IO_CFG_DS1_SPIM1_MOSI (Bit 0)                         */
#define GPM_IO_CFG_SPIM1_MOSI_IO_CFG_DS1_SPIM1_MOSI_Msk (0x1UL)     /*!< IO_CFG_DS1_SPIM1_MOSI (Bitfield-Mask: 0x01)           */
/* ======================================================  SPIM1_MISO  ======================================================= */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_IE_SPIM1_MISO_Pos (6UL)        /*!< IO_CFG_IE_SPIM1_MISO (Bit 6)                          */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_IE_SPIM1_MISO_Msk (0x40UL)     /*!< IO_CFG_IE_SPIM1_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_IS_SPIM1_MISO_Pos (5UL)        /*!< IO_CFG_IS_SPIM1_MISO (Bit 5)                          */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_IS_SPIM1_MISO_Msk (0x20UL)     /*!< IO_CFG_IS_SPIM1_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_SR_SPIM1_MISO_Pos (4UL)        /*!< IO_CFG_SR_SPIM1_MISO (Bit 4)                          */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_SR_SPIM1_MISO_Msk (0x10UL)     /*!< IO_CFG_SR_SPIM1_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_PE_SPIM1_MISO_Pos (3UL)        /*!< IO_CFG_PE_SPIM1_MISO (Bit 3)                          */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_PE_SPIM1_MISO_Msk (0x8UL)      /*!< IO_CFG_PE_SPIM1_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_PS_SPIM1_MISO_Pos (2UL)        /*!< IO_CFG_PS_SPIM1_MISO (Bit 2)                          */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_PS_SPIM1_MISO_Msk (0x4UL)      /*!< IO_CFG_PS_SPIM1_MISO (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_DS0_SPIM1_MISO_Pos (1UL)       /*!< IO_CFG_DS0_SPIM1_MISO (Bit 1)                         */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_DS0_SPIM1_MISO_Msk (0x2UL)     /*!< IO_CFG_DS0_SPIM1_MISO (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_DS1_SPIM1_MISO_Pos (0UL)       /*!< IO_CFG_DS1_SPIM1_MISO (Bit 0)                         */
#define GPM_IO_CFG_SPIM1_MISO_IO_CFG_DS1_SPIM1_MISO_Msk (0x1UL)     /*!< IO_CFG_DS1_SPIM1_MISO (Bitfield-Mask: 0x01)           */
/* =======================================================  SPIM1_EN  ======================================================== */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_IE_SPIM1_EN_Pos (6UL)            /*!< IO_CFG_IE_SPIM1_EN (Bit 6)                            */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_IE_SPIM1_EN_Msk (0x40UL)         /*!< IO_CFG_IE_SPIM1_EN (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_IS_SPIM1_EN_Pos (5UL)            /*!< IO_CFG_IS_SPIM1_EN (Bit 5)                            */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_IS_SPIM1_EN_Msk (0x20UL)         /*!< IO_CFG_IS_SPIM1_EN (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_SR_SPIM1_EN_Pos (4UL)            /*!< IO_CFG_SR_SPIM1_EN (Bit 4)                            */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_SR_SPIM1_EN_Msk (0x10UL)         /*!< IO_CFG_SR_SPIM1_EN (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_PE_SPIM1_EN_Pos (3UL)            /*!< IO_CFG_PE_SPIM1_EN (Bit 3)                            */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_PE_SPIM1_EN_Msk (0x8UL)          /*!< IO_CFG_PE_SPIM1_EN (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_PS_SPIM1_EN_Pos (2UL)            /*!< IO_CFG_PS_SPIM1_EN (Bit 2)                            */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_PS_SPIM1_EN_Msk (0x4UL)          /*!< IO_CFG_PS_SPIM1_EN (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_DS0_SPIM1_EN_Pos (1UL)           /*!< IO_CFG_DS0_SPIM1_EN (Bit 1)                           */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_DS0_SPIM1_EN_Msk (0x2UL)         /*!< IO_CFG_DS0_SPIM1_EN (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_DS1_SPIM1_EN_Pos (0UL)           /*!< IO_CFG_DS1_SPIM1_EN (Bit 0)                           */
#define GPM_IO_CFG_SPIM1_EN_IO_CFG_DS1_SPIM1_EN_Msk (0x1UL)         /*!< IO_CFG_DS1_SPIM1_EN (Bitfield-Mask: 0x01)             */
/* =======================================================  SPIM1_CLK  ======================================================= */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_IE_SPIM1_CLK_Pos (6UL)          /*!< IO_CFG_IE_SPIM1_CLK (Bit 6)                           */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_IE_SPIM1_CLK_Msk (0x40UL)       /*!< IO_CFG_IE_SPIM1_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_IS_SPIM1_CLK_Pos (5UL)          /*!< IO_CFG_IS_SPIM1_CLK (Bit 5)                           */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_IS_SPIM1_CLK_Msk (0x20UL)       /*!< IO_CFG_IS_SPIM1_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_SR_SPIM1_CLK_Pos (4UL)          /*!< IO_CFG_SR_SPIM1_CLK (Bit 4)                           */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_SR_SPIM1_CLK_Msk (0x10UL)       /*!< IO_CFG_SR_SPIM1_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_PE_SPIM1_CLK_Pos (3UL)          /*!< IO_CFG_PE_SPIM1_CLK (Bit 3)                           */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_PE_SPIM1_CLK_Msk (0x8UL)        /*!< IO_CFG_PE_SPIM1_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_PS_SPIM1_CLK_Pos (2UL)          /*!< IO_CFG_PS_SPIM1_CLK (Bit 2)                           */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_PS_SPIM1_CLK_Msk (0x4UL)        /*!< IO_CFG_PS_SPIM1_CLK (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_DS0_SPIM1_CLK_Pos (1UL)         /*!< IO_CFG_DS0_SPIM1_CLK (Bit 1)                          */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_DS0_SPIM1_CLK_Msk (0x2UL)       /*!< IO_CFG_DS0_SPIM1_CLK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_DS1_SPIM1_CLK_Pos (0UL)         /*!< IO_CFG_DS1_SPIM1_CLK (Bit 0)                          */
#define GPM_IO_CFG_SPIM1_CLK_IO_CFG_DS1_SPIM1_CLK_Msk (0x1UL)       /*!< IO_CFG_DS1_SPIM1_CLK (Bitfield-Mask: 0x01)            */
/* =======================================================  I2C0_SDA  ======================================================== */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_IE_I2C0_SDA_Pos (6UL)            /*!< IO_CFG_IE_I2C0_SDA (Bit 6)                            */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_IE_I2C0_SDA_Msk (0x40UL)         /*!< IO_CFG_IE_I2C0_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_IS_I2C0_SDA_Pos (5UL)            /*!< IO_CFG_IS_I2C0_SDA (Bit 5)                            */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_IS_I2C0_SDA_Msk (0x20UL)         /*!< IO_CFG_IS_I2C0_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_SR_I2C0_SDA_Pos (4UL)            /*!< IO_CFG_SR_I2C0_SDA (Bit 4)                            */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_SR_I2C0_SDA_Msk (0x10UL)         /*!< IO_CFG_SR_I2C0_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_PE_I2C0_SDA_Pos (3UL)            /*!< IO_CFG_PE_I2C0_SDA (Bit 3)                            */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_PE_I2C0_SDA_Msk (0x8UL)          /*!< IO_CFG_PE_I2C0_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_PS_I2C0_SDA_Pos (2UL)            /*!< IO_CFG_PS_I2C0_SDA (Bit 2)                            */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_PS_I2C0_SDA_Msk (0x4UL)          /*!< IO_CFG_PS_I2C0_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_DS0_I2C0_SDA_Pos (1UL)           /*!< IO_CFG_DS0_I2C0_SDA (Bit 1)                           */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_DS0_I2C0_SDA_Msk (0x2UL)         /*!< IO_CFG_DS0_I2C0_SDA (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_DS1_I2C0_SDA_Pos (0UL)           /*!< IO_CFG_DS1_I2C0_SDA (Bit 0)                           */
#define GPM_IO_CFG_I2C0_SDA_IO_CFG_DS1_I2C0_SDA_Msk (0x1UL)         /*!< IO_CFG_DS1_I2C0_SDA (Bitfield-Mask: 0x01)             */
/* =======================================================  I2C0_SCL  ======================================================== */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_IE_I2C0_SCL_Pos (6UL)            /*!< IO_CFG_IE_I2C0_SCL (Bit 6)                            */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_IE_I2C0_SCL_Msk (0x40UL)         /*!< IO_CFG_IE_I2C0_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_IS_I2C0_SCL_Pos (5UL)            /*!< IO_CFG_IS_I2C0_SCL (Bit 5)                            */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_IS_I2C0_SCL_Msk (0x20UL)         /*!< IO_CFG_IS_I2C0_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_SR_I2C0_SCL_Pos (4UL)            /*!< IO_CFG_SR_I2C0_SCL (Bit 4)                            */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_SR_I2C0_SCL_Msk (0x10UL)         /*!< IO_CFG_SR_I2C0_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_PE_I2C0_SCL_Pos (3UL)            /*!< IO_CFG_PE_I2C0_SCL (Bit 3)                            */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_PE_I2C0_SCL_Msk (0x8UL)          /*!< IO_CFG_PE_I2C0_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_PS_I2C0_SCL_Pos (2UL)            /*!< IO_CFG_PS_I2C0_SCL (Bit 2)                            */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_PS_I2C0_SCL_Msk (0x4UL)          /*!< IO_CFG_PS_I2C0_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_DS0_I2C0_SCL_Pos (1UL)           /*!< IO_CFG_DS0_I2C0_SCL (Bit 1)                           */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_DS0_I2C0_SCL_Msk (0x2UL)         /*!< IO_CFG_DS0_I2C0_SCL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_DS1_I2C0_SCL_Pos (0UL)           /*!< IO_CFG_DS1_I2C0_SCL (Bit 0)                           */
#define GPM_IO_CFG_I2C0_SCL_IO_CFG_DS1_I2C0_SCL_Msk (0x1UL)         /*!< IO_CFG_DS1_I2C0_SCL (Bitfield-Mask: 0x01)             */
/* =======================================================  I2C1_SDA  ======================================================== */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_IE_I2C1_SDA_Pos (6UL)            /*!< IO_CFG_IE_I2C1_SDA (Bit 6)                            */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_IE_I2C1_SDA_Msk (0x40UL)         /*!< IO_CFG_IE_I2C1_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_IS_I2C1_SDA_Pos (5UL)            /*!< IO_CFG_IS_I2C1_SDA (Bit 5)                            */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_IS_I2C1_SDA_Msk (0x20UL)         /*!< IO_CFG_IS_I2C1_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_SR_I2C1_SDA_Pos (4UL)            /*!< IO_CFG_SR_I2C1_SDA (Bit 4)                            */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_SR_I2C1_SDA_Msk (0x10UL)         /*!< IO_CFG_SR_I2C1_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_PE_I2C1_SDA_Pos (3UL)            /*!< IO_CFG_PE_I2C1_SDA (Bit 3)                            */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_PE_I2C1_SDA_Msk (0x8UL)          /*!< IO_CFG_PE_I2C1_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_PS_I2C1_SDA_Pos (2UL)            /*!< IO_CFG_PS_I2C1_SDA (Bit 2)                            */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_PS_I2C1_SDA_Msk (0x4UL)          /*!< IO_CFG_PS_I2C1_SDA (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_DS0_I2C1_SDA_Pos (1UL)           /*!< IO_CFG_DS0_I2C1_SDA (Bit 1)                           */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_DS0_I2C1_SDA_Msk (0x2UL)         /*!< IO_CFG_DS0_I2C1_SDA (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_DS1_I2C1_SDA_Pos (0UL)           /*!< IO_CFG_DS1_I2C1_SDA (Bit 0)                           */
#define GPM_IO_CFG_I2C1_SDA_IO_CFG_DS1_I2C1_SDA_Msk (0x1UL)         /*!< IO_CFG_DS1_I2C1_SDA (Bitfield-Mask: 0x01)             */
/* =======================================================  I2C1_SCL  ======================================================== */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_IE_I2C1_SCL_Pos (6UL)            /*!< IO_CFG_IE_I2C1_SCL (Bit 6)                            */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_IE_I2C1_SCL_Msk (0x40UL)         /*!< IO_CFG_IE_I2C1_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_IS_I2C1_SCL_Pos (5UL)            /*!< IO_CFG_IS_I2C1_SCL (Bit 5)                            */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_IS_I2C1_SCL_Msk (0x20UL)         /*!< IO_CFG_IS_I2C1_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_SR_I2C1_SCL_Pos (4UL)            /*!< IO_CFG_SR_I2C1_SCL (Bit 4)                            */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_SR_I2C1_SCL_Msk (0x10UL)         /*!< IO_CFG_SR_I2C1_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_PE_I2C1_SCL_Pos (3UL)            /*!< IO_CFG_PE_I2C1_SCL (Bit 3)                            */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_PE_I2C1_SCL_Msk (0x8UL)          /*!< IO_CFG_PE_I2C1_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_PS_I2C1_SCL_Pos (2UL)            /*!< IO_CFG_PS_I2C1_SCL (Bit 2)                            */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_PS_I2C1_SCL_Msk (0x4UL)          /*!< IO_CFG_PS_I2C1_SCL (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_DS0_I2C1_SCL_Pos (1UL)           /*!< IO_CFG_DS0_I2C1_SCL (Bit 1)                           */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_DS0_I2C1_SCL_Msk (0x2UL)         /*!< IO_CFG_DS0_I2C1_SCL (Bitfield-Mask: 0x01)             */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_DS1_I2C1_SCL_Pos (0UL)           /*!< IO_CFG_DS1_I2C1_SCL (Bit 0)                           */
#define GPM_IO_CFG_I2C1_SCL_IO_CFG_DS1_I2C1_SCL_Msk (0x1UL)         /*!< IO_CFG_DS1_I2C1_SCL (Bitfield-Mask: 0x01)             */
/* ========================================================  PCM_CLK  ======================================================== */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_IE_PCM_CLK_Pos (6UL)              /*!< IO_CFG_IE_PCM_CLK (Bit 6)                             */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_IE_PCM_CLK_Msk (0x40UL)           /*!< IO_CFG_IE_PCM_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_IS_PCM_CLK_Pos (5UL)              /*!< IO_CFG_IS_PCM_CLK (Bit 5)                             */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_IS_PCM_CLK_Msk (0x20UL)           /*!< IO_CFG_IS_PCM_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_SR_PCM_CLK_Pos (4UL)              /*!< IO_CFG_SR_PCM_CLK (Bit 4)                             */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_SR_PCM_CLK_Msk (0x10UL)           /*!< IO_CFG_SR_PCM_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_PE_PCM_CLK_Pos (3UL)              /*!< IO_CFG_PE_PCM_CLK (Bit 3)                             */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_PE_PCM_CLK_Msk (0x8UL)            /*!< IO_CFG_PE_PCM_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_PS_PCM_CLK_Pos (2UL)              /*!< IO_CFG_PS_PCM_CLK (Bit 2)                             */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_PS_PCM_CLK_Msk (0x4UL)            /*!< IO_CFG_PS_PCM_CLK (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_DS0_PCM_CLK_Pos (1UL)             /*!< IO_CFG_DS0_PCM_CLK (Bit 1)                            */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_DS0_PCM_CLK_Msk (0x2UL)           /*!< IO_CFG_DS0_PCM_CLK (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_DS1_PCM_CLK_Pos (0UL)             /*!< IO_CFG_DS1_PCM_CLK (Bit 0)                            */
#define GPM_IO_CFG_PCM_CLK_IO_CFG_DS1_PCM_CLK_Msk (0x1UL)           /*!< IO_CFG_DS1_PCM_CLK (Bitfield-Mask: 0x01)              */
/* ========================================================  PCM_FS  ========================================================= */
#define GPM_IO_CFG_PCM_FS_IO_CFG_IE_PCM_FS_Pos (6UL)                /*!< IO_CFG_IE_PCM_FS (Bit 6)                              */
#define GPM_IO_CFG_PCM_FS_IO_CFG_IE_PCM_FS_Msk (0x40UL)             /*!< IO_CFG_IE_PCM_FS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_FS_IO_CFG_IS_PCM_FS_Pos (5UL)                /*!< IO_CFG_IS_PCM_FS (Bit 5)                              */
#define GPM_IO_CFG_PCM_FS_IO_CFG_IS_PCM_FS_Msk (0x20UL)             /*!< IO_CFG_IS_PCM_FS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_FS_IO_CFG_SR_PCM_FS_Pos (4UL)                /*!< IO_CFG_SR_PCM_FS (Bit 4)                              */
#define GPM_IO_CFG_PCM_FS_IO_CFG_SR_PCM_FS_Msk (0x10UL)             /*!< IO_CFG_SR_PCM_FS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_FS_IO_CFG_PE_PCM_FS_Pos (3UL)                /*!< IO_CFG_PE_PCM_FS (Bit 3)                              */
#define GPM_IO_CFG_PCM_FS_IO_CFG_PE_PCM_FS_Msk (0x8UL)              /*!< IO_CFG_PE_PCM_FS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_FS_IO_CFG_PS_PCM_FS_Pos (2UL)                /*!< IO_CFG_PS_PCM_FS (Bit 2)                              */
#define GPM_IO_CFG_PCM_FS_IO_CFG_PS_PCM_FS_Msk (0x4UL)              /*!< IO_CFG_PS_PCM_FS (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_FS_IO_CFG_DS0_PCM_FS_Pos (1UL)               /*!< IO_CFG_DS0_PCM_FS (Bit 1)                             */
#define GPM_IO_CFG_PCM_FS_IO_CFG_DS0_PCM_FS_Msk (0x2UL)             /*!< IO_CFG_DS0_PCM_FS (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_FS_IO_CFG_DS1_PCM_FS_Pos (0UL)               /*!< IO_CFG_DS1_PCM_FS (Bit 0)                             */
#define GPM_IO_CFG_PCM_FS_IO_CFG_DS1_PCM_FS_Msk (0x1UL)             /*!< IO_CFG_DS1_PCM_FS (Bitfield-Mask: 0x01)               */
/* ========================================================  PCM_IN  ========================================================= */
#define GPM_IO_CFG_PCM_IN_IO_CFG_IE_PCM_IN_Pos (6UL)                /*!< IO_CFG_IE_PCM_IN (Bit 6)                              */
#define GPM_IO_CFG_PCM_IN_IO_CFG_IE_PCM_IN_Msk (0x40UL)             /*!< IO_CFG_IE_PCM_IN (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_IN_IO_CFG_IS_PCM_IN_Pos (5UL)                /*!< IO_CFG_IS_PCM_IN (Bit 5)                              */
#define GPM_IO_CFG_PCM_IN_IO_CFG_IS_PCM_IN_Msk (0x20UL)             /*!< IO_CFG_IS_PCM_IN (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_IN_IO_CFG_SR_PCM_IN_Pos (4UL)                /*!< IO_CFG_SR_PCM_IN (Bit 4)                              */
#define GPM_IO_CFG_PCM_IN_IO_CFG_SR_PCM_IN_Msk (0x10UL)             /*!< IO_CFG_SR_PCM_IN (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_IN_IO_CFG_PE_PCM_IN_Pos (3UL)                /*!< IO_CFG_PE_PCM_IN (Bit 3)                              */
#define GPM_IO_CFG_PCM_IN_IO_CFG_PE_PCM_IN_Msk (0x8UL)              /*!< IO_CFG_PE_PCM_IN (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_IN_IO_CFG_PS_PCM_IN_Pos (2UL)                /*!< IO_CFG_PS_PCM_IN (Bit 2)                              */
#define GPM_IO_CFG_PCM_IN_IO_CFG_PS_PCM_IN_Msk (0x4UL)              /*!< IO_CFG_PS_PCM_IN (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_PCM_IN_IO_CFG_DS0_PCM_IN_Pos (1UL)               /*!< IO_CFG_DS0_PCM_IN (Bit 1)                             */
#define GPM_IO_CFG_PCM_IN_IO_CFG_DS0_PCM_IN_Msk (0x2UL)             /*!< IO_CFG_DS0_PCM_IN (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_IN_IO_CFG_DS1_PCM_IN_Pos (0UL)               /*!< IO_CFG_DS1_PCM_IN (Bit 0)                             */
#define GPM_IO_CFG_PCM_IN_IO_CFG_DS1_PCM_IN_Msk (0x1UL)             /*!< IO_CFG_DS1_PCM_IN (Bitfield-Mask: 0x01)               */
/* ========================================================  PCM_OUT  ======================================================== */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_IE_PCM_OUT_Pos (6UL)              /*!< IO_CFG_IE_PCM_OUT (Bit 6)                             */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_IE_PCM_OUT_Msk (0x40UL)           /*!< IO_CFG_IE_PCM_OUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_IS_PCM_OUT_Pos (5UL)              /*!< IO_CFG_IS_PCM_OUT (Bit 5)                             */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_IS_PCM_OUT_Msk (0x20UL)           /*!< IO_CFG_IS_PCM_OUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_SR_PCM_OUT_Pos (4UL)              /*!< IO_CFG_SR_PCM_OUT (Bit 4)                             */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_SR_PCM_OUT_Msk (0x10UL)           /*!< IO_CFG_SR_PCM_OUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_PE_PCM_OUT_Pos (3UL)              /*!< IO_CFG_PE_PCM_OUT (Bit 3)                             */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_PE_PCM_OUT_Msk (0x8UL)            /*!< IO_CFG_PE_PCM_OUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_PS_PCM_OUT_Pos (2UL)              /*!< IO_CFG_PS_PCM_OUT (Bit 2)                             */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_PS_PCM_OUT_Msk (0x4UL)            /*!< IO_CFG_PS_PCM_OUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_DS0_PCM_OUT_Pos (1UL)             /*!< IO_CFG_DS0_PCM_OUT (Bit 1)                            */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_DS0_PCM_OUT_Msk (0x2UL)           /*!< IO_CFG_DS0_PCM_OUT (Bitfield-Mask: 0x01)              */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_DS1_PCM_OUT_Pos (0UL)             /*!< IO_CFG_DS1_PCM_OUT (Bit 0)                            */
#define GPM_IO_CFG_PCM_OUT_IO_CFG_DS1_PCM_OUT_Msk (0x1UL)           /*!< IO_CFG_DS1_PCM_OUT (Bitfield-Mask: 0x01)              */
/* =========================================================  PWM0  ========================================================== */
#define GPM_IO_CFG_PWM0_IO_CFG_IE_PWM0_Pos (6UL)                    /*!< IO_CFG_IE_PWM0 (Bit 6)                                */
#define GPM_IO_CFG_PWM0_IO_CFG_IE_PWM0_Msk (0x40UL)                 /*!< IO_CFG_IE_PWM0 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM0_IO_CFG_IS_PWM0_Pos (5UL)                    /*!< IO_CFG_IS_PWM0 (Bit 5)                                */
#define GPM_IO_CFG_PWM0_IO_CFG_IS_PWM0_Msk (0x20UL)                 /*!< IO_CFG_IS_PWM0 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM0_IO_CFG_SR_PWM0_Pos (4UL)                    /*!< IO_CFG_SR_PWM0 (Bit 4)                                */
#define GPM_IO_CFG_PWM0_IO_CFG_SR_PWM0_Msk (0x10UL)                 /*!< IO_CFG_SR_PWM0 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM0_IO_CFG_PE_PWM0_Pos (3UL)                    /*!< IO_CFG_PE_PWM0 (Bit 3)                                */
#define GPM_IO_CFG_PWM0_IO_CFG_PE_PWM0_Msk (0x8UL)                  /*!< IO_CFG_PE_PWM0 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM0_IO_CFG_PS_PWM0_Pos (2UL)                    /*!< IO_CFG_PS_PWM0 (Bit 2)                                */
#define GPM_IO_CFG_PWM0_IO_CFG_PS_PWM0_Msk (0x4UL)                  /*!< IO_CFG_PS_PWM0 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM0_IO_CFG_DS0_PWM0_Pos (1UL)                   /*!< IO_CFG_DS0_PWM0 (Bit 1)                               */
#define GPM_IO_CFG_PWM0_IO_CFG_DS0_PWM0_Msk (0x2UL)                 /*!< IO_CFG_DS0_PWM0 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_PWM0_IO_CFG_DS1_PWM0_Pos (0UL)                   /*!< IO_CFG_DS1_PWM0 (Bit 0)                               */
#define GPM_IO_CFG_PWM0_IO_CFG_DS1_PWM0_Msk (0x1UL)                 /*!< IO_CFG_DS1_PWM0 (Bitfield-Mask: 0x01)                 */
/* =========================================================  PWM1  ========================================================== */
#define GPM_IO_CFG_PWM1_IO_CFG_IE_PWM1_Pos (6UL)                    /*!< IO_CFG_IE_PWM1 (Bit 6)                                */
#define GPM_IO_CFG_PWM1_IO_CFG_IE_PWM1_Msk (0x40UL)                 /*!< IO_CFG_IE_PWM1 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM1_IO_CFG_IS_PWM1_Pos (5UL)                    /*!< IO_CFG_IS_PWM1 (Bit 5)                                */
#define GPM_IO_CFG_PWM1_IO_CFG_IS_PWM1_Msk (0x20UL)                 /*!< IO_CFG_IS_PWM1 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM1_IO_CFG_SR_PWM1_Pos (4UL)                    /*!< IO_CFG_SR_PWM1 (Bit 4)                                */
#define GPM_IO_CFG_PWM1_IO_CFG_SR_PWM1_Msk (0x10UL)                 /*!< IO_CFG_SR_PWM1 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM1_IO_CFG_PE_PWM1_Pos (3UL)                    /*!< IO_CFG_PE_PWM1 (Bit 3)                                */
#define GPM_IO_CFG_PWM1_IO_CFG_PE_PWM1_Msk (0x8UL)                  /*!< IO_CFG_PE_PWM1 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM1_IO_CFG_PS_PWM1_Pos (2UL)                    /*!< IO_CFG_PS_PWM1 (Bit 2)                                */
#define GPM_IO_CFG_PWM1_IO_CFG_PS_PWM1_Msk (0x4UL)                  /*!< IO_CFG_PS_PWM1 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM1_IO_CFG_DS0_PWM1_Pos (1UL)                   /*!< IO_CFG_DS0_PWM1 (Bit 1)                               */
#define GPM_IO_CFG_PWM1_IO_CFG_DS0_PWM1_Msk (0x2UL)                 /*!< IO_CFG_DS0_PWM1 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_PWM1_IO_CFG_DS1_PWM1_Pos (0UL)                   /*!< IO_CFG_DS1_PWM1 (Bit 0)                               */
#define GPM_IO_CFG_PWM1_IO_CFG_DS1_PWM1_Msk (0x1UL)                 /*!< IO_CFG_DS1_PWM1 (Bitfield-Mask: 0x01)                 */
/* =========================================================  PWM2  ========================================================== */
#define GPM_IO_CFG_PWM2_IO_CFG_IE_PWM2_Pos (6UL)                    /*!< IO_CFG_IE_PWM2 (Bit 6)                                */
#define GPM_IO_CFG_PWM2_IO_CFG_IE_PWM2_Msk (0x40UL)                 /*!< IO_CFG_IE_PWM2 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM2_IO_CFG_IS_PWM2_Pos (5UL)                    /*!< IO_CFG_IS_PWM2 (Bit 5)                                */
#define GPM_IO_CFG_PWM2_IO_CFG_IS_PWM2_Msk (0x20UL)                 /*!< IO_CFG_IS_PWM2 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM2_IO_CFG_SR_PWM2_Pos (4UL)                    /*!< IO_CFG_SR_PWM2 (Bit 4)                                */
#define GPM_IO_CFG_PWM2_IO_CFG_SR_PWM2_Msk (0x10UL)                 /*!< IO_CFG_SR_PWM2 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM2_IO_CFG_PE_PWM2_Pos (3UL)                    /*!< IO_CFG_PE_PWM2 (Bit 3)                                */
#define GPM_IO_CFG_PWM2_IO_CFG_PE_PWM2_Msk (0x8UL)                  /*!< IO_CFG_PE_PWM2 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM2_IO_CFG_PS_PWM2_Pos (2UL)                    /*!< IO_CFG_PS_PWM2 (Bit 2)                                */
#define GPM_IO_CFG_PWM2_IO_CFG_PS_PWM2_Msk (0x4UL)                  /*!< IO_CFG_PS_PWM2 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM2_IO_CFG_DS0_PWM2_Pos (1UL)                   /*!< IO_CFG_DS0_PWM2 (Bit 1)                               */
#define GPM_IO_CFG_PWM2_IO_CFG_DS0_PWM2_Msk (0x2UL)                 /*!< IO_CFG_DS0_PWM2 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_PWM2_IO_CFG_DS1_PWM2_Pos (0UL)                   /*!< IO_CFG_DS1_PWM2 (Bit 0)                               */
#define GPM_IO_CFG_PWM2_IO_CFG_DS1_PWM2_Msk (0x1UL)                 /*!< IO_CFG_DS1_PWM2 (Bitfield-Mask: 0x01)                 */
/* =========================================================  PWM3  ========================================================== */
#define GPM_IO_CFG_PWM3_IO_CFG_IE_PWM3_Pos (6UL)                    /*!< IO_CFG_IE_PWM3 (Bit 6)                                */
#define GPM_IO_CFG_PWM3_IO_CFG_IE_PWM3_Msk (0x40UL)                 /*!< IO_CFG_IE_PWM3 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM3_IO_CFG_IS_PWM3_Pos (5UL)                    /*!< IO_CFG_IS_PWM3 (Bit 5)                                */
#define GPM_IO_CFG_PWM3_IO_CFG_IS_PWM3_Msk (0x20UL)                 /*!< IO_CFG_IS_PWM3 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM3_IO_CFG_SR_PWM3_Pos (4UL)                    /*!< IO_CFG_SR_PWM3 (Bit 4)                                */
#define GPM_IO_CFG_PWM3_IO_CFG_SR_PWM3_Msk (0x10UL)                 /*!< IO_CFG_SR_PWM3 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM3_IO_CFG_PE_PWM3_Pos (3UL)                    /*!< IO_CFG_PE_PWM3 (Bit 3)                                */
#define GPM_IO_CFG_PWM3_IO_CFG_PE_PWM3_Msk (0x8UL)                  /*!< IO_CFG_PE_PWM3 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM3_IO_CFG_PS_PWM3_Pos (2UL)                    /*!< IO_CFG_PS_PWM3 (Bit 2)                                */
#define GPM_IO_CFG_PWM3_IO_CFG_PS_PWM3_Msk (0x4UL)                  /*!< IO_CFG_PS_PWM3 (Bitfield-Mask: 0x01)                  */
#define GPM_IO_CFG_PWM3_IO_CFG_DS0_PWM3_Pos (1UL)                   /*!< IO_CFG_DS0_PWM3 (Bit 1)                               */
#define GPM_IO_CFG_PWM3_IO_CFG_DS0_PWM3_Msk (0x2UL)                 /*!< IO_CFG_DS0_PWM3 (Bitfield-Mask: 0x01)                 */
#define GPM_IO_CFG_PWM3_IO_CFG_DS1_PWM3_Pos (0UL)                   /*!< IO_CFG_DS1_PWM3 (Bit 0)                               */
#define GPM_IO_CFG_PWM3_IO_CFG_DS1_PWM3_Msk (0x1UL)                 /*!< IO_CFG_DS1_PWM3 (Bitfield-Mask: 0x01)                 */
/* ======================================================  FLASH1_CS_N  ====================================================== */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_IE_FLASH1_CS_N_Pos (6UL)      /*!< IO_CFG_IE_FLASH1_CS_N (Bit 6)                         */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_IE_FLASH1_CS_N_Msk (0x40UL)   /*!< IO_CFG_IE_FLASH1_CS_N (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_IS_FLASH1_CS_N_Pos (5UL)      /*!< IO_CFG_IS_FLASH1_CS_N (Bit 5)                         */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_IS_FLASH1_CS_N_Msk (0x20UL)   /*!< IO_CFG_IS_FLASH1_CS_N (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_SR_FLASH1_CS_N_Pos (4UL)      /*!< IO_CFG_SR_FLASH1_CS_N (Bit 4)                         */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_SR_FLASH1_CS_N_Msk (0x10UL)   /*!< IO_CFG_SR_FLASH1_CS_N (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_PE_FLASH1_CS_N_Pos (3UL)      /*!< IO_CFG_PE_FLASH1_CS_N (Bit 3)                         */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_PE_FLASH1_CS_N_Msk (0x8UL)    /*!< IO_CFG_PE_FLASH1_CS_N (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_PS_FLASH1_CS_N_Pos (2UL)      /*!< IO_CFG_PS_FLASH1_CS_N (Bit 2)                         */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_PS_FLASH1_CS_N_Msk (0x4UL)    /*!< IO_CFG_PS_FLASH1_CS_N (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_DS0_FLASH1_CS_N_Pos (1UL)     /*!< IO_CFG_DS0_FLASH1_CS_N (Bit 1)                        */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_DS0_FLASH1_CS_N_Msk (0x2UL)   /*!< IO_CFG_DS0_FLASH1_CS_N (Bitfield-Mask: 0x01)          */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_DS1_FLASH1_CS_N_Pos (0UL)     /*!< IO_CFG_DS1_FLASH1_CS_N (Bit 0)                        */
#define GPM_IO_CFG_FLASH1_CS_N_IO_CFG_DS1_FLASH1_CS_N_Msk (0x1UL)   /*!< IO_CFG_DS1_FLASH1_CS_N (Bitfield-Mask: 0x01)          */
/* ======================================================  FLASH1_SCK  ======================================================= */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_IE_FLASH1_SCK_Pos (6UL)        /*!< IO_CFG_IE_FLASH1_SCK (Bit 6)                          */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_IE_FLASH1_SCK_Msk (0x40UL)     /*!< IO_CFG_IE_FLASH1_SCK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_IS_FLASH1_SCK_Pos (5UL)        /*!< IO_CFG_IS_FLASH1_SCK (Bit 5)                          */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_IS_FLASH1_SCK_Msk (0x20UL)     /*!< IO_CFG_IS_FLASH1_SCK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_SR_FLASH1_SCK_Pos (4UL)        /*!< IO_CFG_SR_FLASH1_SCK (Bit 4)                          */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_SR_FLASH1_SCK_Msk (0x10UL)     /*!< IO_CFG_SR_FLASH1_SCK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_PE_FLASH1_SCK_Pos (3UL)        /*!< IO_CFG_PE_FLASH1_SCK (Bit 3)                          */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_PE_FLASH1_SCK_Msk (0x8UL)      /*!< IO_CFG_PE_FLASH1_SCK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_PS_FLASH1_SCK_Pos (2UL)        /*!< IO_CFG_PS_FLASH1_SCK (Bit 2)                          */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_PS_FLASH1_SCK_Msk (0x4UL)      /*!< IO_CFG_PS_FLASH1_SCK (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_DS0_FLASH1_SCK_Pos (1UL)       /*!< IO_CFG_DS0_FLASH1_SCK (Bit 1)                         */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_DS0_FLASH1_SCK_Msk (0x2UL)     /*!< IO_CFG_DS0_FLASH1_SCK (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_DS1_FLASH1_SCK_Pos (0UL)       /*!< IO_CFG_DS1_FLASH1_SCK (Bit 0)                         */
#define GPM_IO_CFG_FLASH1_SCK_IO_CFG_DS1_FLASH1_SCK_Msk (0x1UL)     /*!< IO_CFG_DS1_FLASH1_SCK (Bitfield-Mask: 0x01)           */
/* ======================================================  FLASH1_IO0  ======================================================= */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_IE_FLASH1_IO0_Pos (6UL)        /*!< IO_CFG_IE_FLASH1_IO0 (Bit 6)                          */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_IE_FLASH1_IO0_Msk (0x40UL)     /*!< IO_CFG_IE_FLASH1_IO0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_IS_FLASH1_IO0_Pos (5UL)        /*!< IO_CFG_IS_FLASH1_IO0 (Bit 5)                          */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_IS_FLASH1_IO0_Msk (0x20UL)     /*!< IO_CFG_IS_FLASH1_IO0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_SR_FLASH1_IO0_Pos (4UL)        /*!< IO_CFG_SR_FLASH1_IO0 (Bit 4)                          */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_SR_FLASH1_IO0_Msk (0x10UL)     /*!< IO_CFG_SR_FLASH1_IO0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_PE_FLASH1_IO0_Pos (3UL)        /*!< IO_CFG_PE_FLASH1_IO0 (Bit 3)                          */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_PE_FLASH1_IO0_Msk (0x8UL)      /*!< IO_CFG_PE_FLASH1_IO0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_PS_FLASH1_IO0_Pos (2UL)        /*!< IO_CFG_PS_FLASH1_IO0 (Bit 2)                          */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_PS_FLASH1_IO0_Msk (0x4UL)      /*!< IO_CFG_PS_FLASH1_IO0 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_DS0_FLASH1_IO0_Pos (1UL)       /*!< IO_CFG_DS0_FLASH1_IO0 (Bit 1)                         */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_DS0_FLASH1_IO0_Msk (0x2UL)     /*!< IO_CFG_DS0_FLASH1_IO0 (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_DS1_FLASH1_IO0_Pos (0UL)       /*!< IO_CFG_DS1_FLASH1_IO0 (Bit 0)                         */
#define GPM_IO_CFG_FLASH1_IO0_IO_CFG_DS1_FLASH1_IO0_Msk (0x1UL)     /*!< IO_CFG_DS1_FLASH1_IO0 (Bitfield-Mask: 0x01)           */
/* ======================================================  FLASH1_IO1  ======================================================= */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_IE_FLASH1_IO1_Pos (6UL)        /*!< IO_CFG_IE_FLASH1_IO1 (Bit 6)                          */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_IE_FLASH1_IO1_Msk (0x40UL)     /*!< IO_CFG_IE_FLASH1_IO1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_IS_FLASH1_IO1_Pos (5UL)        /*!< IO_CFG_IS_FLASH1_IO1 (Bit 5)                          */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_IS_FLASH1_IO1_Msk (0x20UL)     /*!< IO_CFG_IS_FLASH1_IO1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_SR_FLASH1_IO1_Pos (4UL)        /*!< IO_CFG_SR_FLASH1_IO1 (Bit 4)                          */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_SR_FLASH1_IO1_Msk (0x10UL)     /*!< IO_CFG_SR_FLASH1_IO1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_PE_FLASH1_IO1_Pos (3UL)        /*!< IO_CFG_PE_FLASH1_IO1 (Bit 3)                          */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_PE_FLASH1_IO1_Msk (0x8UL)      /*!< IO_CFG_PE_FLASH1_IO1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_PS_FLASH1_IO1_Pos (2UL)        /*!< IO_CFG_PS_FLASH1_IO1 (Bit 2)                          */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_PS_FLASH1_IO1_Msk (0x4UL)      /*!< IO_CFG_PS_FLASH1_IO1 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_DS0_FLASH1_IO1_Pos (1UL)       /*!< IO_CFG_DS0_FLASH1_IO1 (Bit 1)                         */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_DS0_FLASH1_IO1_Msk (0x2UL)     /*!< IO_CFG_DS0_FLASH1_IO1 (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_DS1_FLASH1_IO1_Pos (0UL)       /*!< IO_CFG_DS1_FLASH1_IO1 (Bit 0)                         */
#define GPM_IO_CFG_FLASH1_IO1_IO_CFG_DS1_FLASH1_IO1_Msk (0x1UL)     /*!< IO_CFG_DS1_FLASH1_IO1 (Bitfield-Mask: 0x01)           */
/* ======================================================  FLASH1_IO2  ======================================================= */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_IE_FLASH1_IO2_Pos (6UL)        /*!< IO_CFG_IE_FLASH1_IO2 (Bit 6)                          */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_IE_FLASH1_IO2_Msk (0x40UL)     /*!< IO_CFG_IE_FLASH1_IO2 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_IS_FLASH1_IO2_Pos (5UL)        /*!< IO_CFG_IS_FLASH1_IO2 (Bit 5)                          */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_IS_FLASH1_IO2_Msk (0x20UL)     /*!< IO_CFG_IS_FLASH1_IO2 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_SR_FLASH1_IO2_Pos (4UL)        /*!< IO_CFG_SR_FLASH1_IO2 (Bit 4)                          */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_SR_FLASH1_IO2_Msk (0x10UL)     /*!< IO_CFG_SR_FLASH1_IO2 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_PE_FLASH1_IO2_Pos (3UL)        /*!< IO_CFG_PE_FLASH1_IO2 (Bit 3)                          */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_PE_FLASH1_IO2_Msk (0x8UL)      /*!< IO_CFG_PE_FLASH1_IO2 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_PS_FLASH1_IO2_Pos (2UL)        /*!< IO_CFG_PS_FLASH1_IO2 (Bit 2)                          */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_PS_FLASH1_IO2_Msk (0x4UL)      /*!< IO_CFG_PS_FLASH1_IO2 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_DS0_FLASH1_IO2_Pos (1UL)       /*!< IO_CFG_DS0_FLASH1_IO2 (Bit 1)                         */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_DS0_FLASH1_IO2_Msk (0x2UL)     /*!< IO_CFG_DS0_FLASH1_IO2 (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_DS1_FLASH1_IO2_Pos (0UL)       /*!< IO_CFG_DS1_FLASH1_IO2 (Bit 0)                         */
#define GPM_IO_CFG_FLASH1_IO2_IO_CFG_DS1_FLASH1_IO2_Msk (0x1UL)     /*!< IO_CFG_DS1_FLASH1_IO2 (Bitfield-Mask: 0x01)           */
/* ======================================================  FLASH1_IO3  ======================================================= */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_IE_FLASH1_IO3_Pos (6UL)        /*!< IO_CFG_IE_FLASH1_IO3 (Bit 6)                          */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_IE_FLASH1_IO3_Msk (0x40UL)     /*!< IO_CFG_IE_FLASH1_IO3 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_IS_FLASH1_IO3_Pos (5UL)        /*!< IO_CFG_IS_FLASH1_IO3 (Bit 5)                          */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_IS_FLASH1_IO3_Msk (0x20UL)     /*!< IO_CFG_IS_FLASH1_IO3 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_SR_FLASH1_IO3_Pos (4UL)        /*!< IO_CFG_SR_FLASH1_IO3 (Bit 4)                          */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_SR_FLASH1_IO3_Msk (0x10UL)     /*!< IO_CFG_SR_FLASH1_IO3 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_PE_FLASH1_IO3_Pos (3UL)        /*!< IO_CFG_PE_FLASH1_IO3 (Bit 3)                          */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_PE_FLASH1_IO3_Msk (0x8UL)      /*!< IO_CFG_PE_FLASH1_IO3 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_PS_FLASH1_IO3_Pos (2UL)        /*!< IO_CFG_PS_FLASH1_IO3 (Bit 2)                          */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_PS_FLASH1_IO3_Msk (0x4UL)      /*!< IO_CFG_PS_FLASH1_IO3 (Bitfield-Mask: 0x01)            */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_DS0_FLASH1_IO3_Pos (1UL)       /*!< IO_CFG_DS0_FLASH1_IO3 (Bit 1)                         */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_DS0_FLASH1_IO3_Msk (0x2UL)     /*!< IO_CFG_DS0_FLASH1_IO3 (Bitfield-Mask: 0x01)           */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_DS1_FLASH1_IO3_Pos (0UL)       /*!< IO_CFG_DS1_FLASH1_IO3 (Bit 0)                         */
#define GPM_IO_CFG_FLASH1_IO3_IO_CFG_DS1_FLASH1_IO3_Msk (0x1UL)     /*!< IO_CFG_DS1_FLASH1_IO3 (Bitfield-Mask: 0x01)           */
/* ========================================================  CLKOUT  ========================================================= */
#define GPM_IO_CFG_CLKOUT_IO_CFG_IE_CLKOUT_Pos (6UL)                /*!< IO_CFG_IE_CLKOUT (Bit 6)                              */
#define GPM_IO_CFG_CLKOUT_IO_CFG_IE_CLKOUT_Msk (0x40UL)             /*!< IO_CFG_IE_CLKOUT (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_CLKOUT_IO_CFG_IS_CLKOUT_Pos (5UL)                /*!< IO_CFG_IS_CLKOUT (Bit 5)                              */
#define GPM_IO_CFG_CLKOUT_IO_CFG_IS_CLKOUT_Msk (0x20UL)             /*!< IO_CFG_IS_CLKOUT (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_CLKOUT_IO_CFG_SR_CLKOUT_Pos (4UL)                /*!< IO_CFG_SR_CLKOUT (Bit 4)                              */
#define GPM_IO_CFG_CLKOUT_IO_CFG_SR_CLKOUT_Msk (0x10UL)             /*!< IO_CFG_SR_CLKOUT (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_CLKOUT_IO_CFG_PE_CLKOUT_Pos (3UL)                /*!< IO_CFG_PE_CLKOUT (Bit 3)                              */
#define GPM_IO_CFG_CLKOUT_IO_CFG_PE_CLKOUT_Msk (0x8UL)              /*!< IO_CFG_PE_CLKOUT (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_CLKOUT_IO_CFG_PS_CLKOUT_Pos (2UL)                /*!< IO_CFG_PS_CLKOUT (Bit 2)                              */
#define GPM_IO_CFG_CLKOUT_IO_CFG_PS_CLKOUT_Msk (0x4UL)              /*!< IO_CFG_PS_CLKOUT (Bitfield-Mask: 0x01)                */
#define GPM_IO_CFG_CLKOUT_IO_CFG_DS0_CLKOUT_Pos (1UL)               /*!< IO_CFG_DS0_CLKOUT (Bit 1)                             */
#define GPM_IO_CFG_CLKOUT_IO_CFG_DS0_CLKOUT_Msk (0x2UL)             /*!< IO_CFG_DS0_CLKOUT (Bitfield-Mask: 0x01)               */
#define GPM_IO_CFG_CLKOUT_IO_CFG_DS1_CLKOUT_Pos (0UL)               /*!< IO_CFG_DS1_CLKOUT (Bit 0)                             */
#define GPM_IO_CFG_CLKOUT_IO_CFG_DS1_CLKOUT_Msk (0x1UL)             /*!< IO_CFG_DS1_CLKOUT (Bitfield-Mask: 0x01)               */


/* =========================================================================================================================== */
/* ================                                        GPM_IO_PAR                                         ================ */
/* =========================================================================================================================== */

/* =========================================================  GPIO0  ========================================================= */
#define GPM_IO_PAR_GPIO0_GPIO0_Pos        (0UL)                     /*!< GPIO0 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO0_GPIO0_Msk        (0x3UL)                   /*!< GPIO0 (Bitfield-Mask: 0x03)                           */
/* =========================================================  GPIO1  ========================================================= */
#define GPM_IO_PAR_GPIO1_GPIO1_Pos        (0UL)                     /*!< GPIO1 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO1_GPIO1_Msk        (0x3UL)                   /*!< GPIO1 (Bitfield-Mask: 0x03)                           */
/* =========================================================  GPIO2  ========================================================= */
#define GPM_IO_PAR_GPIO2_GPIO2_Pos        (0UL)                     /*!< GPIO2 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO2_GPIO2_Msk        (0x3UL)                   /*!< GPIO2 (Bitfield-Mask: 0x03)                           */
/* =========================================================  GPIO3  ========================================================= */
#define GPM_IO_PAR_GPIO3_GPIO3_Pos        (0UL)                     /*!< GPIO3 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO3_GPIO3_Msk        (0x3UL)                   /*!< GPIO3 (Bitfield-Mask: 0x03)                           */
/* =========================================================  GPIO4  ========================================================= */
#define GPM_IO_PAR_GPIO4_GPIO4_Pos        (0UL)                     /*!< GPIO4 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO4_GPIO4_Msk        (0x3UL)                   /*!< GPIO4 (Bitfield-Mask: 0x03)                           */
/* =========================================================  GPIO5  ========================================================= */
#define GPM_IO_PAR_GPIO5_GPIO5_Pos        (0UL)                     /*!< GPIO5 (Bit 0)                                         */
#define GPM_IO_PAR_GPIO5_GPIO5_Msk        (0x3UL)                   /*!< GPIO5 (Bitfield-Mask: 0x03)                           */
/* ====================================================  RFFE_VDDIO_OUT  ===================================================== */
#define GPM_IO_PAR_RFFE_VDDIO_OUT_RFFE_VDDIO_OUT_Pos (0UL)          /*!< RFFE_VDDIO_OUT (Bit 0)                                */
#define GPM_IO_PAR_RFFE_VDDIO_OUT_RFFE_VDDIO_OUT_Msk (0x3UL)        /*!< RFFE_VDDIO_OUT (Bitfield-Mask: 0x03)                  */
/* =======================================================  RFFE_SCLK  ======================================================= */
#define GPM_IO_PAR_RFFE_SCLK_RFFE_SCLK_Pos (0UL)                    /*!< RFFE_SCLK (Bit 0)                                     */
#define GPM_IO_PAR_RFFE_SCLK_RFFE_SCLK_Msk (0x3UL)                  /*!< RFFE_SCLK (Bitfield-Mask: 0x03)                       */
/* ======================================================  RFFE_SDATA  ======================================================= */
#define GPM_IO_PAR_RFFE_SDATA_RFFE_SDATA_Pos (0UL)                  /*!< RFFE_SDATA (Bit 0)                                    */
#define GPM_IO_PAR_RFFE_SDATA_RFFE_SDATA_Msk (0x3UL)                /*!< RFFE_SDATA (Bitfield-Mask: 0x03)                      */
/* ========================================================  SC_RST  ========================================================= */
#define GPM_IO_PAR_SC_RST_SC_RST_Pos      (0UL)                     /*!< SC_RST (Bit 0)                                        */
#define GPM_IO_PAR_SC_RST_SC_RST_Msk      (0x3UL)                   /*!< SC_RST (Bitfield-Mask: 0x03)                          */
/* =========================================================  SC_IO  ========================================================= */
#define GPM_IO_PAR_SC_IO_SC_IO_Pos        (0UL)                     /*!< SC_IO (Bit 0)                                         */
#define GPM_IO_PAR_SC_IO_SC_IO_Msk        (0x3UL)                   /*!< SC_IO (Bitfield-Mask: 0x03)                           */
/* ========================================================  SC_CLK  ========================================================= */
#define GPM_IO_PAR_SC_CLK_SC_CLK_Pos      (0UL)                     /*!< SC_CLK (Bit 0)                                        */
#define GPM_IO_PAR_SC_CLK_SC_CLK_Msk      (0x3UL)                   /*!< SC_CLK (Bitfield-Mask: 0x03)                          */
/* ========================================================  SC_DET  ========================================================= */
#define GPM_IO_PAR_SC_DET_SC_DET_Pos      (0UL)                     /*!< SC_DET (Bit 0)                                        */
#define GPM_IO_PAR_SC_DET_SC_DET_Msk      (0x3UL)                   /*!< SC_DET (Bitfield-Mask: 0x03)                          */
/* ========================================================  SC_SWP  ========================================================= */
#define GPM_IO_PAR_SC_SWP_SC_SWP_Pos      (0UL)                     /*!< SC_SWP (Bit 0)                                        */
#define GPM_IO_PAR_SC_SWP_SC_SWP_Msk      (0x3UL)                   /*!< SC_SWP (Bitfield-Mask: 0x03)                          */
/* ========================================================  EJ_TCK  ========================================================= */
#define GPM_IO_PAR_EJ_TCK_EJ_TCK_Pos      (0UL)                     /*!< EJ_TCK (Bit 0)                                        */
#define GPM_IO_PAR_EJ_TCK_EJ_TCK_Msk      (0x3UL)                   /*!< EJ_TCK (Bitfield-Mask: 0x03)                          */
/* ========================================================  EJ_TMS  ========================================================= */
#define GPM_IO_PAR_EJ_TMS_EJ_TMS_Pos      (0UL)                     /*!< EJ_TMS (Bit 0)                                        */
#define GPM_IO_PAR_EJ_TMS_EJ_TMS_Msk      (0x3UL)                   /*!< EJ_TMS (Bitfield-Mask: 0x03)                          */
/* ========================================================  EJ_TRST  ======================================================== */
#define GPM_IO_PAR_EJ_TRST_EJ_TRST_Pos    (0UL)                     /*!< EJ_TRST (Bit 0)                                       */
#define GPM_IO_PAR_EJ_TRST_EJ_TRST_Msk    (0x3UL)                   /*!< EJ_TRST (Bitfield-Mask: 0x03)                         */
/* ========================================================  EJ_TDI  ========================================================= */
#define GPM_IO_PAR_EJ_TDI_EJ_TDI_Pos      (0UL)                     /*!< EJ_TDI (Bit 0)                                        */
#define GPM_IO_PAR_EJ_TDI_EJ_TDI_Msk      (0x3UL)                   /*!< EJ_TDI (Bitfield-Mask: 0x03)                          */
/* ========================================================  EJ_TDO  ========================================================= */
#define GPM_IO_PAR_EJ_TDO_EJ_TDO_Pos      (0UL)                     /*!< EJ_TDO (Bit 0)                                        */
#define GPM_IO_PAR_EJ_TDO_EJ_TDO_Msk      (0x3UL)                   /*!< EJ_TDO (Bitfield-Mask: 0x03)                          */
/* =======================================================  UART0_RX  ======================================================== */
#define GPM_IO_PAR_UART0_RX_UART0_RX_Pos  (0UL)                     /*!< UART0_RX (Bit 0)                                      */
#define GPM_IO_PAR_UART0_RX_UART0_RX_Msk  (0x3UL)                   /*!< UART0_RX (Bitfield-Mask: 0x03)                        */
/* =======================================================  UART0_TX  ======================================================== */
#define GPM_IO_PAR_UART0_TX_UART0_TX_Pos  (0UL)                     /*!< UART0_TX (Bit 0)                                      */
#define GPM_IO_PAR_UART0_TX_UART0_TX_Msk  (0x3UL)                   /*!< UART0_TX (Bitfield-Mask: 0x03)                        */
/* =======================================================  UART0_CTS  ======================================================= */
#define GPM_IO_PAR_UART0_CTS_UART0_CTS_Pos (0UL)                    /*!< UART0_CTS (Bit 0)                                     */
#define GPM_IO_PAR_UART0_CTS_UART0_CTS_Msk (0x3UL)                  /*!< UART0_CTS (Bitfield-Mask: 0x03)                       */
/* =======================================================  UART0_RTS  ======================================================= */
#define GPM_IO_PAR_UART0_RTS_UART0_RTS_Pos (0UL)                    /*!< UART0_RTS (Bit 0)                                     */
#define GPM_IO_PAR_UART0_RTS_UART0_RTS_Msk (0x3UL)                  /*!< UART0_RTS (Bitfield-Mask: 0x03)                       */
/* =======================================================  UART2_RX  ======================================================== */
#define GPM_IO_PAR_UART2_RX_UART2_RX_Pos  (0UL)                     /*!< UART2_RX (Bit 0)                                      */
#define GPM_IO_PAR_UART2_RX_UART2_RX_Msk  (0x3UL)                   /*!< UART2_RX (Bitfield-Mask: 0x03)                        */
/* =======================================================  UART2_TX  ======================================================== */
#define GPM_IO_PAR_UART2_TX_UART2_TX_Pos  (0UL)                     /*!< UART2_TX (Bit 0)                                      */
#define GPM_IO_PAR_UART2_TX_UART2_TX_Msk  (0x3UL)                   /*!< UART2_TX (Bitfield-Mask: 0x03)                        */
/* =======================================================  UART2_CTS  ======================================================= */
#define GPM_IO_PAR_UART2_CTS_UART2_CTS_Pos (0UL)                    /*!< UART2_CTS (Bit 0)                                     */
#define GPM_IO_PAR_UART2_CTS_UART2_CTS_Msk (0x3UL)                  /*!< UART2_CTS (Bitfield-Mask: 0x03)                       */
/* =======================================================  UART2_RTS  ======================================================= */
#define GPM_IO_PAR_UART2_RTS_UART2_RTS_Pos (0UL)                    /*!< UART2_RTS (Bit 0)                                     */
#define GPM_IO_PAR_UART2_RTS_UART2_RTS_Msk (0x3UL)                  /*!< UART2_RTS (Bitfield-Mask: 0x03)                       */
/* =======================================================  DEBUG_SEL  ======================================================= */
#define GPM_IO_PAR_DEBUG_SEL_DEBUG_SEL_Pos (0UL)                    /*!< DEBUG_SEL (Bit 0)                                     */
#define GPM_IO_PAR_DEBUG_SEL_DEBUG_SEL_Msk (0x3UL)                  /*!< DEBUG_SEL (Bitfield-Mask: 0x03)                       */
/* ======================================================  DEBUG_RSTN  ======================================================= */
#define GPM_IO_PAR_DEBUG_RSTN_DEBUG_RSTN_Pos (0UL)                  /*!< DEBUG_RSTN (Bit 0)                                    */
#define GPM_IO_PAR_DEBUG_RSTN_DEBUG_RSTN_Msk (0x3UL)                /*!< DEBUG_RSTN (Bitfield-Mask: 0x03)                      */
/* ======================================================  SPIM0_MOSI  ======================================================= */
#define GPM_IO_PAR_SPIM0_MOSI_SPIM0_MOSI_Pos (0UL)                  /*!< SPIM0_MOSI (Bit 0)                                    */
#define GPM_IO_PAR_SPIM0_MOSI_SPIM0_MOSI_Msk (0x3UL)                /*!< SPIM0_MOSI (Bitfield-Mask: 0x03)                      */
/* ======================================================  SPIM0_MISO  ======================================================= */
#define GPM_IO_PAR_SPIM0_MISO_SPIM0_MISO_Pos (0UL)                  /*!< SPIM0_MISO (Bit 0)                                    */
#define GPM_IO_PAR_SPIM0_MISO_SPIM0_MISO_Msk (0x3UL)                /*!< SPIM0_MISO (Bitfield-Mask: 0x03)                      */
/* =======================================================  SPIM0_EN0  ======================================================= */
#define GPM_IO_PAR_SPIM0_EN0_SPIM0_EN0_Pos (0UL)                    /*!< SPIM0_EN0 (Bit 0)                                     */
#define GPM_IO_PAR_SPIM0_EN0_SPIM0_EN0_Msk (0x3UL)                  /*!< SPIM0_EN0 (Bitfield-Mask: 0x03)                       */
/* =======================================================  SPIM0_EN1  ======================================================= */
#define GPM_IO_PAR_SPIM0_EN1_SPIM0_EN1_Pos (0UL)                    /*!< SPIM0_EN1 (Bit 0)                                     */
#define GPM_IO_PAR_SPIM0_EN1_SPIM0_EN1_Msk (0x3UL)                  /*!< SPIM0_EN1 (Bitfield-Mask: 0x03)                       */
/* =======================================================  SPIM0_CLK  ======================================================= */
#define GPM_IO_PAR_SPIM0_CLK_SPIM0_CLK_Pos (0UL)                    /*!< SPIM0_CLK (Bit 0)                                     */
#define GPM_IO_PAR_SPIM0_CLK_SPIM0_CLK_Msk (0x3UL)                  /*!< SPIM0_CLK (Bitfield-Mask: 0x03)                       */
/* ======================================================  SPIM1_MOSI  ======================================================= */
#define GPM_IO_PAR_SPIM1_MOSI_SPIM1_MOSI_Pos (0UL)                  /*!< SPIM1_MOSI (Bit 0)                                    */
#define GPM_IO_PAR_SPIM1_MOSI_SPIM1_MOSI_Msk (0x3UL)                /*!< SPIM1_MOSI (Bitfield-Mask: 0x03)                      */
/* ======================================================  SPIM1_MISO  ======================================================= */
#define GPM_IO_PAR_SPIM1_MISO_SPIM1_MISO_Pos (0UL)                  /*!< SPIM1_MISO (Bit 0)                                    */
#define GPM_IO_PAR_SPIM1_MISO_SPIM1_MISO_Msk (0x3UL)                /*!< SPIM1_MISO (Bitfield-Mask: 0x03)                      */
/* =======================================================  SPIM1_EN  ======================================================== */
#define GPM_IO_PAR_SPIM1_EN_SPIM1_EN_Pos  (0UL)                     /*!< SPIM1_EN (Bit 0)                                      */
#define GPM_IO_PAR_SPIM1_EN_SPIM1_EN_Msk  (0x3UL)                   /*!< SPIM1_EN (Bitfield-Mask: 0x03)                        */
/* =======================================================  SPIM1_CLK  ======================================================= */
#define GPM_IO_PAR_SPIM1_CLK_SPIM1_CLK_Pos (0UL)                    /*!< SPIM1_CLK (Bit 0)                                     */
#define GPM_IO_PAR_SPIM1_CLK_SPIM1_CLK_Msk (0x3UL)                  /*!< SPIM1_CLK (Bitfield-Mask: 0x03)                       */
/* =======================================================  I2C0_SDA  ======================================================== */
#define GPM_IO_PAR_I2C0_SDA_I2C0_SDA_Pos  (0UL)                     /*!< I2C0_SDA (Bit 0)                                      */
#define GPM_IO_PAR_I2C0_SDA_I2C0_SDA_Msk  (0x3UL)                   /*!< I2C0_SDA (Bitfield-Mask: 0x03)                        */
/* =======================================================  I2C0_SCL  ======================================================== */
#define GPM_IO_PAR_I2C0_SCL_I2C0_SCL_Pos  (0UL)                     /*!< I2C0_SCL (Bit 0)                                      */
#define GPM_IO_PAR_I2C0_SCL_I2C0_SCL_Msk  (0x3UL)                   /*!< I2C0_SCL (Bitfield-Mask: 0x03)                        */
/* =======================================================  I2C1_SDA  ======================================================== */
#define GPM_IO_PAR_I2C1_SDA_I2C1_SDA_Pos  (0UL)                     /*!< I2C1_SDA (Bit 0)                                      */
#define GPM_IO_PAR_I2C1_SDA_I2C1_SDA_Msk  (0x3UL)                   /*!< I2C1_SDA (Bitfield-Mask: 0x03)                        */
/* =======================================================  I2C1_SCL  ======================================================== */
#define GPM_IO_PAR_I2C1_SCL_I2C1_SCL_Pos  (0UL)                     /*!< I2C1_SCL (Bit 0)                                      */
#define GPM_IO_PAR_I2C1_SCL_I2C1_SCL_Msk  (0x3UL)                   /*!< I2C1_SCL (Bitfield-Mask: 0x03)                        */
/* ========================================================  PCM_CLK  ======================================================== */
#define GPM_IO_PAR_PCM_CLK_PCM_CLK_Pos    (0UL)                     /*!< PCM_CLK (Bit 0)                                       */
#define GPM_IO_PAR_PCM_CLK_PCM_CLK_Msk    (0x3UL)                   /*!< PCM_CLK (Bitfield-Mask: 0x03)                         */
/* ========================================================  PCM_FS  ========================================================= */
#define GPM_IO_PAR_PCM_FS_PCM_FS_Pos      (0UL)                     /*!< PCM_FS (Bit 0)                                        */
#define GPM_IO_PAR_PCM_FS_PCM_FS_Msk      (0x3UL)                   /*!< PCM_FS (Bitfield-Mask: 0x03)                          */
/* ========================================================  PCM_IN  ========================================================= */
#define GPM_IO_PAR_PCM_IN_PCM_IN_Pos      (0UL)                     /*!< PCM_IN (Bit 0)                                        */
#define GPM_IO_PAR_PCM_IN_PCM_IN_Msk      (0x3UL)                   /*!< PCM_IN (Bitfield-Mask: 0x03)                          */
/* ========================================================  PCM_OUT  ======================================================== */
#define GPM_IO_PAR_PCM_OUT_PCM_OUT_Pos    (0UL)                     /*!< PCM_OUT (Bit 0)                                       */
#define GPM_IO_PAR_PCM_OUT_PCM_OUT_Msk    (0x3UL)                   /*!< PCM_OUT (Bitfield-Mask: 0x03)                         */
/* =========================================================  PWM0  ========================================================== */
#define GPM_IO_PAR_PWM0_PWM0_Pos          (0UL)                     /*!< PWM0 (Bit 0)                                          */
#define GPM_IO_PAR_PWM0_PWM0_Msk          (0x3UL)                   /*!< PWM0 (Bitfield-Mask: 0x03)                            */
/* =========================================================  PWM1  ========================================================== */
#define GPM_IO_PAR_PWM1_PWM1_Pos          (0UL)                     /*!< PWM1 (Bit 0)                                          */
#define GPM_IO_PAR_PWM1_PWM1_Msk          (0x3UL)                   /*!< PWM1 (Bitfield-Mask: 0x03)                            */
/* =========================================================  PWM2  ========================================================== */
#define GPM_IO_PAR_PWM2_PWM2_Pos          (0UL)                     /*!< PWM2 (Bit 0)                                          */
#define GPM_IO_PAR_PWM2_PWM2_Msk          (0x3UL)                   /*!< PWM2 (Bitfield-Mask: 0x03)                            */
/* =========================================================  PWM3  ========================================================== */
#define GPM_IO_PAR_PWM3_PWM3_Pos          (0UL)                     /*!< PWM3 (Bit 0)                                          */
#define GPM_IO_PAR_PWM3_PWM3_Msk          (0x3UL)                   /*!< PWM3 (Bitfield-Mask: 0x03)                            */
/* ======================================================  FLASH1_CS_N  ====================================================== */
#define GPM_IO_PAR_FLASH1_CS_N_FLASH1_CS_N_Pos (0UL)                /*!< FLASH1_CS_N (Bit 0)                                   */
#define GPM_IO_PAR_FLASH1_CS_N_FLASH1_CS_N_Msk (0x3UL)              /*!< FLASH1_CS_N (Bitfield-Mask: 0x03)                     */
/* ======================================================  FLASH1_SCK  ======================================================= */
#define GPM_IO_PAR_FLASH1_SCK_FLASH1_SCK_Pos (0UL)                  /*!< FLASH1_SCK (Bit 0)                                    */
#define GPM_IO_PAR_FLASH1_SCK_FLASH1_SCK_Msk (0x3UL)                /*!< FLASH1_SCK (Bitfield-Mask: 0x03)                      */
/* ======================================================  FLASH1_IO0  ======================================================= */
#define GPM_IO_PAR_FLASH1_IO0_FLASH1_IO0_Pos (0UL)                  /*!< FLASH1_IO0 (Bit 0)                                    */
#define GPM_IO_PAR_FLASH1_IO0_FLASH1_IO0_Msk (0x3UL)                /*!< FLASH1_IO0 (Bitfield-Mask: 0x03)                      */
/* ======================================================  FLASH1_IO1  ======================================================= */
#define GPM_IO_PAR_FLASH1_IO1_FLASH1_IO1_Pos (0UL)                  /*!< FLASH1_IO1 (Bit 0)                                    */
#define GPM_IO_PAR_FLASH1_IO1_FLASH1_IO1_Msk (0x3UL)                /*!< FLASH1_IO1 (Bitfield-Mask: 0x03)                      */
/* ======================================================  FLASH1_IO2  ======================================================= */
#define GPM_IO_PAR_FLASH1_IO2_FLASH1_IO2_Pos (0UL)                  /*!< FLASH1_IO2 (Bit 0)                                    */
#define GPM_IO_PAR_FLASH1_IO2_FLASH1_IO2_Msk (0x3UL)                /*!< FLASH1_IO2 (Bitfield-Mask: 0x03)                      */
/* ======================================================  FLASH1_IO3  ======================================================= */
#define GPM_IO_PAR_FLASH1_IO3_FLASH1_IO3_Pos (0UL)                  /*!< FLASH1_IO3 (Bit 0)                                    */
#define GPM_IO_PAR_FLASH1_IO3_FLASH1_IO3_Msk (0x3UL)                /*!< FLASH1_IO3 (Bitfield-Mask: 0x03)                      */
/* ========================================================  CLKOUT  ========================================================= */
#define GPM_IO_PAR_CLKOUT_CLKOUT_Pos      (0UL)                     /*!< CLKOUT (Bit 0)                                        */
#define GPM_IO_PAR_CLKOUT_CLKOUT_Msk      (0x3UL)                   /*!< CLKOUT (Bitfield-Mask: 0x03)                          */
/* ========================================================  WAKEUP  ========================================================= */
#define GPM_IO_PAR_WAKEUP_WAKEUP_Pos      (0UL)                     /*!< WAKEUP (Bit 0)                                        */
#define GPM_IO_PAR_WAKEUP_WAKEUP_Msk      (0x3UL)                   /*!< WAKEUP (Bitfield-Mask: 0x03)                          */
/* ==========================================================  PB  =========================================================== */
#define GPM_IO_PAR_PB_PB_Pos              (0UL)                     /*!< PB (Bit 0)                                            */
#define GPM_IO_PAR_PB_PB_Msk              (0x3UL)                   /*!< PB (Bitfield-Mask: 0x03)                              */

/** @} */ /* End of group PosMask_peripherals */


#ifdef __cplusplus
}
#endif

#endif /* ALT1250_H */


/** @} */ /* End of group ALT1250 */

/** @} */ /* End of group Sony Semiconductor Israel */
